<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa con Leaflet, Catastro, GeoJSONs, MDT y Generación de Pasadas</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin="anonymous"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/geotiff.js/2.0.7/geotiff.min.js"></script>
    <style>
        /* Estilos por defecto para pantallas más grandes */
        #map {
            height: 500px;
            width: 80%;
            margin: 20px auto;
            border: 1px solid #ccc;
        }
        .container {
            position: relative;
            width: 80%;
            margin: 20px auto;
        }
        /* Estilo básico para los controles */
        .control-container {
            text-align: center;
            margin-bottom: 10px;
        }
        .control-container label, .control-container input, .control-container button {
            display: inline-block;
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            vertical-align: middle; /* Alinea verticalmente los elementos */
        }
         .control-container label {
             padding: 10px 5px; /* Ajuste de padding para la etiqueta */
             cursor: default;
        }
        .control-container input[type="number"] {
             width: 80px; /* Ancho fijo para el input number */
             padding: 10px;
        }
         #loading-status {
             margin-top: 10px;
             font-size: 1em;
             color: #555;
         }

        /* --- Estilos para el botón de localización --- */
        .leaflet-control-locate {
            position: absolute;
            z-index: 1000; /* Asegúrate de que esté por encima del mapa */
            bottom: 20px; /* Ajusta la posición vertical desde abajo */
            left: 50%; /* Centra horizontalmente */
            transform: translateX(-50%); /* Ajusta para centrar exactamente */
            /* Considera posicionarlo en una esquina si prefieres */
            /* bottom: 20px; right: 20px; left: auto; transform: none; */
        }

        .leaflet-control-locate button {
            background-color: #fff;
            border: 2px solid rgba(0,0,0,0.2);
            background-clip-padding: padding-box;
            min-width: 30px;
            min-height: 30px;
            line-height: 30px;
            margin: 0;
            padding: 0;
            text-align: center;
            text-decoration: none;
            color: #333;
            cursor: pointer;
            border-radius: 2px;
        }
         .leaflet-control-locate button i {
             font-size: 1.2em;
             width: 1em; /* Asegura que el icono tenga un ancho definido */
             height: 1em; /* Asegura que el icono tenga un alto definido */
             line-height: 1em; /* Centra el icono verticalmente */
         }


        /* --- Estilos para dispositivos móviles --- */
        @media (max-width: 600px) {
            #map {
                height: 70vh; /* Usa 70% del alto del viewport en pantallas pequeñas */
                width: 100%; /* Usa todo el ancho en pantallas pequeñas */
                margin: 0; /* Elimina márgenes horizontales */
                border: none; /* Elimina el borde si quieres que se vea completamente integrado */
            }
            .container {
                width: 100%; /* Usa todo el ancho en pantallas pequeñas */
                margin: 0; /* Elimina márgenes horizontales */
            }
            /* Ajusta otros estilos para móvil si es necesario, ej: tamaños de fuente, padding */
            .control-container {
                padding: 10px; /* Añade algo de padding para que no se pegue a los bordes */
            }
            .control-container label, .control-container input, .control-container button {
                display: block; /* Apila los controles verticalmente en pantallas pequeñas */
                margin: 5px auto; /* Centra los controles */
                width: 95%; /* Haz que los controles ocupen casi todo el ancho */
            }
             .control-container input[type="number"] {
                 width: 95%; /* Ajusta el ancho para el input number */
            }

             /* Ajusta la posición del botón de localización en móvil si es necesario */
            .leaflet-control-locate {
                bottom: 10px; /* Más abajo en móvil */
                 /* Mantener centrado horizontalmente o mover a esquina */
                 /* right: 10px; left: auto; transform: none; */
            }

        }
        /* --- Fin Estilos para dispositivos móviles --- */

        /* Estilo para el control de zoom */
        .leaflet-control-zoomlevel {
            background-color: #fff;
            border: 2px solid rgba(0,0,0,0.2);
            background-clip-padding: padding-box;
            padding: 4px 8px;
            text-align: center;
            font-size: 14px;
            cursor: default;
        }

    </style>
</head>
<body>

    <div class="control-container">
        <label for="workingWidth">Ancho de Trabajo (m):</label>
        <input type="number" id="workingWidth" value="15" min="1">
        <button id="generarPasadasBtn" disabled>Generar Pasadas</button>
        <div id="loading-status">Cargando datos geoespaciales iniciales...</div>
    </div>


    <div class="container">
        <div id="map"></div>
    </div>

    <div class="leaflet-control leaflet-control-locate">
        <button id="locateButton" title="Centrar en mi ubicación">
            <i class="fas fa-location-arrow"></i> </button>
    </div>


    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <script>
        console.log("Estado de 'turf' inmediatamente después del script tag:", typeof turf);
        if (typeof turf === 'undefined') {
             console.error("VERIFICACIÓN: 'turf' es undefined justo después del script tag. El script de Turf.js NO se cargó o ejecutó como se esperaba.");
        } else {
             console.log("VERIFICACIÓN: 'turf' parece estar definido. Tipo:", typeof turf);
        }
    </script>


    <script>
        // Vista inicial en Andalucía (ajustada para Ronda)
        const map = L.map('map').setView([36.7462, -5.1612], 14); // Vista ajustada

        // --- Variables ---
        let selectedLayer = null; // Variable para almacenar la capa (parcela) que está seleccionada
        let originalStyle = {}; // Variable para guardar el estilo original de cada capa de parcela
        let parcelasLayer = null; // Capa para parcelas (seleccionable) - Ahora usará subparcelas
        let construccionesLayer = null; // Capa para construcciones (exclusión)
        let elementosInternosLayer = null; // Capa para viales/arroyos/elementos internos (exclusión)
        let curvasNivelLayer = null; // Variable para la capa de curvas de nivel (ahora solo para visualización)
        let mdtGeoTiff = null; // Variable para almacenar el objeto GeoTIFF del MDT
        window.exclusionFeatures = []; // Declarada explícitamente en window
        let generatedPassesLayer = L.featureGroup().addTo(map); // Capa para las pasadas generadas
        let exclusionLayersLoaded = false; // Flag para saber si los datos de exclusión ya se cargaron
        window.curvasNivelGeoJSONData = null; // Variable para almacenar los datos de curvas de nivel GeoJSON (ahora solo para visualización)

        // --- Variables para localización GPS ---
        let locationMarker = null;
        let accuracyCircle = null;
        let lastKnownLocation = null; // Variable para guardar la última posición conocida
        let watchingLocation = false; // Flag para saber si watchPosition está activo
        let firstLocationObtained = false; // Flag para saber si ya obtuvimos la primera localización

        // --- Elementos de la interfaz ---
        const generarPasadasBtn = document.getElementById('generarPasadasBtn');
        const workingWidthInput = document.getElementById('workingWidth');
        const loadingStatusDiv = document.getElementById('loading-status'); // Referencia al indicador de carga
        const locateButton = document.getElementById('locateButton'); // Referencia al nuevo botón

        // --- CONSTANTES PARA GENERACIÓN DE PASADAS ---
        const STEEP_SLOPE_THRESHOLD = 40.0; // Porcentaje de pendiente para cambiar orientación de pasadas
        const MDT_SAMPLING_POINTS = 100; // Número de puntos a muestrear dentro de la parcela para altitud/pendiente


        // --- Capas base ---
        // Capa Minimalista (Se mantiene)
        const minimalBaseLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19
        });

        // Capa Satélite Esri (Se mantiene para el híbrido, pero se quita del selector de capas base)
         const satelliteLayer = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
              attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, GeoEye, Earthstar Geographics, CNES/Airbus DS, GeoEye, USDA FSA, USGS, AeroGRID, IGN, IGP, swisstopo, and the GIS User Community',
              maxZoom: 18
         });

        // Capa de Etiquetas Esri (Se mantiene para el híbrido)
         const esriOverlayLabels = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
             attribution: 'Esri, Garmin, FAO, NOAA, USGS',
             maxZoom: 17,
             transparent: true
           });

        // Capa Híbrida (Satélite + Etiquetas) (Se mantiene)
         const hybridEsriLayer = L.layerGroup([satelliteLayer, esriOverlayLabels]);


        // --- Capa de superposición WMS de la Dirección General del Catastro ---
        const catastroWmsUrl = 'https://ovc.catastro.meh.es/Cartografia/WMS/ServidorWMS.aspx';
        const catastroLayer = L.tileLayer.wms(catastroWmsUrl, {
            layers: 'Catastro',
            styles: '',
            format: 'image/png',
            transparent: true,
            attribution: 'Cartografía &copy; Dirección General del Catastro (España)',
            maxZoom: 20
        });

        // --- Añade capas iniciales al mapa ---
        // Mantenemos minimalBaseLayer como capa base por defecto
        minimalBaseLayer.addTo(map);
        catastroLayer.addTo(map);

        // --- Configura el control de capas (se actualizará al cargar GeoJSON) ---
        const baseLayers = {
            "Fondo Claro Minimalista": minimalBaseLayer,
            "Híbrido Satélite+Etiquetas (Esri)": hybridEsriLayer
        };

        const overlayLayers = {
             "Cartografía Catastral (WMS)": catastroLayer,
             "Pasadas Generadas": generatedPassesLayer
             // Las capas GeoJSON se añadirán aquí después de cargarse
        };

        let layersControl = L.control.layers(baseLayers, overlayLayers).addTo(map);

        // --- Control de nivel de zoom ---
        const zoomLevelControl = L.control({position: 'topleft'}); // <--- CAMBIADO A 'topleft'

        zoomLevelControl.onAdd = function (map) {
            this._div = L.DomUtil.create('div', 'leaflet-control-zoomlevel');
            this.update();
            return this._div;
        };

        zoomLevelControl.update = function () {
            this._div.innerHTML = 'Zoom: ' + map.getZoom();
        };

        zoomLevelControl.addTo(map);

        map.on('zoomend', function() {
            zoomLevelControl.update();
        });


        // --- Funciones de carga de GeoJSON y actualización de interfaz ---

        // Función para actualizar el control de capas
        function updateLayersControl() {
             if (layersControl) map.removeControl(layersControl);
             layersControl = L.control.layers(baseLayers, overlayLayers).addTo(map);
        }

        // Función para calcular altitud min/max/media y pendiente usando el MDT
        async function calculateMdtAltitudeAndSlope(parcelGeometry, geoTiff) {
            console.log("--- Iniciando cálculo de altitud/pendiente con MDT para parcela ---");
            const parcelProps = selectedLayer && selectedLayer.feature && selectedLayer.feature.properties ? selectedLayer.feature.properties : {};
            const poligono = parcelProps['MASA'] || parcelProps['poligono'] || parcelProps['POLIGONO'] || 'N/A';
            const parcela = parcelProps['PARCELA'] || parcelProps['parcela'] || parcelProps['ID_SUBPAR'] || 'N/A';
            const parcelId = `Polígono ${poligono}, Parcela ${parcela}`;

            if (!parcelGeometry || !geoTiff) {
                console.error(`[${parcelId}] Datos de entrada inválidos para cálculo con MDT.`);
                return { min: 'N/A', max: 'N/A', mean: 'N/A', slope: 'N/A (Datos Inválidos)' };
            }

            try {
                // Obtener la imagen del GeoTIFF (asumiendo que es la primera imagen)
                const image = await geoTiff.getImage();
                const geoKeys = image.getGeoKeys();
                const boundingBox = image.getBoundingBox(); // [west, south, east, north]
                const width = image.getWidth();
                const height = image.getHeight();
                const tiepoint = image.getTiePoints()[0];
                const pixelScale = image.getPixelScale()[0]; // Asumiendo que es el mismo para X e Y

                console.log(`[${parcelId}] MDT Image Info: BBox ${boundingBox}, Width ${width}, Height ${height}, PixelScale ${pixelScale}`);

                // Generar puntos de muestreo dentro de la parcela
                let pointsInParcel = [];
                const parcelFeature = turf.feature(parcelGeometry);
                const parcelArea = turf.area(parcelFeature, {units: 'meters'});

                if (parcelArea === 0) {
                     console.warn(`[${parcelId}] Área de la parcela es cero. No se pueden muestrear puntos.`);
                     return { min: 'N/A', max: 'N/A', mean: 'N/A', slope: 'N/A (Área Cero)' };
                }

                // Intentar generar puntos aleatorios dentro de la parcela
                // turf.randomPoint es más eficiente para generar puntos DENTRO de un polígono
                try {
                     const randomPoints = turf.randomPoint(MDT_SAMPLING_POINTS, { bbox: turf.bbox(parcelFeature) });
                      console.log(`[${parcelId}] Generados ${MDT_SAMPLING_POINTS} puntos aleatorios dentro del Bbox de la parcela.`);

                     // Filtrar los puntos que realmente caen dentro de la geometría de la parcela
                     randomPoints.features.forEach(point => {
                         try {
                             if (turf.booleanPointInPolygon(point, parcelFeature)) {
                                 pointsInParcel.push(point);
                             }
                         } catch(e) {
                             console.warn(`[${parcelId}] Error en booleanPointInPolygon para punto muestreado:`, point, e);
                         }
                     });
                     console.log(`[${parcelId}] ${pointsInParcel.length} puntos de muestreo caen dentro de la parcela.`);

                } catch(e) {
                     console.error(`[${parcelId}] Error generando puntos aleatorios con turf.randomPoint:`, e);
                     // Fallback: Si randomPoint falla, intentar generar puntos en una cuadrícula simple dentro del bbox y filtrar
                     console.log(`[${parcelId}] Intentando generar puntos en cuadrícula como fallback.`);
                     const bbox = turf.bbox(parcelFeature);
                     const bboxPoly = turf.bboxPolygon(bbox);
                     const cellSide = Math.sqrt(parcelArea / MDT_SAMPLING_POINTS) / 2; // Tamaño de celda basado en área
                     try {
                         const grid = turf.pointGrid(bbox, cellSide, { units: 'meters' });
                          console.log(`[${parcelId}] Generados ${grid.features.length} puntos en cuadrícula dentro del Bbox.`);
                         grid.features.forEach(point => {
                             try {
                                 if (turf.booleanPointInPolygon(point, parcelFeature)) {
                                     pointsInParcel.push(point);
                                 }
                             } catch(e) {
                                  console.warn(`[${parcelId}] Error en booleanPointInPolygon para punto de cuadrícula:`, point, e);
                             }
                         });
                          console.log(`[${parcelId}] ${pointsInParcel.length} puntos de cuadrícula caen dentro de la parcela.`);
                     } catch(e) {
                         console.error(`[${parcelId}] Error generando puntos en cuadrícula con turf.pointGrid:`, e);
                          console.error(`[${parcelId}] Fallo al generar puntos de muestreo. No se puede calcular altitud/pendiente con MDT.`);
                          return { min: 'N/A', max: 'N/A', mean: 'N/A', slope: 'N/A (Fallo Muestreo)' };
                     }
                }


                if (pointsInParcel.length === 0) {
                    console.warn(`[${parcelId}] No se generaron puntos de muestreo válidos dentro de la parcela.`);
                    return { min: 'N/A', max: 'N/A', mean: 'N/A', slope: 'N/A (Sin Puntos Muestreo)' };
                }

                let altitudes = [];
                const imageMathTransform = image.getGeoTransform(); // [x_origin, x_res, x_skew, y_origin, y_skew, y_res]

                // Función para convertir coordenadas geográficas (lon, lat) a coordenadas de píxel (x, y)
                function geoToPixel(lon, lat, transform) {
                    const [xOrigin, xRes, xSkew, yOrigin, ySkew, yRes] = transform;
                    // Invertir la transformación para ir de geo a pixel
                    // Usando la matriz inversa de la transformación afín
                    const determinant = xRes * yRes - xSkew * ySkew;
                    if (determinant === 0) {
                        console.error("Determinante cero en transformación GeoTIFF. No se puede convertir geo a pixel.");
                        return null;
                    }
                    const invDeterminant = 1 / determinant;

                    const dx = lon - xOrigin;
                    const dy = lat - yOrigin;

                    // Coordenadas de píxel (flotantes)
                    const pixelX = (dy * xSkew - dx * yRes) * invDeterminant;
                    const pixelY = (dx * ySkew - dy * xRes) * invDeterminant;

                    // Devolver coordenadas de píxel redondeadas (para acceder a los datos)
                    // Es posible que necesites interpolación para mayor precisión, pero para muestreo simple, redondear es suficiente.
                     // Asegurarse de que las coordenadas estén dentro de los límites de la imagen
                    const pixelXInt = Math.floor(pixelX);
                    const pixelYInt = Math.floor(pixelY);

                    if (pixelXInt >= 0 && pixelXInt < width && pixelYInt >= 0 && pixelYInt < height) {
                         return [pixelXInt, pixelYInt];
                    } else {
                         // console.warn(`[${parcelId}] Punto geográfico (${lon}, ${lat}) fuera de los límites del MDT.`);
                         return null; // Punto fuera de los límites del MDT
                    }
                }


                // Leer los datos de altitud de la imagen
                // Leer la banda 0 (la primera y a menudo única banda con datos de elevación)
                const raster = await image.readRasters({ samples: [0] });
                const elevationData = raster[0]; // Array 1D con los valores de altitud

                console.log(`[${parcelId}] Leyendo datos de altitud del MDT. Tamaño del raster: ${elevationData.length}`);


                // Obtener altitud para cada punto de muestreo
                pointsInParcel.forEach(point => {
                    const [lon, lat] = point.geometry.coordinates;
                    const pixelCoords = geoToPixel(lon, lat, imageMathTransform);

                    if (pixelCoords) {
                        const [pixelX, pixelY] = pixelCoords;
                        // Calcular el índice en el array 1D
                        const index = pixelY * width + pixelX;

                        if (index >= 0 && index < elevationData.length) {
                            const altitude = elevationData[index];
                             // Verificar si el valor de altitud es válido (no NaN, Infinity, etc.)
                             if (typeof altitude === 'number' && isFinite(altitude)) {
                                 altitudes.push(altitude);
                             } else {
                                  console.warn(`[${parcelId}] Valor de altitud inválido en píxel (${pixelX}, ${pixelY}):`, altitude);
                             }
                        } else {
                             console.warn(`[${parcelId}] Índice de píxel calculado (${index}) fuera de los límites del array de datos de elevación.`);
                        }
                    }
                });

                console.log(`[${parcelId}] Altitudes muestreadas válidas: ${altitudes.length}`);

                if (altitudes.length === 0) {
                    console.warn(`[${parcelId}] No se obtuvieron altitudes válidas de los puntos de muestreo.`);
                    return { min: 'N/A', max: 'N/A', mean: 'N/A', slope: 'N/A (Sin Altitudes Válidas)' };
                }

                // Calcular min, max y media
                const minElevation = Math.min(...altitudes);
                const maxElevation = Math.max(...altitudes);
                const meanElevation = altitudes.reduce((sum, val) => sum + val, 0) / altitudes.length;

                console.log(`[${parcelId}] Altitudes MDT: Min ${minElevation.toFixed(2)}m, Max ${maxElevation.toFixed(2)}m, Media ${meanElevation.toFixed(2)}m`);

                // Calcular pendiente
                const elevationDifference = maxElevation - minElevation;
                let horizontalDistance = 0;

                // Usar la dimensión más larga del bounding box de la parcela como distancia horizontal
                try {
                     const bbox = turf.bbox(parcelGeometry); // Usamos la geometría ORIGINAL para el bbox
                     const bboxWidth = turf.distance(turf.point([bbox[0], bbox[1]]), turf.point([bbox[2], bbox[1]]), {units: 'meters'});
                     const bboxHeight = turf.distance(turf.point([bbox[0], bbox[1]]), turf.point([bbox[0], bbox[3]]), {units: units});
                     horizontalDistance = Math.max(bboxWidth, bboxHeight);
                     console.log(`[${parcelId}] Distancia horizontal (dimensión máx Bbox parcela original): ${horizontalDistance.toFixed(2)} m`);

                } catch(e) {
                     console.error(`[${parcelId}] Error calculando Bbox para distancia horizontal de pendiente con MDT:`, e);
                      horizontalDistance = 0; // Fallback
                }


                let slopePercentage = 'N/A';
                // Calcula la pendiente solo si la distancia horizontal es mayor que cero
                if (horizontalDistance > 0) {
                    slopePercentage = (elevationDifference / horizontalDistance) * 100;
                    console.log(`[${parcelId}] Pendiente calculada con MDT: ${slopePercentage.toFixed(2)} %`);
                    slopePercentage = slopePercentage.toFixed(2); // Formato a 2 decimales
                } else {
                    console.warn(`[${parcelId}] Distancia horizontal es cero o inválida (${horizontalDistance}). No se puede calcular la pendiente con MDT.`);
                    slopePercentage = 'N/A (Distancia Cero)';
                }


                console.log("--- Fin cálculo de altitud/pendiente con MDT ---");
                return {
                    min: minElevation.toFixed(2),
                    max: maxElevation.toFixed(2),
                    mean: meanElevation.toFixed(2),
                    slope: slopePercentage
                };

            } catch (e) {
                console.error(`[${parcelId}] Error general durante el cálculo con MDT:`, e);
                return { min: 'N/A', max: 'N/A', mean: 'N/A', slope: 'N/A (Error Cálculo MDT)' };
            }
        }


        // Función para calcular el área de la parcela en hectáreas (se mantiene igual)
        function calculateAreaInHectares(parcelGeometry) {
             if (!parcelGeometry) {
                 return "N/A";
             }
             try {
                 const areaSqMeters = turf.area(parcelGeometry);
                 const areaHectares = areaSqMeters / 10000; // 1 hectárea = 10,000 m²
                 return areaHectares.toFixed(2); // Formatear a 2 decimales
             } catch (e) {
                 console.error("Error calculating area with Turf.js:", e);
                 return "Error";
             }
        }


        // --- Carga automática de los archivos iniciales (Parcelas, Curvas Nivel, MDT) al cargar la página ---
        document.addEventListener('DOMContentLoaded', function() {
            console.log("El DOM está cargado. Iniciando carga automática de datos geoespaciales iniciales.");
            loadingStatusDiv.textContent = 'Cargando datos geoespaciales iniciales...';
            generarPasadasBtn.disabled = true; // Asegurarse de que esté deshabilitado durante la carga

            // --- Iniciar localización GPS (independiente de la carga de datos geoespacialess) ---
             // Solo iniciamos watchPosition una vez al cargar si el navegador lo soporta
             if (navigator.geolocation) {
                 if (!watchingLocation) {
                     console.log("Iniciando observación de localización GPS...");
                     watchingLocation = true; // Marca que watchPosition está activo
                     navigator.geolocation.watchPosition(onLocationFound, onLocationError, {
                         enableHighAccuracy: true,
                         timeout: 10000,
                         maximumAge: 0
                     });
                     loadingStatusDiv.textContent += ' y buscando localización...'; // Añadir estado de localización

                 } else {
                     console.log("watchPosition ya está activo.");
                      if (lastKnownLocation) {
                           loadingStatusDiv.textContent += ' Localización encontrada.';
                      } else {
                           loadingStatusDiv.textContent += ' Buscando localización...';
                      }
                 }
             } else {
                 console.log("Tu navegador no soporta geolocalización.");
                 loadingStatusDiv.textContent += ' Error: Geolocalización no soportada.';
                 alert("Tu navegador no soporta la funcionalidad de geolocalización necesaria.");
             }


            // *** LAS URLs DE TUS ARCHIVOS GEOESPACIALES ***
            // URL ACTUALIZADA PARA USAR EL ARCHIVO DE SUBPARCELAS
            const parcelasGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/parcela/refs/heads/main/SUBPARCE.json'; // URL DE SUBPARCELAS (seleccionable)
            const construccionesGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/parcela/refs/heads/main/CONSTRU.json'; // URL DE CONSTRUCCIONES (exclusión)
            const elementosInternosGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/parcela/refs/heads/main/ELEMLIN.json'; // URL DE ELEMENTOS INTERNOS (exclusión - puede necesitar buffer)
            const curvasNivelGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/parcela/refs/heads/main/BTN0201L_CUR_NIV.json'; // URL CORRECTA DE CURVAS DE NIVEL (GeoJSON) - Ahora solo para visualización
            const mdtGeoTiffDataUrl = 'https://raw.githubusercontent.com/tinajita/parcela/refs/heads/main/MDT25-ETRS89-H30-1051-1-COB2.tif'; // URL CORRECTA DEL MDT (TIFF)
             // *** FIN URLs ***

            // Cargar Parcelas (Subparcelas), Curvas de Nivel (para visualización) y MDT (para cálculo)
            Promise.all([
                fetch(parcelasGeojsonDataUrl).then(response => {
                     if (!response.ok) throw new Error(`Error al cargar Subparcelas: ${response.statusText}`);
                     return response.json();
                }),
                 fetch(curvasNivelGeojsonDataUrl).then(response => {
                      if (!response.ok) throw new Error(`Error al cargar Curvas de Nivel: ${response.statusText}`);
                      return response.json();
                 }),
                 // Cargar el MDT como ArrayBuffer para geotiff.js
                 fetch(mdtGeoTiffDataUrl).then(response => {
                      if (!response.ok) {
                          // Intenta detectar si es un error común de CORS
                          if (response.status === 0) {
                               throw new Error(`Error de red o CORS al cargar MDT. Asegúrate de que el servidor (${new URL(mdtGeoTiffDataUrl).origin}) permite CORS.`);
                          } else {
                               throw new Error(`Error HTTP ${response.status} al cargar MDT: ${response.statusText}`);
                          }
                      }
                      console.log("MDT (TIFF) fetch successful. Status:", response.status);
                      return response.arrayBuffer(); // Leer como ArrayBuffer
                 })
            ])
            .then(async ([parcelasGeojsonData, curvasNivelGeoJSONData, mdtArrayBuffer]) => { // Usar async aquí
                console.log("Los archivos Subparcelas, Curvas de Nivel y MDT se cargaron con éxito (primer paso de fetch/json/arrayBuffer).");

                // --- Cargar el MDT (TIFF) con geotiff.js ---
                 console.log("Abriendo MDT (TIFF) con geotiff.js...");
                 try {
                     mdtGeoTiff = await GeoTIFF.fromArrayBuffer(mdtArrayBuffer);
                     console.log("MDT (TIFF) abierto con éxito por geotiff.js.");
                     // No añadimos el MDT como capa visual por defecto, pero está disponible para cálculos.
                     // Si quisieras visualizarlo, necesitarías lógica adicional (ej. usando leaflet-geotiff)
                 } catch(e) {
                     console.error("Error abriendo MDT (TIFF) con geotiff.js:", e);
                      if (!loadingStatusDiv.textContent.startsWith('Error:')) {
                         loadingStatusDiv.textContent += ' Advertencia: Fallo al abrir MDT TIFF.';
                       }
                      alert("Advertencia: Fallo al procesar el archivo MDT. Los cálculos de altitud y pendiente usarán el método basado en curvas de nivel (si hay suficientes).");
                      mdtGeoTiff = null; // Asegurar que sea null si falla la carga/apertura
                 }
                // --- Fin carga MDT ---


                // --- Código para cargar la capa de curvas de nivel (GeoJSON) ---
                 console.log("Inspeccionando y cargando capa de Curvas de Nivel...");
                  if (curvasNivelGeoJSONData && curvasNivelGeoJSONData.type === 'FeatureCollection' && Array.isArray(curvasNivelGeoJSONData.features)) {
                       // Store the GeoJSON data globally or accessible for calculation
                       window.curvasNivelGeoJSONData = curvasNivelGeoJSONData; // Make it accessible (aunque ahora priorizamos MDT)
                       curvasNivelLayer = L.geoJSON(curvasNivelGeoJSONData, {
                           style: function(feature) {
                                return {
                                    color: '#a0522d',
                                    weight: 0.5,
                                    opacity: 0.3
                                };
                           }
                           // Popups for individual contour lines are removed as requested,
                           // info will be aggregated for the parcel popup.
                           // onEachFeature: function(feature, layer) { ... } is removed
                       }).addTo(map);
                       overlayLayers["Curvas de Nivel (Visual)"] = curvasNivelLayer; // Renombrar
                       console.log(`Curvas de Nivel cargadas en Leaflet. Número de features: ${curvasNivelGeoJSONData.features.length}.`);

                  } else {
                      console.warn("Datos de Curvas de Nivel no son un FeatureCollection válido o están vacíos. No se cargarán las curvas.", curvasNivelGeoJSONData);
                       if (!loadingStatusDiv.textContent.startsWith('Error:') && !loadingStatusDiv.textContent.includes('Advertencia:')) {
                         loadingStatusDiv.textContent += ' Advertencia: Datos de Curvas de Nivel inválidos.';
                       }
                 }
                // --- Fin del código para curvas de nivel ---


                // --- Inspeccionar y cargar capa de Subparcelas (Seleccionable) ---
                console.log("Inspeccionando y cargando capa de Subparcelas...");
                 if (parcelasGeojsonData && parcelasGeojsonData.type === 'FeatureCollection' && Array.isArray(parcelasGeojsonData.features)) {
                     parcelasLayer = L.geoJSON(parcelasGeojsonData, {
                         style: feature => ({ color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 }), // Estilo por defecto
                         onEachFeature: (feature, layer) => {
                             const defaultStyle = { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 };
                             originalStyle[layer._leaflet_id] = defaultStyle; // Guardar el estilo por defecto

                             layer.on({
                                 click: async e => { // Usar async aquí para await calculateMdtAltitudeAndSlope
                                     // Siempre deseleccionar la capa previamente seleccionada y restablecer su estilo
                                     if (selectedLayer) {
                                         selectedLayer.setStyle(originalStyle[selectedLayer._leaflet_id] || { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 });
                                         // Cerrar el popup de la capa previamente seleccionada si está abierto
                                         if (selectedLayer.getPopup() && selectedLayer.getPopup().isOpen()) {
                                             selectedLayer.closePopup();
                                         }
                                     }

                                     // Seleccionar la nueva capa visualmente y actualizar la variable selectedLayer
                                     layer.setStyle({ color: '#00FFFF', weight: 3, fillColor: '#00FFFF', fillOpacity: 0.3 }); // Estilo de selección
                                     selectedLayer = layer;
                                     generarPasadasBtn.disabled = false; // Habilitar botón de generar pasadas
                                     console.log("Subparcela seleccionada:", feature.properties);

                                     // Verificar si el nivel de zoom es 14 o superior antes de mostrar el popup
                                     if (map.getZoom() >= 14) {
                                         // Construir el contenido del popup
                                         let popupContent = '<b>Subparcela Seleccionada:</b><br>';
                                         // Ajusta las claves según las propiedades de tu archivo SUBPARCE.json
                                         let poligono = feature.properties['MASA'] || feature.properties['poligono'] || feature.properties['POLIGONO'] || 'N/A';
                                         let parcela = feature.properties['PARCELA'] || feature.properties['parcela'] || feature.properties['ID_SUBPAR'] || 'N/A'; // Usar ID_SUBPAR u otra clave relevante

                                         popupContent += `Polígono: ${poligono}<br>`;
                                         popupContent += `Parcela/Subparcela: ${parcela}<br>`;

                                          // Calcular y añadir información de altitud y pendiente (PRIORIZANDO MDT)
                                          let altitudeSlopeInfo = { min: 'N/A', max: 'N/A', mean: 'N/A', slope: 'N/A (Error)' };
                                          if (mdtGeoTiff) {
                                               loadingStatusDiv.textContent = 'Calculando altitud/pendiente con MDT...';
                                               altitudeSlopeInfo = await calculateMdtAltitudeAndSlope(feature.geometry, mdtGeoTiff);
                                               loadingStatusDiv.textContent = 'Datos iniciales cargados. Localización encontrada. Subparcela seleccionada.'; // Restaurar estado
                                          } else {
                                               loadingStatusDiv.textContent = 'Calculando altitud/pendiente con Curvas de Nivel...';
                                                // Fallback a curvas de nivel si el MDT no está disponible o falló
                                               const slopeInfoContour = calculateSlopeInfo(feature.geometry, window.curvasNivelGeoJSONData);
                                               const meanAltitudeContour = calculateMeanAltitude(feature.geometry, window.curvasNivelGeoJSONData);
                                               altitudeSlopeInfo = {
                                                    min: slopeInfoContour.min,
                                                    max: slopeInfoContour.max,
                                                    mean: meanAltitudeContour,
                                                    slope: slopeInfoContour.slope + ' (Curvas Nivel)' // Indicar que es por curvas
                                               };
                                               loadingStatusDiv.textContent = 'Datos iniciales cargados. Localización encontrada. Subparcela seleccionada.'; // Restaurar estado
                                          }


                                          popupContent += `Altitud Mínima (MDT): ${altitudeSlopeInfo.min} m<br>`;
                                          popupContent += `Altitud Máxima (MDT): ${altitudeSlopeInfo.max} m<br>`;
                                          popupContent += `Altitud Media (MDT): ${altitudeSlopeInfo.mean} m<br>`;
                                          popupContent += `Pendiente Estimada (MDT): ${altitudeSlopeInfo.slope} %<br>`;


                                          // Calcular y añadir área en hectáreas
                                          const areaHa = calculateAreaInHectares(feature.geometry);
                                          popupContent += `Área: ${areaHa} Ha`;

                                         layer.bindPopup(popupContent).openPopup();

                                     } else {
                                          // Si el zoom es demasiado bajo, solo seleccionar la capa visualmente sin mostrar popup
                                          console.log("Nivel de zoom demasiado bajo para mostrar información del popup. Se requiere Zoom >= 14.");
                                     }


                                     L.DomEvent.stopPropagation(e);
                                 }
                             });
                         }
                     }).addTo(map);
                     overlayLayers["Mis Subparcelas"] = parcelasLayer; // Renombrar en el control de capas
                     console.log(`Subparcelas cargadas en Leaflet. Número de features en datos brutos: ${parcelasGeojsonData.features.length}`);
                 } else {
                     console.error("Datos de Subparcelas no son un FeatureCollection válido o están vacíos.", parcelasGeojsonData);
                      loadingStatusDiv.textContent = 'Error: Datos de Subparcelas inválidos.'; // Sobrescribir si hay error de carga de datos
                     alert("Error: El archivo de Subparcelas no contiene un FeatureCollection válido. No se pueden cargar las subparcelas.");
                 }


                 // Actualizar el control de capas con las capas iniciales cargadas
                updateLayersControl();

                // Ajustar la vista del mapa a la extensión de las Subparcelas si se cargaron
                if (parcelasLayer && parcelasLayer.getBounds().isValid()) {
                     map.fitBounds(parcelasLayer.getBounds());
                     console.log("Mapa ajustado a la extensión de las subparcelas.");
                } else {
                     console.warn("No se pudieron obtener bounds válidos de la capa de subparcelas. Ajustando vista a Ronda...");
                      map.setView([36.7462, -5.1612], 14); // Fallback
                }

                // Actualizar el mensaje de estado solo si no hay errores de carga de datos y watchPosition ya se intentó iniciar
                if (!loadingStatusDiv.textContent.startsWith('Error:') && !loadingStatusDiv.textContent.includes('Advertencia:')) {
                     if (watchingLocation) {
                           if (lastKnownLocation) {
                               loadingStatusDiv.textContent = 'Datos iniciales cargados. Localización encontrada. Selecciona una subparcela.';
                           } else {
                                loadingStatusDiv.textContent = 'Datos iniciales cargados. Buscando localización...';
                           }
                     } else {
                         loadingStatusDiv.textContent = 'Datos iniciales cargados. Geolocalización no soportada o no iniciada. Selecciona una subparcela.';
                     }
                }

                console.log("Carga automática de datos iniciales finalizada. Selecciona una subparcela para habilitar la generación de pasadas.");


            })
            .catch(error => {
                console.error("Error durante la carga automática de datos geoespaciales iniciales:", error);
                loadingStatusDiv.textContent = `Error al cargar datos iniciales: ${error.message}`;
                alert(`Ocurrió un error al cargar uno o más archivos geoespaciales iniciales. Revisa las URLs y la consola para más detalles. Error: ${error.message}`);
            });
        });


        // --- LÓGICA PARA GENERAR PASADAS OPTIMIZADAS USANDO TURF.JS ---

        generarPasadasBtn.addEventListener('click', function() {

            // --- VERIFICACIÓN DE TURF ---
            console.log("Estado de 'turf' al hacer clic en Generar Pasadas:", typeof turf);
            if (typeof turf === 'undefined') {
                console.error("Error: La biblioteca Turf.js no se cargó correctamente.");
                alert("Error: La biblioteca Turf.js no está disponible. No se pueden generar pasadas. Revisa la consola.");
                return;
            }
            // --- FIN VERIFICACIÓN ---

            console.log("--- Inicio Generación de Pasadas ---");
            loadingStatusDiv.textContent = 'Generando pasadas...';
            generarPasadasBtn.disabled = true; // Deshabilitar el botón durante la generación

            // Asegurarse de que haya una subparcela seleccionada y sea un polígono válido
            if (!selectedLayer || !selectedLayer.feature || !selectedLayer.feature.geometry || (selectedLayer.feature.geometry.type !== 'Polygon' && selectedLayer.feature.geometry.type !== 'MultiPolygon')) {
                alert("Por favor, selecciona una subparcela válida haciendo clic en ella primero.");
                console.warn("selectedLayer no es una subparcela válida o no tiene geometría poligonal:", selectedLayer);
                loadingStatusDiv.textContent = 'Selecciona una subparcela.';
                generarPasadasBtn.disabled = false; // Re-habilitar si no hay subparcela seleccionada
                return;
            }

             // --- Cargar datos de exclusión si no se han cargado ya ---
             if (!exclusionLayersLoaded) {
                 console.log("Datos de exclusión aún no cargados. Iniciando carga de CONSTRU.json y ELEMLIN.json.");
                 loadingStatusDiv.textContent = 'Cargando datos de exclusión...';

                 const construccionesGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/parcela/refs/heads/main/CONSTRU.json';
                 const elementosInternosGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/parcela/refs/heads/main/ELEMLIN.json';
                 const units = 'meters';
                 const bufferDistanceForLines = 2;

                 Promise.all([
                     fetch(construccionesGeojsonDataUrl).then(response => {
                         if (!response.ok) throw new Error(`Error al cargar Construcciones: ${response.statusText}`);
                         return response.json();
                     }),
                     fetch(elementosInternosGeojsonDataUrl).then(response => {
                         if (!response.ok) throw new Error(`Error al cargar Elementos Internos: ${response.statusText}`);
                         return response.json();
                     })
                 ])
                 .then(([construccionesGeojsonData, elementosInternosGeojsonData]) => {
                     console.log("Archivos de exclusión CONSTRU.json y ELEMLIN.json cargados.");

                     window.exclusionFeatures = []; // Limpiar por si acaso, aunque debería estar vacío

                     // --- Cargar capa de Construcciones y recopilar geometrías de exclusión ---
                     console.log("Inspeccionando y cargando capa de Construcciones...");
                      if (construccionesGeojsonData && construccionesGeojsonData.type === 'FeatureCollection' && Array.isArray(construccionesGeojsonData.features)) {
                           // Eliminar capa anterior si existe
                            if (construccionesLayer) map.removeLayer(construccionesLayer);

                           construccionesLayer = L.geoJSON(construccionesGeojsonData, {
                               style: feature => ({ color: '#FF0000', weight: 2, fillColor: '#FF0000', fillOpacity: 0.5 }),
                                onEachFeature: (feature, layer) => {
                                   if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                                      const clonedFeature = JSON.parse(JSON.stringify(feature));
                                       window.exclusionFeatures.push(clonedFeature);
                                  } else {
                                       console.warn("Geometría de construcción no es Polígono/MultiPolígono. No se usará para recorte:", feature.geometry);
                                  }
                               }
                           }).addTo(map);
                           overlayLayers["Construcciones"] = construccionesLayer; // Añadir al control de capas
                           console.log(`Construcciones cargadas en Leaflet. Número de features: ${construccionesGeojsonData.features.length}.`);
                      } else {
                          console.warn("Datos de Construcciones no son un FeatureCollection válido o están vacíos. No se cargarán construcciones.", construccionesGeojsonData);
                      }


                     // --- Cargar capa de Elementos Internos y recopilar geometrías de exclusión (con buffer si son líneas) ---
                      console.log("Inspeccionando y cargando capa de Elementos Internos...");
                       if (elementosInternosGeojsonData && elementosInternosGeojsonData.type === 'FeatureCollection' && Array.isArray(elementosInternosGeojsonData.features)) {
                            // Eliminar capa anterior si existe
                             if (elementosInternosLayer) map.removeLayer(elementosInternosLayer);

                           elementosInternosLayer = L.geoJSON(elementosInternosGeojsonData, {
                               style: feature => {
                                     if (feature.geometry && feature.geometry.type === 'LineString') {
                                          return { color: '#0000FF', weight: 2, opacity: 0.8 };
                                     } else if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                                          return { color: '#006400', weight: 1, fillColor: '#006400', fillOpacity: 0.3 };
                                     }
                                     return { color: '#888888', weight: 1, opacity: 0.5 };
                                },
                               onEachFeature: (feature, layer) => {
                                   if (feature.geometry) {
                                       if (feature.geometry.type === 'LineString') {
                                           try {
                                               const buffered = turf.buffer(feature, bufferDistanceForLines, {units: units});
                                                if (buffered && buffered.geometry && (buffered.geometry.type === 'Polygon' || buffered.geometry.type === 'MultiPolygon')) {
                                                     const bufferedFeature = JSON.parse(JSON.stringify(buffered));
                                                     window.exclusionFeatures.push(bufferedFeature);
                                                      console.log(`LineString de Elementos Internos bufferizado a ${buffered.geometry.type} y añadido como exclusión.`);
                                                } else {
                                                    console.warn("El buffer de LineString de Elementos Internos no resultó en una geometría válida (Polygon/MultiPolygon) para exclusión. No se usará para recorte:", buffered);
                                                }
                                           } catch (e) {
                                                console.error("Error al crear buffer para LineString de Elementos Internos:", feature, e);
                                                console.warn("Error al crear buffer para LineString de Elemento Interno. No se usará para recorte.");
                                           }

                                       } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                                           const clonedFeature = JSON.parse(JSON.stringify(feature));
                                           window.exclusionFeatures.push(clonedFeature);
                                            console.log(`Polygon/MultiPolygon de Elementos Internos añadido como exclusión.`);
                                       } else {
                                            console.warn(`Geometría de Elemento Interno (${feature.geometry.type}) no es LineString, Polígono o MultiPolígono. No se usará para recorte:`, feature.geometry);
                                       }
                                   }
                               }
                           }).addTo(map);
                           overlayLayers["Viales y Arroyos"] = elementosInternosLayer;
                           console.log(`Elementos Internos cargados en Leaflet. Número de features: ${elementosInternosGeojsonData.features.length}.`);
                       } else {
                           console.warn("Datos de Elementos Internos no son un FeatureCollection válido o están vacíos. No se cargarán elementos internos.", elementosInternosGeojsonData);
                       }

                     console.log(`Total features de exclusión recopiladas de Construcciones y Elementos Internos: ${window.exclusionFeatures.length}`);
                     exclusionLayersLoaded = true; // Marcar que los datos de exclusión ya se cargaron
                     updateLayersControl(); // Actualizar control de capas con las nuevas capas

                     // Continuar con la generación de pasadas ahora que los datos de exclusión están cargados
                     generatePassesLogic();

                 })
                 .catch(error => {
                     console.error("Error durante la carga de datos de exclusión:", error);
                     loadingStatusDiv.textContent = `Error al cargar datos de exclusión: ${error.message}`;
                     alert(`Ocurrió un error al cargar los archivos de exclusión. No se generarán pasadas con exclusiones. Revisa la consola para más detalles. Error: ${error.message}`);
                     // Continuar con la generación de pasadas pero sin datos de exclusión
                     window.exclusionFeatures = []; // Asegurar que esté vacío si hubo error
                     exclusionLayersLoaded = true; // Marcar como cargado para no intentar de nuevo
                     generatePassesLogic(); // Intentar generar pasadas sin exclusiones

                 });

             } else {
                  // Si los datos de exclusión ya se cargaron, simplemente continuar con la lógica de generación
                  console.log("Datos de exclusión ya cargados. Procediendo con la generación de pasadas.");
                  generatePassesLogic();
             }

        });

        // --- Función separada para la lógica principal de generación de pasadas ---
        async function generatePassesLogic() { // Usar async aquí
             console.log("--- Inicio Lógica de Generación de Pasadas ---");
             console.log("Estado de window.exclusionFeatures al inicio de generatePassesLogic:", window.exclusionFeatures ? window.exclusionFeatures.length : 'undefined/null', window.exclusionFeatures);

             const selectedParcelGeoJSON = selectedLayer.toGeoJSON();
             let parcelGeometry = selectedParcelGeoJSON.geometry;
             const parcelFeature = turf.feature(parcelGeometry);

             generatedPassesLayer.clearLayers();
             console.log("Limpiando pasadas generadas anteriormente.");

             const workingWidth = parseFloat(workingWidthInput.value);
             if (isNaN(workingWidth) || workingWidth <= 0) {
                  alert("Por favor, introduce un valor válido y positivo para el ancho de trabajo.");
                  console.error("Valor inválido para ancho de trabajo:", workingWidthInput.value);
                   loadingStatusDiv.textContent = 'Valor de ancho de trabajo inválido.';
                   generarPasadasBtn.disabled = false;
                  return;
             }

             const units = 'meters';

             // *** INCIO MODIFICACIÓN POR PENDIENTE (USANDO MDT) ***
             let currentSlopePercentage = null;
             if (mdtGeoTiff) {
                  loadingStatusDiv.textContent = 'Calculando pendiente con MDT para orientación de pasadas...';
                  const altitudeSlopeInfo = await calculateMdtAltitudeAndSlope(parcelGeometry, mdtGeoTiff);
                  currentSlopePercentage = parseFloat(altitudeSlopeInfo.slope);
                  console.log(`Pendiente de la parcela (MDT) para generación de pasadas: ${altitudeSlopeInfo.slope}%`);
                   // Restaurar estado del loadingStatusDiv, pero mantener el mensaje de "Generando pasadas..." después
                  loadingStatusDiv.textContent = 'Generando pasadas...';

             } else {
                  // Fallback a curvas de nivel si MDT no está disponible
                  loadingStatusDiv.textContent = 'Calculando pendiente con Curvas de Nivel para orientación de pasadas...';
                  const slopeInfoContour = calculateSlopeInfo(parcelGeometry, window.curvasNivelGeoJSONData);
                  currentSlopePercentage = parseFloat(slopeInfoContour.slope);
                  console.log(`Pendiente de la parcela (Curvas Nivel) para generación de pasadas: ${slopeInfoContour.slope}%`);
                   // Restaurar estado del loadingStatusDiv, pero mantener el mensaje de "Generando pasadas..." después
                   loadingStatusDiv.textContent = 'Generando pasadas...';
             }

             // *** FIN MODIFICACIÓN POR PENDIENTE (USANDO MDT) ***


             try {
                 let intersectingExclusionFeatures = [];
                 const globalExclusionFeatures = window.exclusionFeatures || [];


                  if (globalExclusionFeatures.length > 0) {
                      console.log(`Total features de exclusión cargadas globalmente: ${globalExclusionFeatures.length}`);
                      console.log(`Filtrando features de exclusión para encontrar las que intersectan con la parcela seleccionada.`);
                       globalExclusionFeatures.forEach((exclusionFeature, index) => {
                          if (exclusionFeature.geometry && (exclusionFeature.geometry.type === 'Polygon' || exclusionFeature.geometry.type === 'MultiPolygon')) {
                               try {
                                  if (turf.booleanIntersects(parcelFeature, exclusionFeature)) {
                                     intersectingExclusionFeatures.push(exclusionFeature);
                                  }
                               } catch (e) {
                                   console.warn(`Error al verificar intersección para feature de exclusión #${index}. Se omitirá.`, exclusionFeature, e);
                               }
                          } else {
                               console.warn(`Geometría de feature de exclusión #${index} (${exclusionFeature.geometry ? exclusionFeature.geometry.type : 'null/undefined'}) no es Polígono/MultiPolígono válido para intersección. Se omitirá.`, exclusionFeature);
                          }
                       });
                  } else {
                      console.log("No se cargaron features de exclusión globalmente (window.exclusionFeatures está vacío) o hubo errores en la carga.");
                  }
                 console.log(`Features de exclusión que intersectan con la parcela: ${intersectingExclusionFeatures.length}`);


                  let simplifiedExclusionFeatures = [];
                  if (intersectingExclusionFeatures.length > 0) {
                      const tinySimplificationTolerance = 0.000001;
                      console.log(`Aplicando mínima simplificación (${tinySimplificationTolerance} grados) a ${intersectingExclusionFeatures.length} features de exclusión que intersectan.`);
                      simplifiedExclusionFeatures = intersectingExclusionFeatures.map(feature => {
                            try {
                                 if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                                       const simplified = turf.simplify(feature, { tolerance: tinySimplificationTolerance, highQuality: true });

                                       if (simplified && simplified.geometry && (simplified.geometry.type === 'Polygon' || simplified.geometry.type === 'MultiPolygon' || simplified.geometry.type === 'GeometryCollection')) {
                                            if (simplified.geometry.type === 'GeometryCollection') {
                                                 let validGeomsInGC = [];
                                                 turf.geomEach(simplified.geometry, function(geom) {
                                                     if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
                                                         validGeomsInGC.push(turf.feature(geom));
                                                     }
                                                 });
                                                 if (validGeomsInGC.length > 0) {
                                                      let consolidatedFeature = null;
                                                       if (validGeomsInGC.length === 1) {
                                                            consolidatedFeature = validGeomsInGC[0];
                                                            console.log("Simplificación mínima: GC consolidado es 1 polígono. Usando directamente.");
                                                       } else {
                                                            try {
                                                                 consolidatedFeature = turf.union(...validGeomsInGC);
                                                                console.log("Simplificación mínima: GC consolidado de múltiples polígonos. Resultado tipo unión:", consolidatedFeature ? consolidatedFeature.geometry.type : 'null/undefined');
                                                            } catch(e) {
                                                                console.error("Error al unir partes válidas de GC:", e);
                                                                console.warn("Simplificación mínima: Falló unión de partes válidas en GC. Devolviendo null.");
                                                                consolidatedFeature = null;
                                                            }
                                                       }

                                                     if(consolidatedFeature && consolidatedFeature.geometry && (consolidatedFeature.geometry.type === 'Polygon' || consolidatedFeature.geometry.type === 'MultiPolygon')) {
                                                          if (turf.area(consolidatedFeature) > 0) {
                                                             return consolidatedFeature;
                                                         } else {
                                                              console.warn("Simplificación mínima: GC consolidado tiene área 0.", consolidatedFeature);
                                                             return null;
                                                         }
                                                     } else {
                                                         console.warn("Simplificación mínima: La unión de partes válidas en GC no resultó en Polygon/MultiPolygon.", consolidatedFeature);
                                                         return null;
                                                     }
                                                 } else {
                                                     console.warn("Simplificación mínima: GeometryCollection resultante no contiene polígonos válidos.", simplified);
                                                     return null;
                                                 }
                                            } else {
                                                if (turf.area(simplified) > 0) {
                                                    return simplified;
                                                 } else {
                                                     console.warn("Simplificación mínima: Resultado directo (Polygon/MultiPolygon) tiene área 0.", simplified);
                                                     return null;
                                                 }
                                            }
                                       } else {
                                             console.warn("Simplificación mínima: turf.simplify devolvió un resultado no válido o nulo.", simplified);
                                             return null;
                                       }
                                   } else {
                                        console.warn("Simplificación mínima: La feature de exclusión no es Polygon/MultiPolígono. Devolviendo null.");
                                        return null;
                                   }

                              } catch (e) {
                                   console.error("Error durante la simplificación mínima de una feature de exclusión:", feature, e);
                                   console.warn("Simplificación mínima fallida para feature de exclusión. Se omitirá.");
                                   return null;
                              }
                          }).filter(feature => feature !== null);

                          console.log(`Quedan ${simplifiedExclusionFeatures.length} features de exclusión VÁLIDAS después de la mínima simplificación.`);

                  } else {
                       console.log("No hay features de exclusión que intersecten para simplificar.");
                  }


                 let geometryForCalculations = parcelGeometry;
                 let unionOfExclusions = null;
                 let unionGeometryForDifference = null;


                 if (simplifiedExclusionFeatures.length === 0) {
                      console.log("No hay features de exclusión simplificadas válidas. No se excluirán zonas a evitar.");
                  } else if (simplifiedExclusionFeatures.length === 1) {
                      console.log("Solo 1 feature de exclusión simplificada. Usando esta directamente para la diferencia.");
                      unionOfExclusions = simplifiedExclusionFeatures[0];
                      if (unionOfExclusions && unionOfExclusions.geometry && (unionOfExclusions.geometry.type === 'Polygon' || unionOfExclusions.geometry.type === 'MultiPolygon')) {
                           unionGeometryForDifference = unionOfExclusions.geometry;
                           console.log("Feature única de exclusión es Polígono/MultiPolígono válido para la diferencia.");
                      } else {
                            console.warn("La única feature de exclusión simplificada no es Polígono/MultiPolígono válido. No se excluirán zonas a evitar.");
                            geometryForCalculations = parcelGeometry;
                             alert("Advertencia: El área a evitar no es una geometría válida. Generando pasadas sobre la parcela completa.");
                      }

                  } else { // simplifiedExclusionFeatures.length > 1
                       console.log(`Más de 1 feature de exclusión simplificada (${simplifiedExclusionFeatures.length}). Calculando unión...`);
                      try {
                          // console.log("Input (STRINGIFIED) para turf.union:", JSON.stringify(simplifiedExclusionFeatures)); // Puede ser muy grande
                          unionOfExclusions = turf.union(...simplifiedExclusionFeatures);
                          // console.log("Resultado (STRINGIFIED) de turf.union:", JSON.stringify(unionOfExclusions)); // Puede ser muy grande

                          if (unionOfExclusions && unionOfExclusions.geometry) {
                              if (unionOfExclusions.geometry.type === 'Polygon' || unionOfExclusions.geometry.type === 'MultiPolygon' || unionOfExclusions.geometry.type === 'GeometryCollection') {

                                  let unionGeometryForDifference = null;

                                   if (unionOfExclusions.geometry.type === 'GeometryCollection') {
                                       console.warn("La unión de áreas a evitar resultó en un GeometryCollection. Intentando extraer polígonos válidos para la diferencia.");
                                        let validGeometries = [];
                                        turf.geomEach(unionOfExclusions.geometry, function(geom) {
                                            if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
                                                validGeometries.push(turf.feature(geom));
                                            }
                                        });

                                        if (validGeometries.length > 0) {
                                             let consolidatedUnion = null;
                                              if (validGeometries.length === 1) {
                                                  consolidatedUnion = validGeometries[0];
                                                  console.log("GeometryCollection consolidado es 1 polígono. Usando directamente.");
                                              } else {
                                                  try {
                                                       consolidatedUnion = turf.union(...validGeometries);
                                                      console.log("GeometryCollection consolidado de múltiples polígonos. Resultado tipo unión:", consolidatedUnion ? consolidatedUnion.geometry.type : 'null/undefined');
                                                  } catch(e) {
                                                       console.error("Error al intentar unir polígonos válidos dentro de GeometryCollection:", e);
                                                        console.warn("Error procesando GeometryCollection de unión. Devolviendo null.");
                                                        consolidatedUnion = null;
                                                   }
                                              }

                                              if (consolidatedUnion && consolidatedUnion.geometry && (consolidatedUnion.geometry.type === 'Polygon' || consolidatedUnion.geometry.type === 'MultiPolygon')) {
                                                  unionGeometryForDifference = consolidatedUnion.geometry;
                                                   console.log("Polígonos válidos de GeometryCollection unidos con éxito para la diferencia. Tipo resultado unión:", unionGeometryForDifference.type);
                                              } else {
                                                  console.warn("La re-unión de polígonos válidos dentro del GeometryCollection no resultó en un polígono válido. Usando solo el polígono más grande.", consolidatedUnion);
                                                  unionGeometryForDifference = null;
                                              }
                                         } else {
                                              console.warn("GeometryCollection de unión no contiene polígonos válidos para usar en la diferencia. No se excluirán zonas a evitar.", unionOfExclusions);
                                              unionGeometryForDifference = null;
                                         }

                                    } else {
                                         unionGeometryForDifference = unionOfExclusions.geometry;
                                          console.log("Unión de exclusiones es un Polígono/MultiPolígono válido. Usando este para la diferencia.");
                                    }

                                   if (!unionGeometryForDifference) {
                                       console.warn("No se pudo obtener una geometría de unión válida para la diferencia después de procesar el resultado de turf.union. Usando geometría original de la parcela.");
                                       geometryForCalculations = parcelGeometry;
                                        alert("Advertencia: El área a evitar no es una geometría válida. Generando pasadas sobre la parcela completa.");
                                        // return; // No retornar, intentar seguir sin exclusiones
                                   }


                               } else {
                                    console.warn(`El resultado de turf.union tiene geometría (${unionOfExclusions.geometry.type}), pero no es un tipo válido (Polygon, MultiPolygon, GeometryCollection) para la diferencia. No se excluirán zonas a evitar.`, unionOfExclusions);
                                    geometryForCalculations = parcelGeometry;
                                     alert("Advertencia: La unión de áreas a evitar resultó en una geometría de tipo inesperado. Generando pasadas sobre la parcela completa.");
                                    // return; // No retornar
                               }

                          } else {
                               console.warn("El resultado de turf.union fue nulo o no tiene geometría. No se excluirán zonas a evitar.", unionOfExclusions);
                               geometryForCalculations = parcelGeometry;
                               alert("Advertencia: La unión de áreas a evitar devolvió un resultado vacío. Generando pasadas sobre la parcela completa.");
                                // return; // No retornar
                          }

                      } catch (e) {
                          console.error("Error general en turf.union o procesamiento subsiguiente:", e);
                          console.warn("Ocurrió un error al calcular la unión de áreas a evitar. Usando geometría original de la parcela.");
                          geometryForCalculations = parcelGeometry;
                          alert("Advertencia: Ocurrió un error al calcular la unión de áreas a evitar. Generando pasadas sobre la parcela completa. Revisa la consola.");
                        //   return; // No retornar
                      }
                  }

                  if (unionGeometryForDifference) {
                        console.log(`Calculando área limpia: Diferencia entre parcela seleccionada y área de unión de exclusiones.`);
                        try {
                            const unionFeatureForDifference = turf.feature(unionGeometryForDifference);
                            const parcelFeature = turf.feature(parcelGeometry);
                             const cleanedArea = turf.difference(parcelFeature, unionFeatureForDifference);

                             console.log("Resultado de turf.difference (Área limpia):", JSON.stringify(cleanedArea));

                             if (cleanedArea && cleanedArea.geometry) {
                                  const areaCalculated = turf.area(cleanedArea);
                                  console.log("Tipo de geometría del área limpia:", cleanedArea.geometry.type, "Área:", areaCalculated, units);

                                  if ((cleanedArea.geometry.type === 'Polygon' || cleanedArea.geometry.type === 'MultiPolygon' || cleanedArea.geometry.type === 'GeometryCollection') && areaCalculated > 0) {
                                       if (cleanedArea.geometry.type === 'GeometryCollection') {
                                            console.warn("Área limpia resultante es GeometryCollection. Intentando consolidar para el barrido.");
                                             let validGeomsInCleanedArea = [];
                                             turf.geomEach(cleanedArea.geometry, function(geom) {
                                                 if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
                                                     validGeomsInCleanedArea.push(turf.feature(geom));
                                                 }
                                             });

                                             if (validGeomsInCleanedArea.length > 0) {
                                                  let consolidatedCleanArea = null;
                                                   if (validGeomsInCleanedArea.length === 1) {
                                                        consolidatedCleanArea = validGeomsInCleanedArea[0];
                                                        console.log("GeometryCollection de área limpia consolidado es 1 polígono. Usando directamente.");
                                                   } else {
                                                        try {
                                                             consolidatedCleanArea = turf.union(...validGeomsInCleanedArea);
                                                            console.log("GeometryCollection de área limpia consolidado de múltiples polígonos. Resultado tipo unión:", consolidatedCleanArea ? consolidatedCleanArea.geometry.type : 'null/undefined');
                                                        } catch(e) {
                                                             console.error("Error al consolidar GeometryCollection resultante de difference:", e);
                                                              console.warn("Error procesando el área limpia compleja. Devolviendo null.");
                                                              consolidatedCleanArea = null;
                                                        }
                                                   }

                                                   if (consolidatedCleanArea && consolidatedCleanArea.geometry && (consolidatedCleanArea.geometry.type === 'Polygon' || consolidatedCleanArea.geometry.type === 'MultiPolygon')) {
                                                       geometryForCalculations = consolidatedCleanArea.geometry;
                                                        console.log("Área limpia (parcela - exclusiones) consolidada a:", geometryForCalculations.type, ". Usando para cálculos.");
                                                   } else {
                                                       console.warn("La consolidación del GeometryCollection resultante del difference no produjo Polygon/MultiPolygon válido. No se excluirán zonas a evitar.", consolidatedCleanArea);
                                                       geometryForCalculations = parcelGeometry;
                                                       alert("Advertencia: No se pudo procesar el área limpia compleja. Generando pasadas sobre la parcela completa.");
                                                   }

                                              } else {
                                                   console.warn("El GeometryCollection resultante de difference no contiene polígonos válidos para el barrido. No se excluirán zonas a evitar.", cleanedArea);
                                                  geometryForCalculations = parcelGeometry;
                                                   alert("Advertencia: El área limpia resultante no contiene polígonos válidos. Generando pasadas sobre la parcela completa.");
                                              }

                                       } else {
                                          geometryForCalculations = cleanedArea.geometry;
                                          console.log(`Área limpia (parcela - exclusiones) calculada con éxito. Tipo: ${geometryForCalculations.type}, Área > 0. Usando para cálculos.`);
                                       }

                                  } else {
                                       console.warn("El área resultante de turf.difference no es un polígono/multipolígono/GC válido o tiene área 0. No se excluirán zonas a evitar.", cleanedArea);
                                       geometryForCalculations = parcelGeometry;
                                        if (areaCalculated === 0) {
                                             console.log("Advertencia: La parcela seleccionada parece estar completamente cubierta por áreas a evitar (área limpia = 0).");
                                             alert("Advertencia: La parcela seleccionada parece estar completamente cubierta por áreas a evitar. No se pueden generar pasadas útiles.");
                                             console.log("Revirtiendo a geometría original de la parcela según la lógica actual.");
                                             geometryForCalculations = parcelGeometry;
                                        } else {
                                              console.warn("Advertencia: El área limpia resultante no es una geometría válida para generar pasadas.");
                                              geometryForCalculations = parcelGeometry;
                                               alert("Advertencia: El área limpia resultante no es una geometría válida para generar pasadas. Generando pasadas sobre la parcela completa.");
                                        }
                                  }

                             } else {
                                  console.warn("El resultado de turf.difference no tiene una geometría válida. No se excluirán zonas a evitar.", cleanedArea);
                                 geometryForCalculations = parcelGeometry;
                                  alert("Advertencia: El resultado del cálculo de áreas a evitar no es válido. Generando pasadas sobre la parcela completa.");
                             }
                        } catch (e) {
                             console.error("Error durante el cálculo de diferencia de geometrías:", e);
                             console.warn("Ocurrió un error al excluir zonas a evitar. Usando geometría original de la parcela.");
                             geometryForCalculations = parcelGeometry;
                             alert("Advertencia: Ocurrió un error al excluir zonas a evitar. Generando pasadas sobre la parcela completa. Revisa la consola.");
                        }
                  } else {
                      console.log("No se pudo calcular un área limpia válida (probablemente no hay exclusiones válidas o hubo un error en el procesamiento de la unión). Usando geometría original de la parcela.");
                  }


                 let finalGeometryToSweep = geometryForCalculations;
                 console.log("Intentando simplificar la geometría final para el barrido...");
                 console.log("Geometría ANTES de simplificar:", JSON.stringify(geometryForCalculations));

                 if (!geometryForCalculations || !geometryForCalculations.type) {
                      console.error("La geometría para simplificar es nula, undefined o de tipo incorrecto. Deteniendo proceso.");
                       alert("Error: La geometría resultante para generar pasadas no es válida.");
                        loadingStatusDiv.textContent = 'Error en geometría para pasadas.';
                        generarPasadasBtn.disabled = false;
                       return;
                 }

                 try {
                     const simplificationTolerance = 0.00005;

                     const featureToSimplify = turf.feature(geometryForCalculations);

                      if (featureToSimplify) {
                           const simplifiedFeature = turf.simplify(featureToSimplify, {
                                tolerance: simplificationTolerance,
                                highQuality: true
                           });

                            console.log("Resultado de turf.simplify:", JSON.stringify(simplifiedFeature));

                            if (simplifiedFeature && simplifiedFeature.geometry && (simplifiedFeature.geometry.type === 'Polygon' || simplifiedFeature.geometry.type === 'MultiPolygon')) {
                                finalGeometryToSweep = simplifiedFeature.geometry;
                                console.log("Geometría final simplificada con éxito. Tipo:", finalGeometryToSweep.type);
                            } else {
                                 console.warn("El resultado de turf.simplify no es un polígono o multipolígono válido. Usando geometría sin simplificar.", simplifiedFeature);
                                 finalGeometryToSweep = geometryForCalculations;
                                 alert("Advertencia: No se pudo simplificar la geometría resultante del área limpia. Generando pasadas con geometría detallada (puede ser más lento).");
                            }
                      } else {
                          console.warn("No se pudo crear una feature para simplificar. Usando geometría sin simplificar.");
                          finalGeometryToSweep = geometryForCalculations;
                           alert("Advertencia: No se pudo crear Feature para simplificar. Generando pasadas con geometría detallada.");
                      }


                 } catch (e) {
                     console.error("Error durante la simplificación de geometría:", e);
                     console.warn("No se pudo simplificar la geometría final. Usando geometría sin simplificar.");
                     finalGeometryToSweep = geometryForCalculations;
                     alert("Advertencia: Ocurrió un error al simplificar la geometría. Generando pasadas con geometría detallada (puede ser más lento). Revisa la consola.");
                 }


                 let geometryForSweepAndPiP = null;
                 if (finalGeometryToSweep && (finalGeometryToSweep.type === 'Polygon' || finalGeometryToSweep.type === 'MultiPolygon')) {
                      geometryForSweepAndPiP = finalGeometryToSweep;

                      if (geometryForSweepAndPiP.type === 'MultiPolygon') {
                          console.log("La geometría final para el barrido es un MultiPolygon. Intentando usar el polígono más grande o su unión.");
                          let largestPoly = null;
                          let maxPolyArea = 0;
                          let validPolygonsInMulti = [];

                          if (geometryForSweepAndPiP.coordinates && Array.isArray(geometryForSweepAndPiP.coordinates)) {
                              geometryForSweepAndPiP.coordinates.forEach(polyCoords => {
                                  try {
                                      const currentPoly = turf.polygon(polyCoords);
                                       let area = turf.area(currentPoly);
                                        validPolygonsInMulti.push(turf.feature(currentPoly.geometry));
                                      if (area > maxPolyArea) {
                                          maxPolyArea = area;
                                          largestPoly = currentPoly.geometry;
                                      }
                                  } catch (e) {
                                     console.warn("Error procesando un polígono dentro del MultiPolygon final:", e);
                                  }
                              });
                          } else {
                               console.error("Las coordenadas del MultiPolygon final no son válidas.");
                          }


                          if (largestPoly) {
                              if (validPolygonsInMulti.length > 0) {
                                  if (validPolygonsInMulti.length > 1) {
                                      console.log(`MultiPolygon contiene ${validPolygonsInMulti.length} polígonos válidos. Intentando unirlos para el barrido.`);
                                      try {
                                           const unionOfMultiParts = turf.union(...validPolygonsInMulti);
                                            if (unionOfMultiParts && unionOfMultiParts.geometry && (unionOfMultiParts.geometry.type === 'Polygon' || unionOfMultiParts.geometry.type === 'MultiPolygon')) {
                                                geometryForSweepAndPiP = unionOfMultiParts.geometry;
                                                 console.log("Polígonos del MultiPolygon unidos con éxito para el barrido. Resultado:", geometryForSweepAndPiP.type);
                                            } else {
                                                 console.warn("La unión de las partes del MultiPolygon no resultó en un polígono/multipolígono válido. Usando solo el polígono más grande.", unionOfMultiParts);
                                                 geometryForSweepAndPiP = largestPoly;
                                            }
                                      } catch (e) {
                                           console.error("Error al intentar unir las partes del MultiPolygon:", e);
                                            console.warn("Error al unir las partes del MultiPolygon. Usando solo el polígono más grande.");
                                            geometryForSweepAndPiP = largestPoly;
                                      }
                                  } else {
                                      geometryForSweepAndPiP = largestPoly;
                                      console.log("MultiPolygon con 1 polígono válido encontrado. Usando este para el barrido.");
                                  }
                              } else {
                                    console.error("MultiPolygon resultante no contiene polígonos válidos después de procesar las partes.");
                                    alert("Error procesando la geometría para el barrido. No se encontraron polígonos válidos dentro del MultiPolygon.");
                                     loadingStatusDiv.textContent = 'Error procesando geometría.';
                                     generarPasadasBtn.disabled = false;
                                    return;
                              }

                          } else {
                               console.error("MultiPolygon resultante no contiene polígonos válidos para el barrido y no se pudo encontrar el polígono más grande.");
                               alert("Error procesando la geometría para el barrido. No se encontraron polígonos válidos dentro del MultiPolygon.");
                                loadingStatusDiv.textContent = 'Error procesando geometría.';
                                generarPasadasBtn.disabled = false;
                               return;
                          }
                      } else {
                          console.log("La geometría final para el barrido es un Polígono simple válido.");
                      }
                 } else {
                      console.error("La geometría final para el barrido es nula, undefined o de tipo incorrecto:", finalGeometryToSweep);
                      alert("Error: La geometría resultante (después de excluir zonas a evitar/simplificar) no es un polígono válido para generar pasadas.");
                       loadingStatusDiv.textContent = 'Error en geometría para pasadas.';
                       generarPasadasBtn.disabled = false;
                      return;
                 }


                 console.log("Geometría FINAL para barrido y PiP:", JSON.stringify(geometryForSweepAndPiP));
                 try {
                      if (turf.area(geometryForSweepAndPiP) === 0) {
                           console.error("La geometría final para el barrido tiene área 0.");
                            alert("La geometría resultante del área limpia tiene área cero. No se pueden generar pasadas.");
                            loadingStatusDiv.textContent = 'Área resultante cero.';
                            generarPasadasBtn.disabled = false;
                           return;
                      }
                 } catch(e) {
                      console.error("Error calculando área de geometría final para barrido:", e);
                       alert("Error verificando la geometría final para el barrido.");
                       loadingStatusDiv.textContent = 'Error verificando geometría.';
                       generarPasadasBtn.disabled = false;
                      return;
                 }


                 let centroid = null;
                 try {
                      centroid = turf.centroid(geometryForSweepAndPiP);
                      console.log("Centroide del área limpia para rotación:", JSON.stringify(centroid));
                 } catch(e) {
                      console.error("Error calculando centroide de la geometría limpia:", e);
                       alert("Error calculando el centroide para la rotación.");
                       loadingStatusDiv.textContent = 'Error calculando centroide.';
                       generarPasadasBtn.disabled = false;
                      return;
                 }

                // --- LÓGICA DE DETERMINACIÓN DE ÁNGULO DE PASADAS (MODIFICADA) ---
                let rotationAngle = 0;
                let sweepDirectionInRotatedSpace = 0; // 0 for N-S sweep (horizontal passes in rotated), 90 for E-W sweep (vertical passes in rotated)
                let heuristicDirectionDescription = "";

                let longestSegmentAngle = 0;
                let foundLongestSegment = false;

                if (parcelGeometry.type === 'Polygon' && parcelGeometry.coordinates && parcelGeometry.coordinates.length > 0) {
                    const exteriorCoords = parcelGeometry.coordinates[0];
                    if (exteriorCoords && Array.isArray(exteriorCoords) && exteriorCoords.length > 2) {
                        let maxLength = 0;
                        let p1Longest = null;
                        let p2Longest = null;

                        for (let i = 0; i < exteriorCoords.length - 1; i++) {
                            const p1 = turf.point(exteriorCoords[i]);
                            const p2 = turf.point(exteriorCoords[i+1]);
                            try {
                                const length = turf.distance(p1, p2, {units: units});
                                if (length > maxLength) {
                                    maxLength = length;
                                    p1Longest = p1;
                                    p2Longest = p2;
                                }
                            } catch(e) {
                                console.warn("Error calculando distancia para segmento en heurística:", p1, p2, e);
                            }
                        }

                        if (p1Longest && p2Longest) {
                            try {
                                longestSegmentAngle = turf.bearing(p1Longest, p2Longest);
                                foundLongestSegment = true;
                                console.log(`Lado más largo de la parcela original encontrado. Longitud: ${maxLength.toFixed(2)}m, Ángulo (bearing): ${longestSegmentAngle.toFixed(2)}°`);
                            } catch(e) {
                                console.warn("Error calculando bearing para lado más largo:", p1Longest, p2Longest, e);
                                foundLongestSegment = false;
                            }
                        } else {
                            console.warn("No se encontraron suficientes puntos en el contorno exterior de la parcela original para calcular el lado más largo.");
                        }
                    } else {
                        console.warn("No se pudieron obtener coordenadas exteriores de la parcela original o no hay suficientes puntos.");
                    }
                } else {
                    console.warn("La geometría original de la parcela no es un polígono simple para encontrar el lado más largo.");
                }

                const useLongestSideThreshold = 0.7;
                let originalParcelBbox = null;
                let originalBboxWidthMeters = 0;
                let originalBboxHeightMeters = 0;
                let originalParcelArea = 0;
                let originalBboxArea = 0;
                let originalRectangularity = 0;

                try {
                    originalParcelBbox = turf.bbox(parcelGeometry);
                    originalBboxWidthMeters = turf.distance(turf.point([originalParcelBbox[0], originalParcelBbox[1]]), turf.point([originalParcelBbox[2], originalParcelBbox[1]]), {units: units});
                    originalBboxHeightMeters = turf.distance(turf.point([originalParcelBbox[0], originalParcelBbox[1]]), turf.point([originalParcelBbox[0], originalParcelBbox[3]]), {units: units});
                    originalParcelArea = turf.area(turf.feature(parcelGeometry));
                    originalBboxArea = originalBboxWidthMeters * originalBboxHeightMeters;
                    originalRectangularity = originalBboxArea === 0 ? 0 : originalParcelArea / originalBboxArea;
                    console.log(`Dimensiones Bbox original: Ancho ${originalBboxWidthMeters.toFixed(2)}m, Alto ${originalBboxHeightMeters.toFixed(2)}m. Rectangularidad: ${originalRectangularity.toFixed(2)}`);
                } catch(e) {
                    console.error("Error calculando Bbox o Rectangularidad de la parcela original:", e);
                }

                let baseRotationAngle = 0;
                if (foundLongestSegment && originalRectangularity > useLongestSideThreshold) {
                    baseRotationAngle = -longestSegmentAngle; // Rota para alinear el lado más largo horizontalmente
                    heuristicDirectionDescription = `Lado más largo de la parcela original (ángulo base: ${baseRotationAngle.toFixed(2)}°)`;
                    console.log("Heurística: Usando el lado más largo como dirección principal.");
                } else {
                    console.log("Heurística: Parcela irregular o lado largo no determinante. Usando la orientación de la Bbox original.");
                    if (originalBboxWidthMeters >= originalBboxHeightMeters) {
                        baseRotationAngle = 0; // Bbox ancha, pasadas a lo largo del ancho (E-O si no rotado)
                        heuristicDirectionDescription = "Bounding Box original más ancho que alto (o igual)";
                    } else {
                        baseRotationAngle = 90; // Bbox alta, rota 90° para que pasadas sean horizontales en espacio rotado (N-S en original)
                        heuristicDirectionDescription = "Bounding Box original más alto que ancho (rotado 90° para pasadas horizontales en espacio rotado)";
                    }
                }
                rotationAngle = baseRotationAngle; // Asignar ángulo base inicial

                // *** INCIO MODIFICACIÓN POR PENDIENTE (APLICACIÓN) ***
                if (!isNaN(currentSlopePercentage) && currentSlopePercentage > STEEP_SLOPE_THRESHOLD) {
                    console.log(`Pendiente (${currentSlopePercentage}%) > ${STEEP_SLOPE_THRESHOLD}%. Ajustando orientación de pasadas para mayor verticalidad.`);
                    // Sumar 90 grados al ángulo base para hacer las pasadas perpendiculares a la heurística original.
                    // Esto busca que las pasadas vayan más "arriba/abajo" en la pendiente en lugar de "a través".
                    rotationAngle = baseRotationAngle + 90;
                    heuristicDirectionDescription += ` [PENDIENTE > ${STEEP_SLOPE_THRESHOLD}%: +90° para aprox. verticalidad]`;
                    console.log(`Nuevo ángulo de rotación por pendiente: ${rotationAngle.toFixed(2)}° (Base: ${baseRotationAngle.toFixed(2)}°)`);
                }
                // *** FIN MODIFICACIÓN POR PENDIENTE (APLICACIÓN) ***

                // Normalizar el ángulo (opcional, turf.transformRotate lo maneja, pero es bueno para consistencia en logs)
                rotationAngle = rotationAngle % 360;
                if (rotationAngle > 180) rotationAngle -= 360;
                if (rotationAngle < -180) rotationAngle += 360;

                sweepDirectionInRotatedSpace = 0; // Mantener barrido horizontal en el espacio rotado; la rotación en sí define la orientación final.

                console.log(`Dirección heurística elegida: ${heuristicDirectionDescription}. Rotando el área para el barrido por ${rotationAngle.toFixed(2)} grados.`);
                console.log(`El barrido en el espacio rotado será ${sweepDirectionInRotatedSpace === 0 ? 'N-S (para pasadas horizontales)' : 'E-W (para pasadas verticales)'}.`);
                 // --- FIN LÓGICA DE DETERMINACIÓN DE ÁNGULO ---


                  if (!centroid || !centroid.geometry || !centroid.geometry.coordinates) {
                       console.error("Centroide no válido para la rotación. Deteniendo proceso.");
                        alert("Error: No se pudo determinar el centroide para la rotación.");
                        loadingStatusDiv.textContent = 'Error calculando centroide.';
                        generarPasadasBtn.disabled = false;
                       return;
                  }

                  let rotatedGeometryForSweepAndPiP = null;
                  try {
                       rotatedGeometryForSweepAndPiP = turf.transformRotate(geometryForCalculations, rotationAngle, {pivot: centroid});
                        console.log("Geometría LIMPIA, SIMPLIFICADA y ROTADA para barrido/PiP:", JSON.stringify(rotatedGeometryForSweepAndPiP));
                  } catch(e) {
                       console.error("Error al rotar la geometría final para el barrido:", e);
                        alert("Error al rotar la geometría para generar pasadas.");
                        loadingStatusDiv.textContent = 'Error al rotar geometría.';
                        generarPasadasBtn.disabled = false;
                       return;
                  }


                  let rotatedGeometryBbox = null;
                  let rotatedBboxWest = 0, rotatedBboxSouth = 0, rotatedBboxEast = 0, rotatedBboxNorth = 0;

                  try {
                       rotatedGeometryBbox = turf.bbox(rotatedGeometryForSweepAndPiP);
                       rotatedBboxWest = rotatedGeometryBbox[0];
                       rotatedBboxSouth = rotatedGeometryBbox[1];
                       rotatedBboxEast = rotatedGeometryBbox[2];
                       rotatedBboxNorth = rotatedGeometryBbox[3];
                  } catch(e) {
                       console.error("Error calculando Bbox de la geometría rotada:", e);
                        alert("Error calculando límites de la geometría rotada para generar pasadas.");
                        loadingStatusDiv.textContent = 'Error calculando límites.';
                        generarPasadasBtn.disabled = false;
                       return;
                  }


                 let rotatedStartSweepCoordValue;
                 let rotatedEndSweepCoordValue;
                 let rotatedSweepLineStartCoord;
                 let rotatedSweepLineEndCoord;
                 let rotatedSweepLineDirection;


                 if (sweepDirectionInRotatedSpace === 0) {
                     rotatedStartSweepCoordValue = rotatedBboxSouth;
                     rotatedEndSweepCoordValue = rotatedBboxNorth;
                     rotatedSweepLineStartCoord = rotatedBboxWest;
                     rotatedSweepLineEndCoord = rotatedBboxEast;
                     rotatedSweepLineDirection = 90; // Dirección para turf.destination para moverse perpendicularmente a las pasadas (hacia el Este)

                      console.log("Configurando barrido S->N en espacio rotado para generar pasadas horizontales (O->E).");
                 } else { // Esto no se usará con la lógica actual de sweepDirectionInRotatedSpace = 0
                     rotatedStartSweepCoordValue = rotatedBboxWest;
                     rotatedEndSweepCoordValue = rotatedBboxEast;
                      rotatedSweepLineStartCoord = rotatedBboxSouth;
                      rotatedSweepLineEndCoord = rotatedBboxNorth;
                      rotatedSweepLineDirection = 0; // Dirección para turf.destination para moverse perpendicularmente a las pasadas (hacia el Norte)

                      console.log("Configurando barrido O->E en espacio rotado para generar pasadas verticales (S->N).");
                 }

                 let totalSweepExtentMeters = 0;
                 let passLengthMeters = 0;
                  try {
                      totalSweepExtentMeters = turf.distance(
                         turf.point(sweepDirectionInRotatedSpace === 0 ? [rotatedBboxWest, rotatedBboxSouth] : [rotatedBboxWest, rotatedBboxSouth]), // Punto de inicio del barrido en la bbox rotada
                         turf.point(sweepDirectionInRotatedSpace === 0 ? [rotatedBboxWest, rotatedBboxNorth] : [rotatedBboxEast, rotatedBboxSouth]), // Punto final del barrido en la bbox rotada
                         {units: units}
                      );
                      console.log(`Extensión total del barrido en espacio rotado (a lo largo de la Bbox perpendicular a las pasadas): ${totalSweepExtentMeters.toFixed(2)} ${units}`);

                      passLengthMeters = turf.distance(
                           turf.point(sweepDirectionInRotatedSpace === 0 ? [rotatedBboxWest, rotatedBboxSouth] : [rotatedBboxWest, rotatedBboxSouth]), // Punto de inicio de la pasada en la bbox rotada
                           turf.point(sweepDirectionInRotatedSpace === 0 ? [rotatedBboxEast, rotatedBboxSouth] : [rotatedBboxWest, rotatedBboxNorth]), // Punto final de la pasada en la bbox rotada
                           {units: units}
                       );
                       console.log(`Longitud máxima esperada de las pasadas en espacio rotado: ${passLengthMeters.toFixed(2)} ${units}`);

                  } catch(e) {
                      console.error("Error calculando distancias de la bbox rotada:", e);
                       alert("Error calculando límites de la geometría rotada para generar pasadas.");
                       loadingStatusDiv.textContent = 'Error calculando distancias.';
                       generarPasadasBtn.disabled = false;
                      return;
                  }


                let rotatedCurrentOffset = workingWidth / 2;
                const samplingDistance = 1;
                const geometryForPiPCheck = rotatedGeometryForSweepAndPiP;

                console.log(`Generando pasadas de ${workingWidth}m en espacio rotado (muestreo de ${samplingDistance}m).`);

                 let generatedRotatedPasses = [];


                if (workingWidth <= 0 || totalSweepExtentMeters <= 0) {
                    console.warn("Ancho de trabajo o extensión del barrido <= 0. No se generarán pasadas.");
                    alert("Ancho de trabajo inválido o área a barrer muy pequeña.");
                     loadingStatusDiv.textContent = 'Ancho de trabajo o área inválida.';
                     generarPasadasBtn.disabled = false;
                    return;
                } else {
                     const sweepLimit = totalSweepExtentMeters - (workingWidth / 2) + (workingWidth * 0.1); // Añadir un pequeño margen para asegurar que se barre hasta el final
                     while (rotatedCurrentOffset <= sweepLimit ) {

                        let pointOnSweepAxis = null;
                         try {
                             // Calcula un punto en el eje de barrido a la distancia 'rotatedCurrentOffset' desde el inicio del barrido
                             pointOnSweepAxis = turf.destination(
                                 turf.point(sweepDirectionInRotatedSpace === 0 ? [rotatedBboxWest, rotatedBboxSouth] : [rotatedBboxWest, rotatedBboxSouth]), // Punto de origen para la distancia (esquina Suroeste de la Bbox rotada)
                                 rotatedCurrentOffset / 1000, // Distancia en kilómetros para turf.destination
                                 sweepDirectionInRotatedSpace === 0 ? 0 : 90, // Dirección 0 (Norte) para barrido S->N (pasadas horizontales), 90 (Este) para barrido O->E (pasadas verticales)
                                 {units: 'kilometers'}
                             );
                         } catch(e) {
                             console.error("Error en turf.destination al calcular punto en eje de barrido:", e);
                             rotatedCurrentOffset += workingWidth; // Incrementa el offset para intentar la siguiente pasada
                             continue; // Pasa a la siguiente iteración del bucle while
                         }

                         if (!pointOnSweepAxis || !pointOnSweepAxis.geometry || !pointOnSweepAxis.geometry.coordinates) {
                              console.warn("turf.destination devolvió un punto inválido. Saltando esta pasada.");
                              rotatedCurrentOffset += workingWidth;
                              continue;
                         }


                        let passCenterCoord = sweepDirectionInRotatedSpace === 0 ? pointOnSweepAxis.geometry.coordinates[1] : pointOnSweepAxis.geometry.coordinates[0];


                        let fullSweepLineInRotatedSpace = null;
                         try {
                            if (sweepDirectionInRotatedSpace === 0) { // Pasada horizontal (Oeste a Este)
                                 // Crea una línea horizontal a través de la bbox rotada en la coordenada 'passCenterCoord' (latitud)
                                 fullSweepLineInRotatedSpace = turf.lineString([[rotatedBboxWest, passCenterCoord], [rotatedBboxEast, passCenterCoord]]);
                            } else { // Pasada vertical (Sur a Norte)
                                 // Crea una línea vertical a través de la bbox rotada en la coordenada 'passCenterCoord' (longitud)
                                 fullSweepLineInRotatedSpace = turf.lineString([[passCenterCoord, rotatedBboxSouth], [passCenterCoord, rotatedBboxNorth]]);
                            }
                         } catch(e) {
                              console.error("Error en turf.lineString al crear línea de barrido completa:", e);
                             rotatedCurrentOffset += workingWidth;
                             continue;
                         }

                          if (!fullSweepLineInRotatedSpace || !fullSweepLineInRotatedSpace.geometry || fullSweepLineInRotatedSpace.geometry.type !== 'LineString') {
                               console.warn("La línea de barrido completa no es válida (esperado LineString). Saltando esta pasada.");
                               rotatedCurrentOffset += workingWidth;
                               continue;
                          }


                        let lineLength = 0;
                         try {
                              lineLength = turf.length(fullSweepLineInRotatedSpace, {units: units});
                         } catch(e) {
                              console.error("Error en turf.length al calcular longitud de línea de barrido:", e);
                             rotatedCurrentOffset += workingWidth;
                             continue;
                         }


                        let currentSegmentPoints = [];

                         // Muestrea puntos a lo largo de la línea completa de barrido y comprueba si están dentro de la geometría limpia
                        for (let i = 0; i <= lineLength; i += samplingDistance) {
                            let point = null;
                            try {
                                // Obtiene un punto a lo largo de la línea de barrido completa a la distancia 'i'
                                point = turf.along(fullSweepLineInRotatedSpace, i, {units: units});
                            } catch(e) {
                                console.warn(`Error en turf.along al muestrear punto en distancia ${i}.`, e);
                                continue; // Salta el punto si hay error
                            }

                            if (!point || !point.geometry || !point.geometry.coordinates) {
                                 console.warn(`turf.along en distancia ${i} devolvió punto inválido. Saltando punto.`);
                                 continue; // Salta el punto si es inválido
                            }


                            let isInside = false;
                             // Verifica si el punto muestreado está dentro de la geometría del área limpia
                            if (geometryForPiPCheck && (geometryForPiPCheck.type === 'Polygon' || geometryForPiPCheck.type === 'MultiPolygon')) {
                                try {
                                    isInside = turf.booleanPointInPolygon(point, geometryForPiPCheck);
                                } catch(e) {
                                    console.warn("Error durante booleanPointInPolygon para punto en muestreo.", point, e);
                                    isInside = false; // Asume que no está dentro si hay error
                                }
                            } else {
                                console.error("La geometría para verificación PiP no es válida (esperado Polygon/MultiPolygon).", geometryForPiPCheck);
                                isInside = false; // Asume que no está dentro si la geometría es inválida
                            }


                            if (isInside && point && point.geometry && point.geometry.coordinates) {
                                // Si el punto está dentro, añádelo al segmento actual
                                currentSegmentPoints.push(point.geometry.coordinates);
                            } else {
                                // Si el punto no está dentro O hubo un error, termina el segmento actual si hay puntos suficientes
                                if (currentSegmentPoints.length > 1) { // Un segmento válido requiere al menos 2 puntos
                                     try {
                                         // Añade el segmento (LineString) al array de pasadas generadas
                                         generatedRotatedPasses.push(turf.lineString(currentSegmentPoints));
                                     } catch(e) {
                                         console.error("Error en turf.lineString al crear segmento de pasada rotada:", e);
                                     }
                                }
                                currentSegmentPoints = []; // Reinicia los puntos para el próximo segmento
                            }
                        }

                        // Después de muestrear toda la línea de barrido, añade el último segmento si existe
                        if (currentSegmentPoints.length > 1) {
                             try {
                                 generatedRotatedPasses.push(turf.lineString(currentSegmentPoints));
                            } catch(e) {
                                 console.error("Error en turf.lineString al crear segmento final de pasada rotada:", e);
                            }
                        }

                        // Incrementa el offset para la siguiente pasada
                        rotatedCurrentOffset += workingWidth;
                    }
                }


                console.log(`Generadas ${generatedRotatedPasses.length} pasadas (segmentos de LineString) en el espacio rotado.`);

                console.log(`Rotando pasadas de vuelta por ${-rotationAngle.toFixed(2)} grados.`);
                generatedRotatedPasses.forEach((rotatedPass, index) => {
                    try {
                         if (rotatedPass && rotatedPass.geometry && rotatedPass.geometry.type === 'LineString') {
                              if (!centroid || !centroid.geometry || !centroid.geometry.coordinates) {
                                  console.warn(`Centroide no válido al rotar pasada #${index}. Saltando rotación para esta pasada.`);
                                  return;
                              }
                              // Rota la geometría de la pasada de vuelta al espacio original usando el centroide original
                              const originalPassGeometry = turf.transformRotate(rotatedPass.geometry, -rotationAngle, {pivot: centroid});
                              // Añade la pasada rotada al mapa
                              L.geoJSON(originalPassGeometry, {
                                  style: { color: '#800080', weight: 2 } // Estilo para las pasadas generadas (morado)
                              }).addTo(generatedPassesLayer);
                         } else {
                              console.warn(`La pasada rotada #${index} no es un LineString válido. No se añadirá al mapa.`, rotatedPass);
                         }

                    } catch (e) {
                        console.warn(`Error al rotar una pasada de vuelta (#${index}):`, rotatedPass, e);
                    }
                });

                console.log("Generación de pasadas optimizadas (excluyendo zonas a evitar) finalizada.");
                 loadingStatusDiv.textContent = 'Pasadas generadas.';
                 generarPasadasBtn.disabled = false; // Re-habilitar el botón al finalizar
                 console.log("--- Fin Lógica de Generación de Pasadas ---");

            } catch (e) {
                console.error("Error general durante la generación de pasadas:", e);
                console.error("Parcel Geometry (inicio):", JSON.stringify(parcelGeometry));
                if (typeof geometryForCalculations !== 'undefined') {
                     console.error("Geometry for Calculations (después de exclusión):", JSON.stringify(geometryForCalculations));
                }
                 if (typeof finalGeometryToSweep !== 'undefined') {
                     console.error("Final Geometry To Sweep (después de simplificación):", JSON.stringify(finalGeometryToSweep));
                }
                 if (typeof geometryForSweepAndPiP !== 'undefined') {
                      console.error("Geometry For Sweep And PiP (polígono más grande):", JSON.stringify(geometryForSweepAndPiP));
                 }

                alert("Ocurrió un error al generar las pasadas. Revisa la consola para detalles.");
                 loadingStatusDiv.textContent = 'Error al generar pasadas.';
                 generarPasadasBtn.disabled = false;
            }
        }


        // --- Lógica de Localización GPS ---
        function locateUser() {
            if (!navigator.geolocation) {
                console.log("Tu navegador no soporta geolocalización.");
                 if (!loadingStatusDiv.textContent.startsWith('Error:')) {
                      loadingStatusDiv.textContent = 'Error: Geolocalización no soportada.';
                 }
                alert("Tu navegador no soporta la funcionalidad de geolocalización necesaria para mostrar tu posición.");
                return;
            }

            if (watchingLocation) {
                 console.log("watchPosition ya está activo.");
                 if (lastKnownLocation) {
                      map.setView(lastKnownLocation, Math.max(map.getZoom(), 16));
                      console.log("Centrando mapa en la última localización conocida.");
                       if (!loadingStatusDiv.textContent.startsWith('Error:') && !loadingStatusDiv.textContent.includes('Advertencia:')) {
                          loadingStatusDiv.textContent = 'Datos iniciales cargados. Localización encontrada.';
                       }
                 } else {
                     console.log("watchPosition activo, pero aún sin localización. Esperando...");
                      if (!loadingStatusDiv.textContent.startsWith('Error:') && !loadingStatusDiv.textContent.includes('Advertencia:')) {
                           loadingStatusDiv.textContent = 'Datos iniciales cargados. Buscando localización...';
                      }
                 }
                 return;
            }

            console.log("Iniciando observación de localización GPS...");
            watchingLocation = true;
            navigator.geolocation.watchPosition(onLocationFound, onLocationError, {
                enableHighAccuracy: true,
                timeout: 15000,
                maximumAge: 0
            });

            if (!loadingStatusDiv.textContent.startsWith('Error:') && !loadingStatusDiv.textContent.includes('Advertencia:')) {
                loadingStatusDiv.textContent = 'Cargando datos iniciales y buscando localización...';
            }

        }

        function onLocationFound(e) {
            const radius = e.coords.accuracy;
            const latlng = L.latLng(e.coords.latitude, e.coords.longitude);
            lastKnownLocation = latlng;

            console.log(`Localización GPS encontrada: Lat ${latlng.lat}, Lng ${latlng.lng}, Precisión ${radius} m`);

            if (locationMarker) {
                map.removeLayer(locationMarker);
            }
            if (accuracyCircle) {
                map.removeLayer(accuracyCircle);
            }

            locationMarker = L.circleMarker(latlng, {
                radius: 8,
                color: '#0055FF',
                fillColor: '#0055FF',
                fillOpacity: 1
            }).addTo(map);

            accuracyCircle = L.circle(latlng, radius, {
                 color: '#136AEC',
                 fillColor: '#136AEC',
                 fillOpacity: 0.15,
                 weight: 2
            }).addTo(map);

            if (!firstLocationObtained) {
                 map.setView(latlng, Math.max(map.getZoom(), 16));
                 firstLocationObtained = true;
                 console.log("Primera localización obtenida. Mapa centrado.");
            } else {
                 console.log("Localización actualizada.");
            }


             if (!loadingStatusDiv.textContent.startsWith('Error:') && !loadingStatusDiv.textContent.includes('Advertencia:')) {
                 if (selectedLayer) {
                     loadingStatusDiv.textContent = 'Datos iniciales cargados. Localización encontrada. Subparcela seleccionada.';
                 } else {
                      loadingStatusDiv.textContent = 'Datos iniciales cargados. Localización encontrada. Selecciona una subparcela.';
                 }

             }


        }

        function onLocationError(e) {
            console.error(`Error de localización (${e.code}): ${e.message}`);
            watchingLocation = false;

            let errorMessage = "Error al obtener la localización: ";

            switch (e.code) {
                case 1:
                    errorMessage += "Permiso denegado.";
                    alert("Para mostrar tu posición, por favor permite el acceso a la geolocalización.");
                    break;
                case 2:
                    errorMessage += "Posición no disponible.";
                     alert("Tu posición no está disponible (señal GPS débil o desactivado).");
                    break;
                case 3:
                    errorMessage += "Tiempo de espera agotado.";
                     alert("Tiempo de espera agotado al buscar tu localización. Asegúrate de tener buena señal GPS.");
                    break;
                default:
                    errorMessage += `Error desconocido: ${e.message}`;
                     alert(errorMessage + " Revisa la consola para más detalles.");
                    break;
            }
             if (!loadingStatusDiv.textContent.startsWith('Error:')) {
                  loadingStatusDiv.textContent = 'Datos iniciales cargados. ' + errorMessage;
             }

             if (locationMarker) {
                map.removeLayer(locationMarker);
                locationMarker = null;
             }
             if (accuracyCircle) {
                map.removeLayer(accuracyCircle);
                accuracyCircle = null;
             }
             lastKnownLocation = null;
        }
        // --- Fin Lógica de Localización GPS ---

        // --- Event Listener para el botón de localización ---
        locateButton.addEventListener('click', function() {
            console.log("Botón de localización pulsado.");
            if (lastKnownLocation) {
                 map.setView(lastKnownLocation, Math.max(map.getZoom(), 16));
                 console.log("Centrando mapa en la última localización conocida al pulsar el botón.");
                 if (!loadingStatusDiv.textContent.startsWith('Error:') && !loadingStatusDiv.textContent.includes('Advertencia:')) {
                       loadingStatusDiv.textContent = 'Datos iniciales cargados. Mapa centrado en tu posición.';
                 }

            } else {
                 console.log("No hay localización conocida. Intentando iniciar/reiniciar localización...");
                 locateUser();
                 if (!loadingStatusDiv.textContent.startsWith('Error:') && !loadingStatusDiv.textContent.includes('Advertencia:')) {
                       loadingStatusDiv.textContent = 'Datos iniciales cargados. Buscando localización...';
                 }
            }
        });


        // --- Funciones de cálculo de altitud/pendiente con Curvas de Nivel (Mantenidas como fallback si MDT falla) ---
         // Función para calcular la altitud media de una parcela usando curvas de nivel (con logs de depuración y buffer)
        function calculateMeanAltitude(parcelGeometry, curvasNivelGeoJSON) {
            console.log("--- Iniciando cálculo de altitud media con Curvas de Nivel para parcela ---");
            let totalAltitude = 0;
            let intersectingContoursCount = 0;
            const bufferDistance = 0.1; // Pequeño buffer en metros para la parcela
            const units = 'meters';

            // Intenta obtener un identificador de parcela si está disponible en las propiedades
            const parcelProps = selectedLayer && selectedLayer.feature && selectedLayer.feature.properties ? selectedLayer.feature.properties : {};
            // Ajusta las claves si el archivo de subparcelas usa nombres diferentes (ej: 'id_subpar')
            const poligono = parcelProps['MASA'] || parcelProps['poligono'] || parcelProps['POLIGONO'] || 'N/A';
            const parcela = parcelProps['PARCELA'] || parcelProps['parcela'] || parcelProps['ID_SUBPAR'] || 'N/A'; // Usar ID_SUBPAR u otra clave relevante
            const parcelId = `Polígono ${poligono}, Parcela ${parcela}`;


            if (!parcelGeometry || !curvasNivelGeoJSON || !curvasNivelGeoJSON.features) {
                console.error(`[${parcelId}] Datos de entrada inválidos para cálculo de altitud con Curvas de Nivel.`);
                return null; // Datos inválidos
            }

            let parcelFeature = turf.feature(parcelGeometry);
             let bufferedParcel = null;

             try {
                 // Añade un pequeño buffer a la parcela
                 bufferedParcel = turf.buffer(parcelFeature, bufferDistance, {units: units});
                  console.log(`[${parcelId}] Parcela original bufferizada por ${bufferDistance} ${units} para altitud con Curvas de Nivel.`);
                 // Usa la parcela bufferizada para la detección de intersecciones
                 parcelFeature = bufferedParcel;

             } catch(e) {
                 console.error(`[${parcelId}] Error al crear buffer para la parcela en cálculo de altitud con Curvas de Nivel. Usando geometría original.`, e);
                  // Si falla el buffer, usa la geometría original de la parcela
                  parcelFeature = turf.feature(parcelGeometry);
             }


            console.log(`[${parcelId}] ParcelFeature (bufferizada o original) creada para altitud con Curvas de Nivel.`);
            console.log(`[${parcelId}] Total de curvas de nivel en los datos: ${curvasNivelGeoJSON.features ? curvasNivelGeoJSON.features.length : 0}`);


            // Asegúrate de que curvasNivelGeoJSON.features es un array antes de iterar
            if (curvasNivelGeoJSON.features && Array.isArray(curvasNivelGeoJSON.features)) {
                curvasNivelGeoJSON.features.forEach((contourFeature, index) => {
                    // console.log(`[${parcelId}] Procesando curva de nivel #${index}.`); // Puede generar muchos logs
                    if (contourFeature.geometry && contourFeature.geometry.type === 'LineString') {
                        try {
                             // Verifica intersección con la parcela (ahora bufferizada)
                            if (turf.booleanIntersects(parcelFeature, contourFeature)) {
                                 // console.log(`[${parcelId}] Intersección detectada con curva de nivel #${index}. Propiedades:`, contourFeature.properties);

                                 let elevation = null;
                                 // Check for different possible elevation properties, prioritizing 'COTA_0201'
                                if (contourFeature.properties.hasOwnProperty('COTA_0201')) {
                                    elevation = parseFloat(contourFeature.properties.COTA_0201);
                                    // console.log(`[${parcelId}] Elevación encontrada en COTA_0201: ${elevation}`);
                                } else if (contourFeature.properties.hasOwnProperty('cota')) {
                                    elevation = parseFloat(contourFeature.properties.cota);
                                    // console.log(`[${parcelId}] Elevación encontrada en cota: ${elevation}`);
                                } else if (contourFeature.properties.hasOwnProperty('ELEVACION')) {
                                    elevation = parseFloat(contourFeature.properties.ELEVACION);
                                    // console.log(`[${parcelId}] Elevación encontrada en ELEVACION: ${elevation}`);
                                } else if (contourFeature.properties.hasOwnProperty('valor')) {
                                    elevation = parseFloat(contourFeature.properties.valor);
                                    // console.log(`[${parcelId}] Elevación encontrada en valor: ${elevation}`);
                                } else if (contourFeature.properties.hasOwnProperty('altura')) {
                                    elevation = parseFloat(contourFeature.properties.altura);
                                    // console.log(`[${parcelId}] Elevación encontrada en altura: ${elevation}`);
                                } else {
                                     // console.log(`[${parcelId}] No se encontró propiedad de elevación esperada en curva #${index}.`);
                                }


                                if (elevation !== null && !isNaN(elevation)) {
                                    totalAltitude += elevation;
                                    intersectingContoursCount++;
                                    // console.log(`[${parcelId}] Curva #${index} añadida al cálculo. Contador: ${intersectingContoursCount}, Total Altitud: ${totalAltitude}`);
                                } else {
                                    console.warn(`[${parcelId}] Curva de nivel #${index} interseca (bufferizada) pero NO tiene propiedad de elevación numérica válida.`, contourFeature.properties);
                                }
                            } else {
                                 // console.log(`[${parcelId}] Curva de nivel #${index} NO interseca (bufferizada).`); // Puede generar muchísimos logs
                            }
                        } catch (e) {
                             console.error(`[${parcelId}] Error verificando intersección (bufferizada) o procesando curva #${index}:`, e, contourFeature);
                        }
                    } else {
                         // console.warn(`[${parcelId}] Feature #${index} en curvas de nivel no es LineString o no tiene geometría:`, contourFeature); // Puede generar muchos logs
                    }
                });
            } else {
                 console.warn(`[${parcelId}] curvasNivelGeoJSON.features no es un array válido para cálculo de altitud con Curvas de Nivel.`);
            }


            console.log(`[${parcelId}] Fin del bucle de altitud con Curvas de Nivel. Curvas que intersectan (bufferizada) con datos válidos: ${intersectingContoursCount}`);

            if (intersectingContoursCount > 0) {
                const mean = totalAltitude / intersectingContoursCount;
                console.log(`[${parcelId}] Altitud media calculada con Curvas de Nivel: ${mean.toFixed(2)} m (usando ${intersectingContoursCount} curvas)`);
                return mean.toFixed(2); // Retornar media con 2 decimales
            } else {
                console.log(`[${parcelId}] No se encontraron curvas de nivel que crucen la parcela (bufferizada) con elevación válida para altitud media.`);
                return "N/A (Sin curvas de nivel)"; // No hay curvas de nivel que crucen la parcela
            }
             // console.log("--- Fin cálculo de altitud media para parcela ---"); // Este log nunca se alcanzará debido a los return anteriores
        }

        // Función para calcular información de pendiente (min/max altitud y pendiente %) con buffer usando Curvas de Nivel
        function calculateSlopeInfo(parcelGeometry, curvasNivelGeoJSON) {
            console.log("--- Iniciando cálculo de información de pendiente con Curvas de Nivel para parcela ---");
            let minElevation = Infinity;
            let maxElevation = -Infinity;
            let intersectingContoursCount = 0;
            const bufferDistance = 0.1; // Pequeño buffer en metros para la parcela
            const units = 'meters';

            const parcelProps = selectedLayer && selectedLayer.feature && selectedLayer.feature.properties ? selectedLayer.feature.properties : {};
            // Ajusta las claves si el archivo de subparcelas usa nombres diferentes
            const poligono = parcelProps['MASA'] || parcelProps['poligono'] || parcelProps['POLIGONO'] || 'N/A';
            const parcela = parcelProps['PARCELA'] || parcelProps['parcela'] || parcelProps['ID_SUBPAR'] || 'N/A'; // Usar ID_SUBPAR u otra clave relevante
            const parcelId = `Polígono ${poligono}, Parcela ${parcela}`;

            if (!parcelGeometry || !curvasNivelGeoJSON || !curvasNivelGeoJSON.features) {
                console.error(`[${parcelId}] Datos de entrada inválidos para cálculo de pendiente con Curvas de Nivel.`);
                return { min: 'N/A', max: 'N/A', slope: 'N/A (Datos Inválidos)' };
            }

            let parcelFeature = turf.feature(parcelGeometry);
             let bufferedParcel = null;

             try {
                 // Añade un pequeño buffer a la parcela
                 bufferedParcel = turf.buffer(parcelFeature, bufferDistance, {units: units});
                 console.log(`[${parcelId}] Parcela original bufferizada por ${bufferDistance} ${units} para pendiente con Curvas de Nivel.`);
                 // Usa la parcela bufferizada para la detección de intersecciones
                 parcelFeature = bufferedParcel;

             } catch(e) {
                 console.error(`[${parcelId}] Error al crear buffer para la parcela en cálculo de pendiente con Curvas de Nivel. Usando geometría original.`, e);
                 // Si falla el buffer, usa la geometría original de la parcela
                  parcelFeature = turf.feature(parcelGeometry);
             }


            console.log(`[${parcelId}] ParcelFeature (bufferizada o original) creada para pendiente con Curvas de Nivel.`);


             if (curvasNivelGeoJSON.features && Array.isArray(curvasNivelGeoJSON.features)) {
                 curvasNivelGeoJSON.features.forEach(contourFeature => {
                     if (contourFeature.geometry && contourFeature.geometry.type === 'LineString') {
                         try {
                              // Verifica intersección con la parcela (ahora bufferizada)
                             if (turf.booleanIntersects(parcelFeature, contourFeature)) {
                                  let elevation = null;
                                 // Check for different possible elevation properties
                                if (contourFeature.properties.hasOwnProperty('COTA_0201')) {
                                    elevation = parseFloat(contourFeature.properties.COTA_0201);
                                } else if (contourFeature.properties.hasOwnProperty('cota')) {
                                    elevation = parseFloat(contourFeature.properties.cota);
                                } else if (contourFeature.properties.hasOwnProperty('ELEVACION')) {
                                    elevation = parseFloat(contourFeature.properties.ELEVACION);
                                } else if (contourFeature.properties.hasOwnProperty('valor')) {
                                    elevation = parseFloat(contourFeature.properties.valor);
                                } else if (contourFeature.properties.hasOwnProperty('altura')) {
                                    elevation = parseFloat(contourFeature.properties.altura);
                                }

                                 if (elevation !== null && !isNaN(elevation)) {
                                     minElevation = Math.min(minElevation, elevation);
                                     maxElevation = Math.max(maxElevation, elevation);
                                     intersectingContoursCount++;
                                 }
                             }
                         } catch (e) {
                              console.warn(`[${parcelId}] Error verificando intersección (bufferizada) o procesando curva para pendiente con Curvas de Nivel:`, e, contourFeature);
                         }
                     }
                 });
             } else {
                  console.warn(`[${parcelId}] curvasNivelGeoJSON.features no es un array válido para cálculo de pendiente con Curvas de Nivel.`);
             }


            console.log(`[${parcelId}] Fin del bucle de pendiente con Curvas de Nivel. Curvas que intersectan (bufferizada) con datos válidos: ${intersectingContoursCount}`);

            // Se necesitan al menos 2 puntos de elevación para tener un rango (mínima y máxima)
            if (intersectingContoursCount < 2 || minElevation === Infinity || maxElevation === -Infinity) {
                 console.log(`[${parcelId}] Menos de 2 curvas de nivel con datos válidos intersectan (bufferizada) la parcela. No se puede calcular la pendiente con Curvas de Nivel.`);
                return { min: 'N/A', max: 'N/A', slope: 'N/A (Sin suficientes curvas)' };
            }

            const elevationDifference = maxElevation - minElevation;
            console.log(`[${parcelId}] Diferencia de elevación con Curvas de Nivel: ${elevationDifference.toFixed(2)} m (Max: ${maxElevation.toFixed(2)}, Min: ${minElevation.toFixed(2)})`);


             // Simplificación: Usar la dimensión más larga del bounding box de la parcela como distancia horizontal
             let horizontalDistance = 0;
             try {
                  const bbox = turf.bbox(parcelGeometry); // Usamos la geometría ORIGINAL para el bbox
                  const bboxWidth = turf.distance(turf.point([bbox[0], bbox[1]]), turf.point([bbox[2], bbox[1]]), {units: units});
                  const bboxHeight = turf.distance(turf.point([bbox[0], bbox[1]]), turf.point([bbox[0], bbox[3]]), {units: units});
                  horizontalDistance = Math.max(bboxWidth, bboxHeight);
                  console.log(`[${parcelId}] Distancia horizontal (dimensión máx Bbox parcela original) para pendiente con Curvas de Nivel: ${horizontalDistance.toFixed(2)} m`);

             } catch(e) {
                  console.error(`[${parcelId}] Error calculando Bbox para distancia horizontal de pendiente con Curvas de Nivel:`, e);
                   horizontalDistance = 0; // Fallback
             }


            let slopePercentage = 'N/A';
            // Calcula la pendiente solo si la distancia horizontal es mayor que cero para evitar división por cero
            if (horizontalDistance > 0) {
                 slopePercentage = (elevationDifference / horizontalDistance) * 100;
                 console.log(`[${parcelId}] Pendiente calculada con Curvas de Nivel: ${slopePercentage.toFixed(2)} %`);
                 slopePercentage = slopePercentage.toFixed(2); // Formato a 2 decimales
            } else {
                 console.warn(`[${parcelId}] Distancia horizontal es cero o inválida (${horizontalDistance}). No se puede calcular la pendiente con Curvas de Nivel.`);
                  slopePercentage = 'N/A (Distancia Cero)';
            }


            console.log("--- Fin cálculo de información de pendiente con Curvas de Nivel ---");
            return {
                min: minElevation.toFixed(2),
                max: maxElevation.toFixed(2),
                slope: slopePercentage
            };
        }
        // --- Fin Funciones de cálculo con Curvas de Nivel ---


        // --- LOGS INICIALES ---
        console.log("Mapa Leaflet con capas base, Catastro (WMS) inicializados.");
        console.log("La carga automática de datos geoespaciales iniciales (Subparcelas, Curvas Nivel, MDT) comenzará al terminar de cargar el DOM.");
        console.log("La búsqueda de localización GPS se iniciará al cargar el DOM si el navegador lo soporta.");

    </script>

</body>
</html>
