<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa con Leaflet, Catastro, GeoJSONs y Generación de Pasadas (Parcelas)</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin="anonymous"/>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
    <script src="https://unpkg.com/georaster@1.7.1/dist/bundle.js"></script>
    <script src="https://unpkg.com/georaster-layer-for-leaflet@3.9.1/dist/georaster-layer-for-leaflet.min.js"></script>

    <style>
        #map {
            height: 500px;
            width: 80%;
            margin: 20px auto;
            border: 1px solid #ccc;
        }
        .container {
            position: relative;
            width: 80%;
            margin: 20px auto;
        }
        /* Estilo básico para los controles */
        .control-container {
            text-align: center;
            margin-bottom: 10px;
        }
        .control-container label, .control-container input, .control-container button, .control-container select { /* Añadido 'select' */
            display: inline-block;
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            vertical-align: middle; /* Alinea verticalmente los elementos */
        }
         .control-container label {
             padding: 10px 5px; /* Ajuste de padding para la etiqueta */
             cursor: default;
        }
        .control-container input[type="number"] {
             width: 80px; /* Ancho fijo para el input number */
             padding: 10px;
        }
         #loading-status {
             margin-top: 10px;
             font-size: 1em;
             color: #555;
         }
         /* Estilo para el control de capas Leaflet */
         .leaflet-control-layers-group-label {
            font-weight: bold;
            margin-top: 5px;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>

    <div class="control-container">
        <label for="parcel-select">Seleccionar Parcela:</label>
        <select id="parcel-select">
           <option value="">-- Seleccionar --</option>
           </select>

         <label for="avoid-select">Seleccionar Zona a Evitar:</label>
        <select id="avoid-select">
            <option value="">-- Seleccionar --</option>
            </select>


        <label for="workingWidth">Ancho de Trabajo (m):</label>
        <input type="number" id="workingWidth" value="15" min="1">
        <button id="generarPasadasBtn" disabled>Generar Pasadas (Cargando Datos...)</button>
        <div id="loading-status">Cargando datos geoespaciales...</div>
    </div>


    <div class="container">
        <div id="map"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <script>
        console.log("Estado de 'turf' inmediatamente después del script tag:", typeof turf);
        if (typeof turf === 'undefined') {
             console.error("VERIFICACIÓN: 'turf' es undefined justo después del script tag. El script de Turf.js NO se cargó o ejecutó como se esperaba.");
        } else {
             console.log("VERIFICACIÓN: 'turf' parece estar definido. Tipo:", typeof turf);
        }
    </script>


    <script>
         // --- Definir la proyección ETRS89 / UTM zone 30N (EPSG:25830) ---
         // Esto es necesario para que proj4js y las librerías que lo usan (como georaster-layer-for-leaflet)
         // entiendan el sistema de coordenadas del MDT GeoTIFF.
         if (typeof proj4 !== 'undefined') {
             try {
                 // +towgs84=0,0,0,0,0,0,0 es la transformación estándar de ETRS89 a WGS84, asumiendo que son equivalentes en la práctica.
                 proj4.defs("EPSG:25830", "+proj=utm +zone=30 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
                 console.log("Proyección EPSG:25830 (ETRS89 / UTM Huso 30N) definida en proj4js.");
             } catch(e) {
                  console.error("Error definiendo proyección EPSG:25830 en proj4js:", e);
             }
         } else {
             console.error("Proj4js no está cargado. La capa de elevación podría no cargarse correctamente.");
         }


        // Vista inicial en Andalucía (ajustada para Ronda)
        const map = L.map('map').setView([36.7462, -5.1612], 14); // Vista ajustada

        // --- Variables ---
        let selectedLayer = null; // Variable para almacenar la capa (parcela) que está seleccionada
        let originalStyle = {}; // Variable para guardar el estilo original de cada capa de parcela
        let parcelasLayer = null; // Capa para parcelas (seleccionable)
        let construccionesLayer = null; // Capa para construcciones (exclusión)
        let elementosInternosLayer = null; // Capa para viales/arroyos/elementos internos (exclusión)
        window.exclusionFeatures = []; // Variable global para almacenar las geometrías de exclusión (Polygon/MultiPolygon)
        let generatedPassesLayer = L.featureGroup().addTo(map); // Capa para las pasadas generadas

        // --- Variables para los nuevos datos de elevación y curvas de nivel ---
        let elevationGeoRaster = null; // Para almacenar el objeto GeoRaster del MDT cargado
        let contourLinesGeoJSON = null; // Para almacenar los datos GeoJSON de las curvas de nivel cargadas


        // --- Elementos de la interfaz ---
        const generarPasadasBtn = document.getElementById('generarPasadasBtn');
        const workingWidthInput = document.getElementById('workingWidth');
        const loadingStatusDiv = document.getElementById('loading-status'); // Referencia al indicador de carga

        // --- Capas base ---
        // Capa Minimalista (Se mantiene)
        const minimalBaseLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19
        });

        // Capa Satélite Esri (Se mantiene para el híbrido, pero se quita del selector de capas base)
         const satelliteLayer = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
              attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, GeoEye, Earthstar Geographics, CNES/Airbus DS, GeoEye, USDA FSA, USGS, AeroGRID, IGN, IGP, swisstopo, and the GIS User Community',
              maxZoom: 18
         });

        // Capa de Etiquetas Esri (Se mantiene para el híbrido)
         const esriOverlayLabels = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
             attribution: 'Esri, Garmin, FAO, NOAA, USGS',
             maxZoom: 17,
             transparent: true
           });

        // Capa Híbrida (Satélite + Etiquetas) (Se mantiene)
         const hybridEsriLayer = L.layerGroup([satelliteLayer, esriOverlayLabels]);


        // --- Capa de superposición WMS de la Dirección General del Catastro ---
        const catastroWmsUrl = 'https://ovc.catastro.meh.es/Cartografia/WMS/ServidorWMS.aspx';
        const catastroLayer = L.tileLayer.wms(catastroWmsUrl, {
            layers: 'Catastro',
            styles: '',
            format: 'image/png',
            transparent: true,
            attribution: 'Cartografía &copy; Dirección General del Catastro (España)',
            maxZoom: 20
        });

        // --- Añade capas iniciales al mapa ---
        // Mantenemos minimalBaseLayer como capa base por defecto
        minimalBaseLayer.addTo(map);
        catastroLayer.addTo(map);

        // --- Configura el control de capas (se actualizará al cargar GeoJSON y otros datos) ---
        const baseLayers = {
            "Fondo Claro Minimalista": minimalBaseLayer,
            "Híbrido Satélite+Etiquetas (Esri)": hybridEsriLayer
        };

        const overlayLayers = {
             "Cartografía Catastral (WMS)": catastroLayer,
             "Pasadas Generadas": generatedPassesLayer
        };

        let layersControl = L.control.layers(baseLayers, overlayLayers).addTo(map);


        // --- Funciones de carga de datos y actualización de interfaz ---

        // Función para actualizar el control de capas
        function updateLayersControl() {
             if (layersControl) map.removeControl(layersControl);
             layersControl = L.control.layers(baseLayers, overlayLayers).addTo(map);
        }

        // Función genérica para cargar GeoJSON y añadirlo al mapa (adaptada para promesas)
        function loadGeoJSONLayer(url, layerName, style = {}) {
            loadingStatusDiv.textContent = `Cargando ${layerName}...`;
            console.log(`Iniciando carga de ${layerName} desde: ${url}`);
            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}, URL: ${url}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log(`${layerName} cargado con éxito. Número de features: ${data.features ? data.features.length : 'N/D'}`);
                    const layer = L.geoJSON(data, { style: style }); // NO añadir a mapa inmediatamente en esta función
                    return { name: layerName, layer: layer, data: data, error: null }; // Devolver info de la capa y datos
                })
                .catch(error => {
                    console.error(`Error cargando ${layerName} desde ${url}:`, error);
                    loadingStatusDiv.textContent = `Error cargando ${layerName}.`;
                    // No alertar por cada error individual en Promise.all, se gestiona al final.
                    return { name: layerName, layer: null, data: null, error: error }; // Indicar que hubo un error
                });
        }

         // Función para cargar el GeoTIFF COG
         function loadGeoTIFFLayer(url, layerName, opacity = 0.5, style = {}) {
             loadingStatusDiv.textContent = `Cargando ${layerName}...`;
             console.log(`Iniciando carga de ${layerName} desde: ${url}`);
              // Verificar si proj4js está cargado y la proyección está definida antes de intentar usarlo con georaster
             if (typeof proj4 === 'undefined' || !proj4.defs("EPSG:25830")) {
                  const error = new Error("Proj4js o la definición EPSG:25830 no está disponible. No se cargará el GeoTIFF.");
                  console.error(`Error cargando ${layerName}: ${error.message}`);
                  loadingStatusDiv.textContent = `Error cargando ${layerName}.`;
                  return Promise.resolve({ name: layerName, georaster: null, layer: null, error: error });
             }

             return fetch(url)
                 .then(response => {
                     if (!response.ok) {
                         throw new Error(`HTTP error! status: ${response.status}, URL: ${url}`);
                     }
                     return response.arrayBuffer();
                 })
                 .then(arrayBuffer => {
                     console.log("Archivo GeoTIFF cargado en ArrayBuffer. Intentando parsear GeoRaster...");
                      // parseGeoRaster es proporcionado por la librería georaster
                     if (typeof parseGeoRaster === 'undefined') {
                          const error = new Error("Librería GeoRaster no cargada correctamente. parseGeoRaster no definido.");
                           console.error(`Error parseando GeoTIFF de ${layerName}: ${error.message}`);
                            loadingStatusDiv.textContent = `Error cargando ${layerName}: Librería GeoRaster.`;
                           return Promise.reject(error); // Rechazar la promesa para que Promise.all falle
                     }
                     return parseGeoRaster(arrayBuffer); // Esto devuelve una Promise
                 })
                 .then(georaster => {
                     console.log("GeoRaster de elevación parseado con éxito:", georaster);
                      // Crear la capa de Leaflet a partir del objeto GeoRaster.
                      // georaster-layer-for-leaflet usa proj4js para re-proyectar al vuelo.
                      const layer = new GeoRasterLayer({
                          georaster: georaster,
                          opacity: opacity,
                          // pixelValuesToColorFn: ... // Puedes añadir estilo aquí
                          // range: ...
                          // colors: ...
                      });
                      console.log(`${layerName} cargado con éxito.`);
                      return { name: layerName, georaster: georaster, layer: layer, error: null }; // Devolver info y el objeto georaster
                 })
                 .catch(error => {
                      console.error(`Error cargando y parseando GeoTIFF de ${layerName} desde ${url}:`, error);
                       loadingStatusDiv.textContent = `Error cargando ${layerName}.`;
                       // No alertar por cada error individual
                       return { name: layerName, georaster: null, layer: null, error: error }; // Indicar error
                 });
         }


        // --- Carga automática de datos al cargar la página ---
        document.addEventListener('DOMContentLoaded', function() {
            console.log("El DOM está cargado. Iniciando carga automática de datos geoespaciales.");
            console.log("Estado de exclusionFeatures global al inicio del DOMContentLoaded:", window.exclusionFeatures ? window.exclusionFeatures.length : 'undefined/null');
            loadingStatusDiv.textContent = 'Cargando datos...';
            generarPasadasBtn.disabled = true; // Asegurarse de que esté deshabilitado durante la carga


            // *** URLs de TUS ARCHIVOS EN GITHUB RAW ***
            // ** IMPORTANTE: Para evitar errores CORS, asegúrate de que tu página HTML también se sirve desde un servidor web (no abrir directamente desde file:///...). **
            // ** Las URLs raw.githubusercontent.com suelen permitir CORS si la página se sirve vía http/https. **
            const parcelasGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/JSON/main/PARCELA.geojson'; // URL DE PARCELAS (seleccionable)
            const construccionesGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/parcela/main/CONSTRU.json'; // URL DE CONSTRUCCIONES (exclusión)
            const elementosInternosGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/parcela/main/ELEMLIN.json'; // URL DE ELEMENTOS INTERNOS (exclusión - puede necesitar buffer)
            const mdtUrl = 'https://raw.githubusercontent.com/tinajita/parcela/main/MDT25-ETRS89-H30-1051-1-COB2.tif'; // URL del GeoTIFF COG de elevación (0.93 MB)
            const contourLinesUrl = 'https://raw.githubusercontent.com/tinajita/parcela/main/BTN0201L_CUR_NIV.json'; // URL del GeoJSON de curvas de nivel simplificadas (aprox 6.32 MB)
            // *** FIN URLs ***

            const units = 'meters'; // Unidades para Turf.js (buffer)
            const bufferDistanceForLines = 2; // Define una distancia de buffer adecuada en metros para LineStrings de ELEMLIN.json


            // Usar Promise.all para cargar todos los archivos concurrentemente
            Promise.all([
                loadGeoJSONLayer(parcelasGeojsonDataUrl, 'Mis Parcelas', { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 }), // Estilo por defecto de parcela
                loadGeoJSONLayer(construccionesGeojsonDataUrl, 'Construcciones', { color: 'red', weight: 2, opacity: 0.7, fillOpacity: 0.3 }),
                loadGeoJSONLayer(elementosInternosGeojsonDataUrl, 'Viales y Arroyos', { // Estilo adaptado para líneas/polígonos
                           style: feature => {
                                if (feature.geometry && feature.geometry.type === 'LineString') {
                                     return { color: '#0000FF', weight: 2, opacity: 0.8 };
                                } else if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                                     return { color: '#006400', weight: 1, fillColor: '#006400', fillOpacity: 0.3 };
                                }
                                return { color: '#888888', weight: 1, opacity: 0.5 };
                           }
                        }),
                loadGeoTIFFLayer(mdtUrl, 'Elevación (MDT25)', 0.5), // Cargar el GeoTIFF
                loadGeoJSONLayer(contourLinesUrl, 'Curvas de Nivel', { color: '#888', weight: 1, opacity: 0.7 }) // Cargar Curvas de Nivel GeoJSON
            ])
            .then(results => {
                console.log("Resultados de carga de Promise.all:", results);
                let allKeyDataLoadedSuccessfully = true; // Bandera para verificar si todos los archivos clave cargaron sin error

                // Procesar los resultados de la carga
                 results.forEach(result => {
                     if (result.error) {
                          allKeyDataLoadedSuccessfully = false;
                          // El error ya fue loggeado en la función de carga.
                          // Podemos mostrar un mensaje de error general al final si allKeyDataLoadedSuccessfully es false.
                     } else {
                         // Si la carga fue exitosa, procesar y añadir la capa al mapa/control
                         if (result.name === 'Mis Parcelas') {
                             parcelasLayer = result.layer;
                             parcelasGeoJSON = result.data;
                             if (parcelasGeoJSON) {
                                 populateSelect('parcel-select', parcelasGeoJSON, 'CODIGO'); // Poblar el selector de parcela
                             } else { allKeyDataLoadedSuccessfully = false; console.error("Datos de Parcelas nulos."); }
                         } else if (result.name === 'Construcciones') {
                              construccionesLayer = result.layer;
                              // Recopilar geometrías de exclusión (Polygon/MultiPolygon) si los datos son válidos
                              if (result.data && result.data.features) {
                                  result.data.features.forEach(feature => {
                                      if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                                          window.exclusionFeatures.push(JSON.parse(JSON.stringify(feature)));
                                      }
                                  });
                              } else { console.warn("Datos de Construcciones nulos o vacíos."); }
                         } else if (result.name === 'Viales y Arroyos') {
                              elementosInternosLayer = result.layer;
                              // Recopilar geometrías de exclusión (LineString -> Buffer, Polygon/MultiPolygon) si los datos son válidos
                               if (result.data && result.data.features) {
                                   result.data.features.forEach(feature => {
                                       if (feature.geometry) {
                                           if (feature.geometry.type === 'LineString') {
                                                try {
                                                    // Asegurarse de que turf está cargado antes de buffer
                                                    if (typeof turf !== 'undefined') {
                                                         const buffered = turf.buffer(feature, bufferDistanceForLines, {units: units});
                                                          if (buffered && buffered.geometry && (buffered.geometry.type === 'Polygon' || buffered.geometry.type === 'MultiPolygon')) {
                                                               window.exclusionFeatures.push(JSON.parse(JSON.stringify(buffered)));
                                                          } else {
                                                               console.warn("Buffer de LineString no válido para exclusión:", feature);
                                                          }
                                                    } else { console.error("Turf.js no cargado para buffer de Linea."); }

                                                } catch(e) { console.error("Error buffer LineString:", e); }
                                           } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                                                window.exclusionFeatures.push(JSON.parse(JSON.stringify(feature)));
                                           }
                                       }
                                   });
                               } else { console.warn("Datos de Viales y Arroyos nulos o vacíos."); }
                         } else if (result.name === 'Elevación (MDT25)') {
                             elevationGeoRaster = result.georaster; // Almacenar el objeto georaster
                             // La capa Leaflet ya se creó y añadió en loadGeoTIFFLayer si el georaster es válido
                             if (!elevationGeoRaster) { allKeyDataLoadedSuccessfully = false; console.error("Objeto georaster nulo después de la carga."); }
                             else { overlayLayers["Elevación (MDT25)"] = result.layer; } // Añadir capa al control
                         } else if (result.name === 'Curvas de Nivel') {
                             contourLinesGeoJSON = result.data; // Almacenar los datos GeoJSON de curvas de nivel
                              // La capa Leaflet ya se creó y añadió en loadGeoJSONLayer si los datos son válidos
                              if (!contourLinesGeoJSON) { allKeyDataLoadedSuccessfully = false; console.error("Datos GeoJSON de Curvas de Nivel nulos."); }
                               else { overlayLayers["Curvas de Nivel"] = result.layer; } // Añadir capa al control
                         }

                          // Añadir la capa Leaflet al mapa si se creó correctamente
                         if (result.layer) {
                             result.layer.addTo(map);
                         }
                     }
                 });

                 console.log(`Total features de exclusión recopiladas: ${window.exclusionFeatures.length}`);
                 console.log("Estado de exclusionFeatures global DESPUÉS de la carga:", window.exclusionFeatures.length, window.exclusionFeatures);

                // Actualizar el control de capas final
                updateLayersControl();

                // Ajustar la vista del mapa a la extensión de las Parcelas si se cargaron
                if (parcelasLayer && parcelasLayer.getBounds().isValid()) {
                     map.fitBounds(parcelasLayer.getBounds());
                } else {
                     console.warn("No se pudieron obtener bounds válidos de la capa de parcelas. Ajustando vista a Ronda...");
                      map.setView([36.7462, -5.1612], 14); // Fallback
                }

                 // Habilitar el botón si todos los datos CLAVE cargaron sin errores reportados en Promise.all
                 // Los datos clave son: Parcelas (geoJSON), Elevación (georaster), Curvas de Nivel (geoJSON)
                 if (allKeyDataLoadedSuccessfully && parcelasGeoJSON && elevationGeoRaster && contourLinesGeoJSON) {
                     loadingStatusDiv.textContent = 'Datos cargados. Selecciona una parcela.';
                     generarPasadasBtn.disabled = false; // Habilitar solo si los datos clave cargaron
                     console.log("Carga automática de datos finalizada con éxito. Selecciona una parcela.");
                 } else {
                      loadingStatusDiv.textContent = 'Carga de datos completada con errores.';
                      console.error("La carga automática de datos finalizó, pero faltan datos clave. El botón de generar pasadas está deshabilitado.");
                      // Un alert general al final si hubo algún error de carga clave
                      if (!parcelasGeoJSON || !elevationGeoRaster || !contourLinesGeoJSON) {
                           alert("No se pudieron cargar todos los datos necesarios (Parcelas, Elevación o Curvas de Nivel). Revisa la consola para detalles.");
                      }
                 }


            })
            .catch(error => {
                 // Este catch se ejecutará si Promise.all falla catastróficamente,
                 // pero los errores individuales ya se manejan en cada función de carga.
                console.error("Error inesperado en Promise.all durante la carga de datos:", error);
                loadingStatusDiv.textContent = `Error crítico durante la carga: ${error.message}`;
                alert(`Ocurrió un error crítico durante la carga de datos. Revisa la consola. Error: ${error.message}`);
            });
        });


        // Función para poblar un selector (select) con opciones de un FeatureCollection
        function populateSelect(selectId, featureCollection, propertyName) {
            const selectElement = document.getElementById(selectId);
            if (!selectElement || !featureCollection || !featureCollection.features) {
                console.warn(`No se pudo poblar el selector ${selectId}.`);
                return;
            }

            // Limpiar opciones existentes (excepto la primera, si es una opción por defecto)
            selectElement.innerHTML = '<option value="">-- Seleccionar --</option>';

            featureCollection.features.forEach(feature => {
                if (feature.properties && feature.properties[propertyName]) {
                    const option = document.createElement('option');
                    option.value = feature.properties[propertyName]; // Usar el código como valor
                    option.textContent = feature.properties[propertyName]; // Mostrar el código como texto
                    // También puedes mostrar otros atributos si son relevantes
                    // option.textContent = `Código: ${feature.properties[propertyName]} - Tipo: ${feature.properties.TIPO || 'N/D'}`;
                    selectElement.appendChild(option);
                }
            });
             console.log(`Selector '${selectId}' poblado con ${featureCollection.features.length} opciones.`);
        }

        // Manejar la selección de parcela
        const parcelSelect = document.getElementById('parcel-select');
        // Asegúrate de que el select de parcela existe en tu HTML. Se ha añadido en el código modificado.
        if (parcelSelect) {
            parcelSelect.addEventListener('change', (event) => {
                const selectedCode = event.target.value;

                // Limpiar selección anterior y estilo
                if (selectedLayer) {
                    // Restaurar estilo original si lo guardaste, o un estilo por defecto si no
                    const originalStyleToRestore = originalStyle[selectedLayer._leaflet_id] || { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 };
                    selectedLayer.setStyle(originalStyleToRestore);
                }
                selectedLayer = null; // Limpiar la referencia a la capa Leaflet seleccionada
                let selectedParcelGeoJSON = null; // Variable para almacenar el GeoJSON del feature seleccionado

                generarPasadasBtn.disabled = true; // Deshabilitar botón hasta seleccionar una válida

                if (selectedCode && parcelasGeoJSON && parcelasGeoJSON.features) {
                     const featureFound = parcelasGeoJSON.features.find(feature => feature.properties && feature.properties.CODIGO === selectedCode);

                    if (featureFound) {
                         // Si modificas el estilo de la capa existente (como en el original)
                         if (parcelasLayer) { // Asegúrate de que la capa de parcelas esté cargada
                              parcelasLayer.eachLayer(layer => {
                                   if (layer.feature && layer.feature.properties && layer.feature.properties.CODIGO === selectedCode) {
                                        // Guardar el estilo original antes de aplicarle el estilo de selección
                                        // Clonar para evitar modificar el objeto original en caso de que el estilo sea complejo
                                        originalStyle[layer._leaflet_id] = JSON.parse(JSON.stringify(layer.options.style));
                                        layer.setStyle({ color: '#00FFFF', weight: 3, fillColor: '#00FFFF', fillOpacity: 0.3 }); // Estilo de selección
                                        selectedLayer = layer; // Guarda la referencia a la capa Leaflet seleccionada
                                        selectedParcelGeoJSON = layer.feature; // Guarda el GeoJSON del feature seleccionado
                                        map.fitBounds(layer.getBounds()); // Acercar el mapa
                                        // generarPasadasBtn.disabled = false; // Habilitar botón aquí si los datos clave ya están cargados (se verifica al final de DOMContentLoaded)
                                        // Habilitar botón solo si la parcela es válida Y los datos clave ya cargaron
                                        if (parcelasGeoJSON && elevationGeoRaster && contourLinesGeoJSON) {
                                            generarPasadasBtn.disabled = false;
                                        }

                                        console.log("Parcela seleccionada:", selectedParcelGeoJSON.properties);
                                        L.DomEvent.stopPropagation(event); // Evitar propagación del clic si fuera relevante

                                        // Aquí podrías añadir lógica para filtrar y mostrar las exclusiones relevantes a esta parcela
                                        // o para realizar alguna otra acción específica de la parcela.

                                   } else {
                                        // Asegurarse de que las otras parcelas tengan su estilo original
                                        // Usar el estilo guardado, o el estilo por defecto si no se guardó (aunque debería haberse guardado)
                                        const styleToRestore = originalStyle[layer._leaflet_id] || { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 };
                                        layer.setStyle(styleToRestore);
                                   }
                              });
                         } else {
                             console.warn("La capa de parcelas no está cargada al intentar seleccionar.");
                         }

                    } else {
                        console.warn("No se encontró la parcela con el código:", selectedCode, "en los datos cargados.");
                        alert("No se encontró la parcela seleccionada en los datos cargados.");
                    }
                }
                // Si selectedParcelGeoJSON es null al final (no se encontró o seleccionó '-- Seleccionar --'), el botón seguirá deshabilitado.
            });
        } else {
             console.error("Elemento 'parcel-select' no encontrado en el DOM. Asegúrate de que está en tu HTML.");
        }


        // El selector 'avoid-select' en el HTML original no tenía funcionalidad asociada.
        // Si necesitas implementar la selección de zonas a evitar desde un select, necesitarás
        // poblarlo con opciones (ej. IDs de construcciones/viales) y manejar su selección.
        // La lógica de exclusión de zonas a evitar en la generación de pasadas ya usa la variable
        // global `window.exclusionFeatures` poblada al inicio. Puedes usar esa variable.


        // --- LÓGICA PARA GENERAR PASADAS OPTIMIZADAS USANDO TURF.JS Y DATOS DE ELEVACIÓN/CURVAS ---

        generarPasadasBtn.addEventListener('click', function() {

            // --- VERIFICACIÓN DE TURF ---
            console.log("Estado de 'turf' al hacer clic en Generar Pasadas:", typeof turf);
            if (typeof turf === 'undefined') {
                console.error("Error: La biblioteca Turf.js no se cargó correctamente.");
                alert("Error: La biblioteca Turf.js no está disponible. No se pueden generar pasadas. Revisa la consola.");
                return;
            }
            // --- FIN VERIFICACIÓN ---

            console.log("--- Inicio Generación de Pasadas ---");

            // --- Verificar que los datos necesarios estén cargados ---
            if (!selectedLayer || !selectedLayer.feature || !selectedLayer.feature.geometry || (selectedLayer.feature.geometry.type !== 'Polygon' && selectedLayer.feature.geometry.type !== 'MultiPolygon')) {
                 alert("Por favor, selecciona una parcela válida haciendo clic en ella primero.");
                 console.warn("selectedLayer no es una parcela válida o no tiene geometría poligonal:", selectedLayer);
                 return;
             }
             // Verificar que los datos clave para la lógica de elevación/curvas están disponibles
            if (!elevationGeoRaster) {
                alert("Los datos de elevación (MDT) no están disponibles. No se puede generar pasadas sensibles al terreno.");
                console.warn("Objeto georaster de elevación no disponible:", elevationGeoRaster);
                return;
            }
             if (!contourLinesGeoJSON || !contourLinesGeoJSON.features) {
                 alert("Los datos de curvas de nivel no están disponibles. No se puede generar pasadas sensibles al terreno.");
                 console.warn("Datos GeoJSON de curvas de nivel no disponibles o vacíos:", contourLinesGeoJSON);
                 return;
             }


            const selectedParcelGeoJSON = selectedLayer.toGeoJSON();
            let parcelGeometry = selectedParcelGeoJSON.geometry; // Geometría de la parcela seleccionada
            const parcelFeature = turf.feature(parcelGeometry); // La parcela como feature para intersecciones

            generatedPassesLayer.clearLayers(); // Limpiar pasadas anteriores
            console.log("Limpiando pasadas generadas anteriormente.");

            // --- Obtener el ancho de trabajo del input ---
            const workingWidth = parseFloat(workingWidthInput.value);
            if (isNaN(workingWidth) || workingWidth <= 0) {
                 alert("Por favor, introduce un valor válido y positivo para el ancho de trabajo.");
                 console.error("Valor inválido para ancho de trabajo:", workingWidthInput.value);
                 return;
            }
            // --- Fin Obtener ancho de trabajo ---

            const units = 'meters'; // Unidades para Turf.js

            // *** UMBRAL DE PENDIENTE ***
            // Define aquí el porcentaje de pendiente a partir del cual el tractor debe seguir las curvas de nivel.
            const slopeThresholdPercent = 10; // Ejemplo: 10% de pendiente. AJUSTA ESTE VALOR.
            console.log(`Umbral de pendiente para cambio de lógica: ${slopeThresholdPercent}%`);


            try {
                // --- Lógica para obtener features de exclusión que intersectan con la parcela seleccionada (usando window.exclusionFeatures) ---
                 let intersectingExclusionFeatures = []; // Array para almacenar las FEATURES de exclusión que INTERSECTAN
                 const globalExclusionFeatures = window.exclusionFeatures || []; // Acceder a la variable global

                 if (globalExclusionFeatures.length > 0) {
                     console.log(`Filtrando features de exclusión para encontrar las que intersectan con la parcela seleccionada.`);
                      globalExclusionFeatures.forEach((exclusionFeature) => {
                         if (exclusionFeature.geometry && (exclusionFeature.geometry.type === 'Polygon' || exclusionFeature.geometry.type === 'MultiPolygon')) {
                              try {
                                  // booleanIntersects verifica si las geometrías se tocan o se cruzan.
                                  if (turf.booleanIntersects(parcelFeature, exclusionFeature)) {
                                     intersectingExclusionFeatures.push(exclusionFeature);
                                  }
                              } catch (e) { console.warn(`Error al verificar intersección para feature de exclusión. Se omitirá.`, exclusionFeature, e); }
                         }
                      });
                 } else { console.log("No se cargaron features de exclusión globalmente."); }
                 console.log(`Features de exclusión que intersectan con la parcela seleccionada: ${intersectingExclusionFeatures.length}`);

                // --- Calcular el área limpia (Parcela - Unión de ExclusionFeatures simplificadas que intersectan) ---
                let geometryForCalculations = parcelGeometry; // Inicialmente es la parcela completa

                // TU LÓGICA EXISTENTE PARA CALCULAR `geometryForCalculations`
                // A PARTIR DE `parcelGeometry` y `intersectingExclusionFeatures` VA AQUÍ.
                // (El código extenso que tenías antes con turf.union, turf.difference, turf.simplify)
                // Asegúrate de que, si la lógica de exclusión se ejecuta, `geometryForCalculations`
                // se actualice a la geometría del área limpia resultante (Polygon o MultiPolygon).
                // Si no hay exclusiones o la lógica falla, `geometryForCalculations` debe seguir siendo la `parcelGeometry`.

                // EJEMPLO SIMPLIFICADO de cómo aplicar la diferencia si hay exclusiones
                if (intersectingExclusionFeatures.length > 0) {
                     try {
                         // turf.union puede manejar múltiples polígonos/multipolígonos
                         const unionOfExclusionsFeature = turf.union(...intersectingExclusionFeatures);

                         if (unionOfExclusionsFeature && unionOfExclusionsFeature.geometry) {
                             // turf.difference(feature1, feature2) feature1 - feature2
                             const cleanedAreaFeature = turf.difference(parcelFeature, unionOfExclusionsFeature);

                             if (cleanedAreaFeature && cleanedAreaFeature.geometry) {
                                 geometryForCalculations = cleanedAreaFeature.geometry; // Usar la geometría del área limpia
                                 console.log("Área limpia calculada después de exclusiones.");
                                  // Opcional: Aplicar una ligera simplificación a la geometría del área limpia si es muy compleja
                                  // try { geometryForCalculations = turf.simplify(turf.feature(geometryForCalculations), { tolerance: 0.00001, highQuality: true }).geometry; } catch(e) { console.warn("Error simplificando área limpia:", e); }
                             } else {
                                console.warn("Resultado de turf.difference es nulo o sin geometría. Usando geometría de parcela completa para pasadas.");
                                 alert("Advertencia: No se pudo calcular el área limpia correctamente. Generando pasadas sobre la parcela completa.");
                             }
                         } else {
                             console.warn("Resultado de turf.union de exclusiones es nulo o sin geometría. Usando geometría de parcela completa para pasadas.");
                              alert("Advertencia: No se pudo unir las áreas a evitar correctamente. Generando pasadas sobre la parcela completa.");
                         }
                     } catch (e) {
                         console.error("Error en lógica de unión/diferencia para exclusiones:", e);
                          alert("Error al excluir zonas a evitar. Generando pasadas sobre la parcela completa. Revisa consola.");
                     }
                 } else {
                     console.log("No hay zonas a evitar que intersecten. Generando pasadas sobre la parcela completa.");
                 }


                 // VALIDACIONES BÁSICAS del área para pasar
                 if (!geometryForCalculations || !(geometryForCalculations.type === 'Polygon' || geometryForCalculations.type === 'MultiPolygon')) {
                     console.error("La geometría final para cálculos no es un Polígono/MultiPolígono válido.");
                     alert("Error: La geometría resultante para generar pasadas no es válida.");
                     return;
                 }
                 try { if (turf.area(turf.feature(geometryForCalculations)) === 0) { alert("El área para generar pasadas es cero."); return; } } catch(e) { console.error("Error área:", e); return; }


                // --- *** N U E V A   L Ó G I C A   D E   G E N E R A C I Ó N   C O N   E L E V A C I Ó N   Y   C U R V A S *** ---
                // Esta es la parte que DEBES implementar basándote en tus datos cargados.
                // El algoritmo para generar pasadas que cambian de dirección según la pendiente
                // y siguen las curvas de nivel es complejo y requiere un diseño específico.

                const generatedPassesFeatures = []; // Array para almacenar los Features (LineString) de las pasadas finales

                // Tienes disponibles:
                // - `geometryForCalculations`: La geometría (Polygon/MultiPolygon) del área limpia donde generar pasadas.
                // - `elevationGeoRaster`: El objeto `georaster` del MDT (para obtener elevación).
                // - `contourLinesGeoJSON`: Los datos GeoJSON de las curvas de nivel (vectoriales).
                // - `workingWidth`: El ancho de trabajo.
                // - `slopeThresholdPercent`: El umbral de pendiente.
                // - `map`: El objeto del mapa Leaflet.

                // Concepto del algoritmo (pseudocódigo - rellenar con lógica real):
                // 1. Determinar una dirección general de inicio para las pasadas (ej. la más larga de la parcela limpia, o un ángulo fijo del input `angleInput.value`).
                // 2. Generar puntos de partida para las pasadas en esa dirección general, separados por el `workingWidth`, cubriendo el ancho del área limpia.
                // 3. Para cada punto de partida:
                //    a. Empezar a trazar la pasada a partir de ese punto.
                //    b. Muestrear puntos a intervalos cortos (ej. cada 1-2 metros) a lo largo de la pasada.
                //    c. Para cada punto de muestreo (o segmento entre puntos):
                //       i. **Obtener la elevación:** Usar `elevationGeoRaster.getValueAt(lng, lat, { planar: true })` con las coordenadas del punto (en WGS84). Ojo: `getValueAt` puede ser asíncrono (devuelve Promise). Necesitarás manejar Promesas si el método es asíncrono.
                //       ii. **Calcular la pendiente:** Estimar la pendiente en ese punto/segmento. Esto es complejo. Una forma simple es obtener la elevación de puntos vecinos (en el ráster) y calcular la diferencia / distancia. Una forma más avanzada requeriría un análisis de pendiente local sobre el `georaster`.
                //       iii. **Tomar decisión según la pendiente:**
                //           - Si la pendiente es MAYOR que `slopeThresholdPercent`:
                //               - La dirección para el siguiente segmento de la pasada DEBE ser **paralela a la curva de nivel cercana**.
                //               - Usar `turf.nearestPointOnLine` con el punto actual y el `contourLinesGeoJSON` (el FeatureCollection de líneas) para encontrar el punto más cercano en una curva de nivel Y la curva de nivel misma.
                //               - Obtener la dirección de la curva de nivel en ese punto (esto es complejo, podría requerir muestrear la curva cercana o usar turf.along/bearing en la curva). La dirección de la curva de nivel es la tangente.
                //               - La dirección deseada para la pasada es **paralela** a esa tangente (la misma dirección que la curva en ese punto).
                //               - Generar el siguiente punto de la pasada siguiendo esta dirección **paralela** por la distancia de muestreo.
                //           - Si la pendiente es MENOR o igual que `slopeThresholdPercent`:
                //               - Seguir la **dirección general** de barrido inicial para el siguiente segmento.
                //               - Generar el siguiente punto de la pasada siguiendo la dirección general por la distancia de muestreo.
                //       iv. Asegurarse de que el punto generado sigue dentro de `geometryForCalculations` (el área limpia) usando `turf.booleanPointInPolygon`. Si sale, terminar el segmento actual.
                //    d. Conectar los puntos generados para formar los segmentos de pasada y añadirlos a `generatedPassesFeatures`.

                // --- ESTE ES UN EJEMPLO RECTO/BARRIDO SIMPLE QUE DEBES REEMPLAZAR ---
                // Utiliza `geometryForCalculations` (el área limpia) en lugar de la parcela original.
                // Esto NO usa los datos de elevación ni las curvas de nivel.
                 console.log("Generando pasadas rectas simuladas (NO considera elevación/curvas)...");
                 try {
                     const bbox = turf.bbox(turf.feature(geometryForCalculations)); // Bbox del área limpia
                     const sweepAngle = 90 - parseFloat(workingWidthInput.value); // Usar el ángulo del input ahora
                     const density = workingWidth; // Densidad es el ancho de trabajo

                     const optionsSweep = { units: units, resolution: 20 }; // Ajusta resolución si es necesario
                     const originPoint = turf.point([bbox[0], bbox[1]]); // Origen del barrido (esquina SW del bbox del área limpia)

                      // Generar líneas de barrido para cubrir el bbox con el ancho de trabajo
                       const bboxDiagonal = turf.distance(turf.point(bbox[0], bbox[1]), turf.point(bbox[2], bbox[3]), {units: units});
                        const totalSweepExtent = bboxDiagonal + density; // Asegurar que cubra la diagonal + margen

                        // Calcular el vector de movimiento perpendicular a la pasada
                        const moveDirection = sweepAngle + 90; // 90 grados respecto a la dirección de pasada
                        const moveDistanceKm = density / 1000;

                       // Generar la primera línea de barrido muy larga
                       let startPoint = turf.destination(originPoint, -(bboxDiagonal/2)/1000, sweepAngle, {units: 'kilometers'}); // Empezar cerca del centro del bbox
                       let endPoint = turf.destination(startPoint, bboxDiagonal/1000, sweepAngle, {units: 'kilometers'});
                       let currentSweepLine = turf.lineString([startPoint.geometry.coordinates, endPoint.geometry.coordinates]);


                       let safetyCounter = 0;
                       const maxSweeps = Math.ceil(totalSweepExtent / density) + 5; // Límite de seguridad

                       // Mover la línea de barrido por el ancho de trabajo e intersectar
                       while(safetyCounter < maxSweeps) {

                           try {
                                // Intersectar la línea de barrido actual con la geometría del área limpia
                                // lineIntersect devuelve un FeatureCollection de Puntos
                                const intersection = turf.lineIntersect(currentSweepLine, turf.feature(geometryForCalculations));

                                if (intersection && intersection.features && intersection.features.length > 0) {
                                    // Los puntos de intersección definen los segmentos de la pasada dentro del área limpia.
                                    // Asegurarse de que los puntos están ordenados a lo largo de la línea de barrido.
                                     const points = intersection.features.map(f => f.geometry.coordinates);
                                     // Ordenar puntos basadas en su distancia desde el inicio de la línea de barrido
                                     const sweepLineStartTurf = turf.point(currentSweepLine.geometry.coordinates[0]);
                                     points.sort((a, b) => {
                                          const distA = turf.distance(sweepLineStartTurf, turf.point(a), {units: units});
                                          const distB = turf.distance(sweepLineStartTurf, turf.point(b), {units: units});
                                          return distA - distB;
                                     });


                                    // Crear segmentos uniendo pares de puntos (entrada/salida del polígono)
                                    for (let i = 0; i < points.length - 1; i += 2) {
                                        const p1 = points[i];
                                        const p2 = points[i+1];
                                        try {
                                            const segment = turf.lineString([p1, p2]);
                                             if (segment && segment.geometry && segment.geometry.type === 'LineString') {
                                                  // Añadir este segmento como una "pasada" generada
                                                  generatedPassesFeatures.push(segment);
                                             } else {
                                                  console.warn("Segmento de pasada generado no es LineString válido.", segment);
                                             }

                                        } catch(e) {
                                              console.error("Error creando segmento de pasada a partir de puntos de intersección:", p1, p2, e);
                                        }

                                    }
                                }

                            } catch(e) {
                                console.error(`Error en turf.lineIntersect para offset ${currentOffsetDistance}m:`, e);
                                 // Continuar al siguiente offset incluso si esta intersección falló
                            }

                            // Mover la línea de barrido al siguiente offset (perpendicular a la pasada)
                             const movedStart = turf.destination(turf.point(currentSweepLine.geometry.coordinates[0]), moveDistanceKm, moveDirection, {units: 'kilometers'});
                             const movedEnd = turf.destination(turf.point(currentSweepLine.geometry.coordinates[currentSweepLine.geometry.coordinates.length - 1]), moveDistanceKm, moveDirection, {units: 'kilometers'});
                             currentSweepLine = turf.lineString([movedStart.geometry.coordinates, movedEnd.geometry.coordinates]);


                            // Criterio de salida: si la línea de barrido se ha movido más allá del extremo opuesto del bbox (con un margen)
                            // Una forma simple: verificar si el punto de referencia (el inicio de la línea movida) se ha movido lo suficiente.
                            const totalDistanceMoved = turf.distance(turf.point(startPoint.geometry.coordinates[0]), turf.point(movedStart.geometry.coordinates[0]), {units: units});

                             if (totalDistanceMoved > totalSweepExtent) {
                                  console.log("Criterio de salida del bucle de barrido cumplido (movido más allá de la extensión total necesaria).");
                                  break; // Salir del bucle
                             }

                             safetyCounter++;
                             if (safetyCounter >= maxSweeps) {
                                console.warn(`Se alcanzó el límite máximo de ${maxSweeps} líneas de barrido. El área limpia podría no estar completamente cubierta.`);
                             }

                       } // Fin bucle while


                 } catch (e) {
                     console.error("Error durante la generación de pasadas rectas simuladas:", e);
                     alert("Ocurrió un error general en la simulación de pasadas rectas. Revisa la consola.");
                 }


                // --- Añadir las pasadas generadas al mapa ---
                 const passesFeatureCollection = turf.featureCollection(generatedPassesFeatures);

                 generatedPassesLayer.clearLayers(); // Limpiar pasadas anteriores (ya se hace al inicio del click)
                 L.geoJSON(passesFeatureCollection, {
                     style: { color: 'green', weight: 2 }
                 }).addTo(generatedPassesLayer); // Añadir al featureGroup existente

                // El featureGroup (generatedPassesLayer) ya está añadido al mapa y al control de capas.


                loadingStatusDiv.textContent = `Pasadas generadas: ${generatedPassesFeatures.length} segmentos.`;
                console.log("--- Fin Generación de Pasadas ---");

           } catch (e) {
               console.error("Error general en el evento click de generación de pasadas:", e);
               alert("Ocurrió un error general al generar las pasadas. Revisa la consola para detalles.");
           }
        });


        // --- LÓGICA DE SELECCIÓN DE ZONAS A EVITAR (Requiere implementación adicional si quieres seleccionarlas en el mapa) ---
        // La variable global `window.exclusionFeatures` ya contiene las geometrías de exclusión cargadas
        // (Construcciones y Elementos Linea con buffer si eran líneas).
        // Tu lógica en el evento click ya filtra las que intersectan con la parcela seleccionada
        // y las usa para calcular el área limpia. Puedes usar esa variable.
        // Si quieres poder SELECCIONAR zonas a evitar manualmente en el mapa, necesitarías:
        // 1. Hacer las capas de Construcciones y Viales interactivas (onEachFeature con click listeners).
        // 2. Tener una forma (ej. un botón o modo) para indicar que estás seleccionando zonas a evitar.
        // 3. Al hacer clic en una feature de Construcción o Vial, añadir su geometría (o su buffer si es LineString)
        //    a una lista TEMPORAL de "zonas a evitar seleccionadas por el usuario" para la generación de pasadas actual.
        // 4. Usar esta lista TEMPORAL en la lógica de exclusión dentro del botón de generar pasadas,
        //    EN LUGAR de (o además de) usar la variable global `window.exclusionFeatures` completa.
        // 5. Proporcionar alguna retroalimentación visual de las zonas a evitar seleccionadas por el usuario.
        // Esta implementación es compleja y va más allá del alcance actual. Por ahora, la lógica usa TODAS
        // las exclusiones cargadas que intersectan la parcela.


        // --- LOGS INICIALES ---
        console.log("Mapa Leaflet con capas base, Catastro (WMS) inicializados.");
        console.log("La carga automática de datos geoespaciales (GeoJSON y ráster/vectoriales de elevación) comenzará al terminar de cargar el DOM.");


    </script>

</body>
</html>