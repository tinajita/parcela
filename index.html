<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa con Leaflet, Catastro, GeoJSONs y Generación de Pasadas (Parcelas)</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin="anonymous"/>

    <style>
        #map {
            height: 500px;
            width: 80%;
            margin: 20px auto;
            border: 1px solid #ccc;
        }
        .container {
            position: relative;
            width: 80%;
            margin: 20px auto;
        }
        /* Estilo básico para los controles */
        .control-container {
            text-align: center;
            margin-bottom: 10px;
        }
        .control-container label, .control-container input, .control-container button {
            display: inline-block;
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            vertical-align: middle; /* Alinea verticalmente los elementos */
        }
         .control-container label {
             padding: 10px 5px; /* Ajuste de padding para la etiqueta */
             cursor: default;
        }
        .control-container input[type="number"] {
             width: 80px; /* Ancho fijo para el input number */
             padding: 10px;
        }
         #loading-status {
             margin-top: 10px;
             font-size: 1em;
             color: #555;
         }
    </style>
</head>
<body>

    <div class="control-container">
        <label for="workingWidth">Ancho de Trabajo (m):</label>
        <input type="number" id="workingWidth" value="15" min="1">
        <button id="generarPasadasBtn" disabled>Generar Pasadas (Cargando Datos...)</button>
        <div id="loading-status">Cargando datos geoespaciales...</div>
    </div>


    <div class="container">
        <div id="map"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/georaster@1.7.1/dist/georaster.browser.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/georaster-layer-for-leaflet@3.8.1/dist/georaster-layer-for-leaflet.min.js"></script>


    <script>
        console.log("Estado de 'turf' inmediatamente después del script tag:", typeof turf);
        if (typeof turf === 'undefined') {
             console.error("VERIFICACIÓN: 'turf' es undefined justo después del script tag. El script de Turf.js NO se cargó o ejecutó como se esperaba.");
        } else {
             console.log("VERIFICACIÓN: 'turf' parece estar definido. Tipo:", typeof turf);
        }
    </script>


    <script>
        // Vista inicial en Andalucía (ajustada para Ronda)
        const map = L.map('map').setView([36.7462, -5.1612], 14); // Vista ajustada

        // --- Variables ---
        let selectedLayer = null; // Variable para almacenar la capa (parcela) que está seleccionada
        let originalStyle = {}; // Variable para guardar el estilo original de cada capa de parcela
        let parcelasLayer = null; // Capa para parcelas (seleccionable)
        let construccionesLayer = null; // Capa para construcciones (exclusión)
        let elementosInternosLayer = null; // Capa para viales/arroyos/elementos internos (exclusión)
        window.exclusionFeatures = []; // <--- Modificado: Declarada explícitamente en window
        let generatedPassesLayer = L.featureGroup().addTo(map); // Capa para las pasadas generadas

        // Variables para GeoTIFF y Curvas de Nivel
        let elevationGeoRaster = null; // Almacenará el objeto GeoRaster del MDT
        let contourLinesGeoJSON = null; // Almacenará los datos GeoJSON de las curvas de nivel
        let elevationLayer = null; // Capa Leaflet para el GeoTIFF
        let contourLayer = null; // Capa Leaflet para las curvas de nivel


        // --- Elementos de la interfaz ---
        const generarPasadasBtn = document.getElementById('generarPasadasBtn');
        const workingWidthInput = document.getElementById('workingWidth');
        const loadingStatusDiv = document.getElementById('loading-status'); // Referencia al indicador de carga

        // --- Capas base ---
        // Capa Minimalista (Se mantiene)
        const minimalBaseLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19
        });

        // Capa Satélite Esri (Se mantiene para el híbrido, pero se quita del selector de capas base)
         const satelliteLayer = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
              attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, GeoEye, Earthstar Geographics, CNES/Airbus DS, GeoEye, USDA FSA, USGS, AeroGRID, IGN, IGP, swisstopo, and the GIS User Community',
              maxZoom: 18
         });

        // Capa de Etiquetas Esri (Se mantiene para el híbrido)
         const esriOverlayLabels = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
             attribution: 'Esri, Garmin, FAO, NOAA, USGS',
             maxZoom: 17,
             transparent: true
           });

        // Capa Híbrida (Satélite + Etiquetas) (Se mantiene)
         const hybridEsriLayer = L.layerGroup([satelliteLayer, esriOverlayLabels]);


        // --- Capa de superposición WMS de la Dirección General del Catastro ---
        const catastroWmsUrl = 'https://ovc.catastro.meh.es/Cartografia/WMS/ServidorWMS.aspx';
        const catastroLayer = L.tileLayer.wms(catastroWmsUrl, {
            layers: 'Catastro',
            styles: '',
            format: 'image/png',
            transparent: true,
            attribution: 'Cartografía &copy; Dirección General del Catastro (España)',
            maxZoom: 20
        });

        // --- Añade capas iniciales al mapa ---
        // Mantenemos minimalBaseLayer como capa base por defecto
        minimalBaseLayer.addTo(map);
        catastroLayer.addTo(map);

        // --- Configura el control de capas (se actualizará al cargar GeoJSON) ---
        const baseLayers = {
            "Fondo Claro Minimalista": minimalBaseLayer,
            "Híbrido Satélite+Etiquetas (Esri)": hybridEsriLayer
        };

        const overlayLayers = {
             "Cartografía Catastral (WMS)": catastroLayer,
             "Pasadas Generadas": generatedPassesLayer
        };

        let layersControl = L.control.layers(baseLayers, overlayLayers).addTo(map);


        // --- Funciones de carga de GeoJSON y actualización de interfaz ---

        // Función para actualizar el control de capas
        function updateLayersControl() {
             if (layersControl) map.removeControl(layersControl);
             layersControl = L.control.layers(baseLayers, overlayLayers).addTo(map);
        }

        // Función para cargar un archivo GeoJSON
        async function loadGeoJSONLayer(url, layerOptions = {}) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                const layer = L.geoJSON(data, layerOptions);

                // Extraer nombre de la capa de la URL o definir uno por defecto
                const urlParts = url.split('/');
                const filename = urlParts[urlParts.length - 1];
                const layerName = layerOptions.layerName || filename.replace(/\.[^/.]+$/, "") || 'Capa GeoJSON'; // Usa layerOptions.layerName si está definido, sino el nombre del archivo sin extensión

                return { name: layerName, layer: layer, data: data }; // Devolver un objeto con nombre, capa y datos
            } catch (error) {
                console.error(`Error loading GeoJSON from ${url}:`, error);
                throw error; // Re-lanza el error para que Promise.all pueda manejarlo
            }
        }

         // Función para cargar un archivo GeoTIFF y crear la capa
        async function loadGeoTIFFLayer(url) {
             try {
                 console.log(`Attempting to load GeoTIFF from ${url}`);
                 const response = await fetch(url);
                 if (!response.ok) {
                     throw new Error(`HTTP error! status: ${response.status}`);
                 }
                 const arrayBuffer = await response.arrayBuffer();
                 console.log("ArrayBuffer received. Parsing GeoTIFF...");

                 // Asegúrate de que GeoRaster es global o accesible aquí
                 if (typeof parseGeoRaster === 'undefined') {
                      console.error("Error: parseGeoRaster is not defined. Is GeoRaster script loaded?");
                      throw new Error("GeoRaster library not loaded.");
                 }

                 const georaster = await parseGeoRaster(arrayBuffer);
                 console.log("GeoTIFF parsed successfully:", georaster);

                 // Configura opciones para la capa GeoRaster (puedes ajustar según tus necesidades)
                 const options = {
                     opacity: 0.7,
                     // pixelValuesToColorFn: values => values[0] === 0 ? null : `hsl(${(1 - values[0] / 3000) * 240}, 100%, 50%)`, // Ejemplo de coloreado
                     // bands: [0], // Solo usar la primera banda
                     // Más opciones como resolution, etc.
                 };

                 const layer = new GeoRasterLayer({
                     georaster: georaster,
                     ...options
                 });

                 console.log("GeoRasterLayer created.");

                 return { name: "MDT (GeoTIFF)", layer: layer, data: georaster }; // Devolver objeto con nombre, capa y objeto GeoRaster
             } catch (error) {
                 console.error(`Error loading GeoTIFF from ${url}:`, error);
                 throw error; // Re-lanza el error
             }
        }


        // --- Carga automática de los 3 archivos GeoJSON + GeoTIFF + Curvas de Nivel al cargar la página ---
        document.addEventListener('DOMContentLoaded', function() {
            console.log("El DOM está cargado. Iniciando carga automática de datos GeoJSON y GeoTIFF.");
            console.log("Estado de exclusionFeatures global al inicio del DOMContentLoaded:", window.exclusionFeatures ? window.exclusionFeatures.length : 'undefined/null'); // Log 1
            loadingStatusDiv.textContent = 'Cargando datos geoespaciales...';
            generarPasadasBtn.disabled = true; // Asegurarse de que esté deshabilitado durante la carga

            // *** LAS URLs DE TUS ARCHIVOS ***
            const parcelasGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/JSON/main/PARCELA.geojson'; // <--- URL DE PARCELAS (seleccionable)
            const construccionesGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/parcela/refs/heads/main/CONSTRU.json'; // <--- URL DE CONSTRUCCIONES (exclusión)
            const elementosInternosGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/parcela/refs/heads/main/ELEMLIN.json'; // <--- URL DE ELEMENTOS INTERNOS (exclusión - puede necesitar buffer)
            const mdtGeoTiffDataUrl = 'https://raw.githubusercontent.com/tinajita/MDT/main/MDT05M_ronda.tif'; // <--- URL DEL MDT (GeoTIFF)
            const contourLinesGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/curvas_nivel/main/curvas_nivel.geojson'; // <--- URL DE CURVAS DE NIVEL (GeoJSON)
             // *** FIN URLs ***

             const units = 'meters'; // Unidades para Turf.js (buffer)
             const bufferDistanceForLines = 2; // Define una distancia de buffer adecuada en metros para LineStrings de ELEMLIN.json

            // Usar Promise.all para cargar los 5 archivos concurrentemente
            Promise.all([
                loadGeoJSONLayer(parcelasGeojsonDataUrl, {
                     layerName: "Mis Parcelas", // Nombre legible para el control de capas
                     style: feature => ({ color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 }), // Estilo por defecto de parcela
                     onEachFeature: (feature, layer) => {
                         const defaultStyle = { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 };
                         originalStyle[layer._leaflet_id] = defaultStyle; // Guardar el estilo por defecto

                         layer.on({
                             click: e => {
                                 if (selectedLayer) {
                                     selectedLayer.setStyle(originalStyle[selectedLayer._leaflet_id] || { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 });
                                 }
                                 layer.setStyle({ color: '#00FFFF', weight: 3, fillColor: '#00FFFF', fillOpacity: 0.3 }); // Estilo de selección
                                 selectedLayer = layer;
                                 generarPasadasBtn.disabled = false; // Habilitar botón de generar pasadas
                                 console.log("Parcela seleccionada:", feature.properties);

                                 L.DomEvent.stopPropagation(e);
                             }
                         });
                     }
                 }),
                loadGeoJSONLayer(construccionesGeojsonDataUrl, {
                     layerName: "Construcciones",
                     style: feature => ({ color: '#FF0000', weight: 2, fillColor: '#FF0000', fillOpacity: 0.5 }),
                      onEachFeature: (feature, layer) => {
                          if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                             const clonedFeature = JSON.parse(JSON.stringify(feature));
                              window.exclusionFeatures.push(clonedFeature); // <--- Modificado: Usar window.exclusionFeatures
                         } else {
                              console.warn("Geometría de construcción no es Polígono/MultiPolígono. No se usará para recorte:", feature.geometry);
                         }
                      }
                 }),
                loadGeoJSONLayer(elementosInternosGeojsonDataUrl, {
                     layerName: "Viales y Arroyos",
                      style: feature => {
                           if (feature.geometry && feature.geometry.type === 'LineString') {
                                return { color: '#0000FF', weight: 2, opacity: 0.8 };
                           } else if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                                return { color: '#006400', weight: 1, fillColor: '#006400', fillOpacity: 0.3 };
                           }
                           return { color: '#888888', weight: 1, opacity: 0.5 };
                      },
                      onEachFeature: (feature, layer) => {
                          if (feature.geometry) {
                              if (feature.geometry.type === 'LineString') {
                                  try {
                                      const buffered = turf.buffer(feature, bufferDistanceForLines, {units: units});
                                       if (buffered) {
                                           if (buffered.geometry && (buffered.geometry.type === 'Polygon' || buffered.geometry.type === 'MultiPolygon')) {
                                                const bufferedFeature = JSON.parse(JSON.stringify(buffered));
                                                window.exclusionFeatures.push(bufferedFeature); // <--- Modificado: Usar window.exclusionFeatures
                                           } else {
                                               console.warn("El buffer de LineString no resultó en una geometría válida (Polygon/MultiPolygon) para exclusión:", buffered);
                                           }
                                       } else {
                                           console.warn("No se pudo crear buffer para LineString de Elemento Interno. El resultado de turf.buffer fue nulo/undefined. No se usará para recorte:", feature);
                                       }
                                  } catch (e) {
                                       console.error("Error al crear buffer para LineString:", feature, e);
                                       console.warn("Error al crear buffer para LineString de Elemento Interno. No se usará para recorte.");
                                  }

                              } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                                  const clonedFeature = JSON.parse(JSON.stringify(feature));
                                  window.exclusionFeatures.push(clonedFeature); // <--- Modificado: Usar window.exclusionFeatures
                              } else {
                                   console.warn(`Geometría de Elemento Interno (${feature.geometry.type}) no es LineString, Polígono o MultiPolígono. No se usará para recorte:`, feature.geometry);
                              }
                          }
                      }
                }),
                loadGeoTIFFLayer(mdtGeoTiffDataUrl), // Cargar el GeoTIFF
                loadGeoJSONLayer(contourLinesGeojsonDataUrl, { // Cargar Curvas de Nivel GeoJSON
                     layerName: "Curvas de Nivel",
                      style: feature => ({
                          color: '#555',
                          weight: 1,
                          opacity: 0.7
                     }),
                     onEachFeature: (feature, layer) => {
                          if (feature.properties && feature.properties.ele) { // Asume que la elevación está en la propiedad 'ele'
                              layer.bindTooltip(`${feature.properties.ele}m`);
                          }
                     }
                })
            ])
            .then(([parcelasResult, construccionesResult, elementosInternosResult, mdtResult, contourResult]) => {
                console.log("Todos los archivos GeoJSON y GeoTIFF se cargaron con éxito.");

                // Asignar capas y datos a las variables correspondientes
                parcelasLayer = parcelasResult.layer;
                construccionesLayer = construccionesResult.layer;
                elementosInternosLayer = elementosInternosResult.layer;

                elevationLayer = mdtResult.layer;
                elevationGeoRaster = mdtResult.data; // Almacenar el objeto GeoRaster
                 console.log("Objeto elevationGeoRaster almacenado:", elevationGeoRaster);

                contourLayer = contourResult.layer;
                contourLinesGeoJSON = contourResult.data; // Almacenar los datos GeoJSON de curvas de nivel
                 console.log("Datos contourLinesGeoJSON almacenados:", contourLinesGeoJSON);


                // Añadir capas al mapa y al control de capas (excepto parcelas, que ya se añaden en loadGeoJSONLayer if success)
                 if (parcelasLayer) parcelasLayer.addTo(map); // Asegurar que Parcelas se añade si la carga fue exitosa
                 if (construccionesLayer) construccionesLayer.addTo(map);
                 if (elementosInternosLayer) elementosInternosLayer.addTo(map);

                // Añadir GeoTIFF y Curvas de Nivel al mapa y control de capas
                 if (elevationLayer) {
                     elevationLayer.addTo(map);
                     overlayLayers[mdtResult.name] = elevationLayer; // Añadir al control de capas
                     console.log("Capa GeoTIFF añadida al mapa y control.");
                 } else {
                      console.warn("La capa GeoTIFF no se pudo cargar.");
                 }

                 if (contourLayer) {
                     contourLayer.addTo(map);
                      overlayLayers[contourResult.name] = contourLayer; // Añadir al control de capas
                      console.log("Capa Curvas de Nivel añadida al mapa y control.");
                 } else {
                      console.warn("La capa de Curvas de Nivel no se pudo cargar.");
                 }


                 console.log(`Total features de exclusión recopiladas de Construcciones y Elementos Internos: ${window.exclusionFeatures.length}`); // <--- Modificado: Usar window.exclusionFeatures
                 console.log("Estado de exclusionFeatures global DESPUÉS de la carga:", window.exclusionFeatures.length, window.exclusionFeatures); // Log 2 - Modificado para usar window.


                 // Actualizar el control de capas con las nuevas capas cargadas (incluyendo GeoTIFF y Curvas)
                updateLayersControl();

                // Ajustar la vista del mapa a la extensión de las Parcelas si se cargaron
                if (parcelasLayer && parcelasLayer.getBounds().isValid()) {
                     map.fitBounds(parcelasLayer.getBounds());
                } else {
                     console.warn("No se pudieron obtener bounds válidos de la capa de parcelas. Ajustando vista a Ronda...");
                      map.setView([36.7462, -5.1612], 14); // Fallback
                }

                loadingStatusDiv.textContent = 'Datos cargados. Selecciona una parcela.';
                console.log("Carga automática de datos finalizada. Selecciona una parcela para habilitar la generación de pasadas.");

            })
            .catch(error => {
                console.error("Error durante la carga automática de datos GeoJSON o GeoTIFF:", error);
                loadingStatusDiv.textContent = `Error al cargar datos: ${error.message}`;
                alert(`Ocurrió un error al cargar uno o más archivos geoespaciales. Revisa las URLs y la consola para más detalles. Error: ${error.message}`);
            });
        });


        // --- LÓGICA PARA GENERAR PASADAS OPTIMIZADAS USANDO TURF.JS ---

        generarPasadasBtn.addEventListener('click', function() {

            // --- VERIFICACIÓN DE TURF ---
            console.log("Estado de 'turf' al hacer clic en Generar Pasadas:", typeof turf);
            if (typeof turf === 'undefined') {
                console.error("Error: La biblioteca Turf.js no se cargó correctamente.");
                alert("Error: La biblioteca Turf.js no está disponible. No se pueden generar pasadas. Revisa la consola.");
                return;
            }
            // --- FIN VERIFICACIÓN ---

            // --- VERIFICACIÓN DE GeoRaster Y CURVAS DE NIVEL ---
             console.log("Estado de elevationGeoRaster:", elevationGeoRaster ? "Cargado" : "No cargado");
             console.log("Estado de contourLinesGeoJSON:", contourLinesGeoJSON ? "Cargado" : "No cargado");

             if (!elevationGeoRaster || !contourLinesGeoJSON) {
                 alert("Error: Los datos de elevación (MDT GeoTIFF) o Curvas de Nivel no se han cargado correctamente. No se pueden generar pasadas sensibles a la elevación.");
                  console.error("Datos de elevación o curvas de nivel no disponibles.");
                 return;
             }
             // --- FIN VERIFICACIÓN ---


            console.log("--- Inicio Generación de Pasadas ---");
            console.log("Estado de window.exclusionFeatures al inicio del click:", window.exclusionFeatures ? window.exclusionFeatures.length : 'undefined/null', window.exclusionFeatures); // Log 3


            // Asegurarse de que haya una parcela seleccionada y sea un polígono válido
            if (!selectedLayer || !selectedLayer.feature || !selectedLayer.feature.geometry || (selectedLayer.feature.geometry.type !== 'Polygon' && selectedLayer.feature.geometry.type !== 'MultiPolygon')) {
                alert("Por favor, selecciona una parcela válida haciendo clic en ella primero.");
                console.warn("selectedLayer no es una parcela válida o no tiene geometría poligonal:", selectedLayer);
                return;
            }

            const selectedParcelGeoJSON = selectedLayer.toGeoJSON();
            let parcelGeometry = selectedParcelGeoJSON.geometry; // Geometría de la parcela seleccionada
            const parcelFeature = turf.feature(parcelGeometry); // La parcela como feature para intersecciones

            generatedPassesLayer.clearLayers(); // Limpiar pasadas anteriores
            console.log("Limpiando pasadas generadas anteriormente.");

            // --- Obtener el ancho de trabajo del input ---
            const workingWidth = parseFloat(workingWidthInput.value);
            if (isNaN(workingWidth) || workingWidth <= 0) {
                 alert("Por favor, introduce un valor válido y positivo para el ancho de trabajo.");
                 console.error("Valor inválido para ancho de trabajo:", workingWidthInput.value);
                 return;
            }
            // --- Fin Obtener ancho de trabajo ---

            const units = 'meters'; // Unidades para Turf.js


            try {
                // Eliminamos la línea: let exclusionFeatures = []; // Ya no es necesaria, usamos window.exclusionFeatures directamente

                let intersectingExclusionFeatures = []; // Array para almacenar las FEATURES de exclusión que INTERSECTAN
                // Usamos la variable global exclusionFeatures poblada al inicio
                const globalExclusionFeatures = window.exclusionFeatures || []; // Acceder a la variable global


                // --- Lógica para obtener features de exclusión que intersectan con la parcela seleccionada ---
                 if (globalExclusionFeatures.length > 0) {
                     console.log(`Total features de exclusión cargadas globalmente: ${globalExclusionFeatures.length}`);
                     console.log(`Filtrando features de exclusión para encontrar las que intersectan con la parcela seleccionada.`);
                      globalExclusionFeatures.forEach((exclusionFeature, index) => {
                          // exclusionFeature ya debe ser un Feature con Polígono/MultiPolígono (buffers si eran LineString)
                         if (exclusionFeature.geometry && (exclusionFeature.geometry.type === 'Polygon' || exclusionFeature.geometry.type === 'MultiPolygon')) {
                              try {
                                   // Verificar si la feature de exclusión intersecta con la parcela seleccionada
                                  if (turf.booleanIntersects(parcelFeature, exclusionFeature)) {
                                     // Si intersecta, añadir la FEATURE COMPLETA a la lista de exclusiones que intersectan
                                     intersectingExclusionFeatures.push(exclusionFeature); // Añadir la FEATURE
                                  }
                              } catch (e) {
                                  console.warn(`Error al verificar intersección para feature de exclusión #${index}. Se omitirá.`, exclusionFeature, e);
                              }
                         } else {
                              console.warn(`Geometría de feature de exclusión #${index} (${exclusionFeature.geometry ? exclusionFeature.geometry.type : 'null/undefined'}) no es Polígono/MultiPolígono válido para intersección. Se omitirá.`, exclusionFeature);
                         }
                      });
                 } else {
                     console.log("No se cargaron features de exclusión globalmente (exclusionFeatures está vacío).");
                 }
                console.log(`Features de exclusión que intersectan con la parcela: ${intersectingExclusionFeatures.length}`);


                // --- Simplificar ligeramente las features de exclusión que intersectan ---
                 let simplifiedExclusionFeatures = [];
                 if (intersectingExclusionFeatures.length > 0) {
                     const tinySimplificationTolerance = 0.000001;
                     console.log(`Aplicando mínima simplificación (${tinySimplificationTolerance} grados) a ${intersectingExclusionFeatures.length} features de exclusión que intersectan.`);
                     simplifiedExclusionFeatures = intersectingExclusionFeatures.map(feature => {
                           try {
                                if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                                      const simplified = turf.simplify(feature, { tolerance: tinySimplificationTolerance, highQuality: true });

                                      if (simplified && simplified.geometry && (simplified.geometry.type === 'Polygon' || simplified.geometry.type === 'MultiPolygon' || simplified.geometry.type === 'GeometryCollection')) {
                                           if (simplified.geometry.type === 'GeometryCollection') {
                                                let validGeomsInGC = [];
                                                turf.geomEach(simplified.geometry, function(geom) {
                                                    if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
                                                        validGeomsInGC.push(turf.feature(geom));
                                                    }
                                                });
                                                if (validGeomsInGC.length > 0) {
                                                     let consolidatedFeature = null;
                                                      if (validGeomsInGC.length === 1) {
                                                           consolidatedFeature = validGeomsInGC[0];
                                                          //  console.log("Simplificación mínima: GC consolidado es 1 polígono. Usando directamente."); // Corregido console.log
                                                      } else {
                                                           try {
                                                                consolidatedFeature = turf.union(...validGeomsInGC);
                                                              //  console.log("Simplificación mínima: GC consolidado de múltiples polígonos. Resultado tipo unión:", consolidatedFeature ? consolidatedFeature.geometry.type : 'null/undefined'); // Corregido console.log
                                                           } catch(e) {
                                                               console.error("Error al unir partes válidas de GC:", e);
                                                              //  console.warn("Simplificación mínima: Falló unión de partes válidas en GC. Devolviendo null."); // Corregido console.log
                                                               consolidatedFeature = null;
                                                           }
                                                      }

                                                    if(consolidatedFeature && consolidatedFeature.geometry && (consolidatedFeature.geometry.type === 'Polygon' || consolidatedFeature.geometry.type === 'MultiPolygon')) {
                                                         if (turf.area(consolidatedFeature) > 0) {
                                                            return consolidatedFeature;
                                                        } else {
                                                             console.warn("Simplificación mínima: GC consolidado tiene área 0.", consolidatedFeature);
                                                            return null;
                                                        }
                                                    } else {
                                                        console.warn("Simplificación mínima: La unión de partes válidas en GC no resultó en Polygon/MultiPolygon.", consolidatedFeature);
                                                        return null;
                                                    }
                                                } else {
                                                    console.warn("Simplificación mínima: GeometryCollection resultante no contiene polígonos válidos.", simplified);
                                                    return null;
                                                }
                                           } else {
                                               if (turf.area(simplified) > 0) {
                                                   return simplified;
                                                } else {
                                                    console.warn("Simplificación mínima: Resultado directo (Polygon/MultiPolygon) tiene área 0.", simplified);
                                                    return null;
                                                }
                                           }
                                      } else {
                                            console.warn("Simplificación mínima: turf.simplify devolvió un resultado no válido o nulo.", simplified);
                                            return null;
                                      }
                                  } else {
                                       console.warn("Simplificación mínima: La feature de exclusión no es Polygon/MultiPolygon. Devolviendo null.");
                                       return null;
                                  }

                             } catch (e) {
                                  console.error("Error durante la simplificación mínima de una feature de exclusión:", feature, e);
                                  console.warn("Simplificación mínima fallida para feature de exclusión. Se omitirá.");
                                  return null;
                             }
                         }).filter(feature => feature !== null);

                         console.log(`Quedan ${simplifiedExclusionFeatures.length} features de exclusión VÁLIDAS después de la mínima simplificación.`);

                 } else {
                      console.log("No hay features de exclusión que intersecten para simplificar.");
                 }


                // --- Calcular el área limpia (Parcela - Unión/Feature única de ExclusionFeatures simplificadas) ---
                let geometryForCalculations = parcelGeometry;
                let unionOfExclusions = null;
                let unionGeometryForDifference = null;


                if (simplifiedExclusionFeatures.length === 0) {
                     console.log("No hay features de exclusión simplificadas válidas. No se excluirán zonas a evitar.");
                 } else if (simplifiedExclusionFeatures.length === 1) {
                     console.log("Solo 1 feature de exclusión simplificada. Usando esta directamente para la diferencia.");
                     unionOfExclusions = simplifiedExclusionFeatures[0];
                     if (unionOfExclusions && unionOfExclusions.geometry && (unionOfExclusions.geometry.type === 'Polygon' || unionOfExclusions.geometry.type === 'MultiPolygon')) {
                          unionGeometryForDifference = unionOfExclusions.geometry;
                          console.log("Feature única de exclusión es Polígono/MultiPolígono válido para la diferencia.");
                     } else {
                           console.warn("La única feature de exclusión simplificada no es Polígono/MultiPolígono válido. No se excluirán zonas a evitar.");
                           geometryForCalculations = parcelGeometry;
                            alert("Advertencia: El área a evitar no es una geometría válida. Generando pasadas sobre la parcela completa.");
                     }

                 } else { // simplifiedExclusionFeatures.length > 1
                      console.log(`Más de 1 feature de exclusión simplificada (${simplifiedExclusionFeatures.length}). Calculando unión...`);
                     try {
                        //  console.log("Input (STRINGIFIED) para turf.union:", JSON.stringify(simplifiedExclusionFeatures)); // Corregido console.log
                         unionOfExclusions = turf.union(...simplifiedExclusionFeatures);
                        //  console.log("Resultado (STRINGIFIED) de turf.union:", JSON.stringify(unionOfExclusions)); // Corregido console.log

                         if (unionOfExclusions && unionOfExclusions.geometry) {
                             if (unionOfExclusions.geometry.type === 'Polygon' || unionOfExclusions.geometry.type === 'MultiPolygon' || unionOfExclusions.geometry.type === 'GeometryCollection') {

                                 let unionGeometryForDifference = null;

                                  if (unionOfExclusions.geometry.type === 'GeometryCollection') {
                                      console.warn("La unión de áreas a evitar resultó en un GeometryCollection. Intentando extraer polígonos válidos para la diferencia.");
                                       let validGeometries = [];
                                       turf.geomEach(unionOfExclusions.geometry, function(geom) {
                                           if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
                                               validGeometries.push(turf.feature(geom));
                                           }
                                       });

                                       if (validGeometries.length > 0) {
                                            let consolidatedUnion = null;
                                             if (validGeometries.length === 1) {
                                                 consolidatedUnion = validGeometries[0];
                                                 console.log("GeometryCollection consolidado es 1 polígono. Usando directamente.");
                                             } else {
                                                 try {
                                                      consolidatedUnion = turf.union(...validGeometries);
                                                    //  console.log("GeometryCollection consolidado de múltiples polígonos. Resultado tipo unión:", consolidatedUnion ? consolidatedUnion.geometry.type : 'null/undefined'); // Corregido console.log
                                                 } catch(e) {
                                                      console.error("Error al intentar unir polígonos válidos dentro de GeometryCollection:", e);
                                                       console.warn("Error procesando GeometryCollection de unión. Devolviendo null.");
                                                       consolidatedUnion = null;
                                                  }
                                             }

                                             if (consolidatedUnion && consolidatedUnion.geometry && (consolidatedUnion.geometry.type === 'Polygon' || consolidatedUnion.geometry.type === 'MultiPolygon')) {
                                                 unionGeometryForDifference = consolidatedUnion.geometry;
                                                  console.log("Polígonos válidos de GeometryCollection unidos con éxito para la diferencia. Tipo resultado unión:", unionGeometryForDifference.type);
                                             } else {
                                                 console.warn("La re-unión de polígonos válidos dentro del GeometryCollection no resultó en un polígono válido. Usando solo el polígono más grande.", consolidatedUnion);
                                                 unionGeometryForDifference = null;
                                             }
                                        } else {
                                             console.warn("GeometryCollection de unión no contiene polígonos válidos para usar en la diferencia. No se excluirán zonas a evitar.", unionOfExclusions);
                                             unionGeometryForDifference = null;
                                        }

                                  } else {
                                       unionGeometryForDifference = unionOfExclusions.geometry;
                                        console.log("Unión de exclusiones es un Polígono/MultiPolígono válido. Usando este para la diferencia.");
                                  }

                                 if (!unionGeometryForDifference) {
                                     console.warn("No se pudo obtener una geometría de unión válida para la diferencia después de procesar el resultado de turf.union. Usando geometría original de la parcela.");
                                     geometryForCalculations = parcelGeometry;
                                      alert("Advertencia: No se pudo procesar la unión de áreas a evitar. Generando pasadas sobre la parcela completa.");
                                      // return; // No se debería salir aquí, se debe seguir con la geometría original
                                 }


                             } else {
                                  console.warn(`El resultado de turf.union tiene geometría (${unionOfExclusions.geometry.type}), pero no es un tipo válido (Polygon, MultiPolygon, GeometryCollection) para la diferencia. No se excluirán zonas a evitar.`, unionOfExclusions);
                                  geometryForCalculations = parcelGeometry;
                                   alert("Advertencia: La unión de áreas a evitar resultó en una geometría de tipo inesperado. Generando pasadas sobre la parcela completa.");
                                  // return; // No se debería salir aquí
                             }

                        } else {
                             console.warn("El resultado de turf.union fue nulo o no tiene geometría. No se excluirán zonas a evitar.", unionOfExclusions);
                             geometryForCalculations = parcelGeometry;
                             alert("Advertencia: La unión de áreas a evitar devolvió un resultado vacío. Generando pasadas sobre la parcela completa.");
                            //  return; // No se debería salir aquí
                        }

                     } catch (e) {
                         console.error("Error general en turf.union o procesamiento subsiguiente:", e);
                         console.warn("Ocurrió un error al calcular la unión de áreas a evitar. Usando geometría original de la parcela.");
                         geometryForCalculations = parcelGeometry;
                         alert("Advertencia: Ocurrió un error al calcular la unión de áreas a evitar. Generando pasadas sobre la parcela completa. Revisa la consola.");
                        //  return; // No se debería salir aquí
                     }
                 }

                 if (unionGeometryForDifference && geometryForCalculations === parcelGeometry) {
                      // Si unionGeometryForDifference es válido, pero no se asignó a geometryForCalculations (porque no se entró en el bloque else if o else de simplifiedExclusionFeatures.length),
                     // significa que hay features de exclusión pero la lógica de unión/diferencia pudo haber tenido problemas.
                     // Volvemos a intentar la diferencia aquí para asegurarnos de que se usa si es posible.
                     console.log("Reintentando cálculo de área limpia con unionGeometryForDifference...");
                     try {
                           const unionFeatureForDifference = turf.feature(unionGeometryForDifference);
                           const parcelFeature = turf.feature(parcelGeometry);
                            const cleanedArea = turf.difference(parcelFeature, unionFeatureForDifference);

                            console.log("Resultado de turf.difference (Área limpia) en reintento:", JSON.stringify(cleanedArea));

                            if (cleanedArea && cleanedArea.geometry) {
                                 const areaCalculated = turf.area(cleanedArea);
                                //  console.log("Tipo de geometría del área limpia en reintento:", cleanedArea.geometry.type, "Área:", areaCalculated, units); // Corregido console.log

                                 if ((cleanedArea.geometry.type === 'Polygon' || cleanedArea.geometry.type === 'MultiPolygon' || cleanedArea.geometry.type === 'GeometryCollection') && areaCalculated > 0) {
                                      if (cleanedArea.geometry.type === 'GeometryCollection') {
                                           console.warn("Área limpia resultante en reintento es GeometryCollection. Intentando consolidar para el barrido.");
                                            let validGeomsInCleanedArea = [];
                                            turf.geomEach(cleanedArea.geometry, function(geom) {
                                                if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
                                                    validGeomsInCleanedArea.push(turf.feature(geom));
                                                }
                                            });

                                            if (validGeomsInCleanedArea.length > 0) {
                                                 let consolidatedCleanArea = null;
                                                  if (validGeomsInCleanedArea.length === 1) {
                                                       consolidatedCleanArea = validGeomsInCleanedArea[0];
                                                      //  console.log("GeometryCollection de área limpia en reintento consolidado es 1 polígono. Usando directamente."); // Corregido console.log
                                                  } else {
                                                       try {
                                                            consolidatedCleanArea = turf.union(...validGeomsInCleanedArea);
                                                          //  console.log("GeometryCollection de área limpia en reintento consolidado de múltiples polígonos. Resultado tipo unión:", consolidatedCleanArea ? consolidatedCleanArea.geometry.type : 'null/undefined'); // Corregido console.log
                                                       } catch(e) {
                                                            console.error("Error al consolidar GeometryCollection resultante de difference en reintento:", e);
                                                             console.warn("Error procesando el área limpia compleja en reintento. Devolviendo null.");
                                                             consolidatedCleanArea = null;
                                                       }
                                                  }

                                                  if (consolidatedCleanArea && consolidatedCleanArea.geometry && (consolidatedCleanArea.geometry.type === 'Polygon' || consolidatedCleanArea.geometry.type === 'MultiPolygon')) {
                                                      geometryForCalculations = consolidatedCleanArea.geometry;
                                                       console.log("Área limpia (parcela - exclusiones) consolidada en reintento a:", geometryForCalculations.type, ". Usando para cálculos.");
                                                  } else {
                                                      console.warn("La consolidación del GeometryCollection resultante del difference en reintento no produjo Polygon/MultiPolygon válido. No se excluirán zonas a evitar.", consolidatedCleanArea);
                                                      // geometryForCalculations ya es parcelGeometry, no es necesario reasignar
                                                      alert("Advertencia: No se pudo procesar el área limpia compleja en reintento. Generando pasadas sobre la parcela completa.");
                                                  }

                                             } else {
                                                  console.warn("El GeometryCollection resultante de difference en reintento no contiene polígonos válidos para el barrido. No se excluirán zonas a evitar.", cleanedArea);
                                                 // geometryForCalculations ya es parcelGeometry
                                                  alert("Advertencia: El área limpia resultante en reintento no contiene polígonos válidos. Generando pasadas sobre la parcela completa.");
                                             }

                                      } else {
                                         geometryForCalculations = cleanedArea.geometry;
                                         console.log(`Área limpia (parcela - exclusiones) calculada con éxito en reintento. Tipo: ${geometryForCalculations.type}, Área > 0. Usando para cálculos.`);
                                      }

                                 } else {
                                      console.warn("El área resultante de turf.difference en reintento no es un polígono/multipolígono/GC válido o tiene área 0. No se excluirán zonas a evitar.", cleanedArea);
                                      // geometryForCalculations ya es parcelGeometry
                                       if (areaCalculated === 0) {
                                            console.log("Advertencia: La parcela seleccionada parece estar completamente cubierta por áreas a evitar (área limpia = 0).");
                                            alert("Advertencia: La parcela seleccionada parece estar completamente cubierta por áreas a evitar. No se pueden generar pasadas útiles.");
                                            console.log("Revertiendo a geometría original de la parcela según la lógica actual.");
                                            // geometryForCalculations ya es parcelGeometry
                                       } else {
                                             console.warn("Advertencia: El área limpia resultante en reintento no es una geometría válida para generar pasadas.");
                                             // geometryForCalculations ya es parcelGeometry
                                              alert("Advertencia: El área limpia resultante en reintento no es una geometría válida para generar pasadas. Generando pasadas sobre la parcela completa.");
                                       }
                                 }

                            } else {
                                 console.warn("El resultado de turf.difference en reintento no tiene una geometría válida. No se excluirán zonas a evitar.", cleanedArea);
                                // geometryForCalculations ya es parcelGeometry
                                 alert("Advertencia: El resultado del cálculo de áreas a evitar en reintento no es válido. Generando pasadas sobre la parcela completa.");
                            }
                       } catch (e) {
                            console.error("Error durante el cálculo de diferencia de geometrías en reintento:", e);
                            console.warn("Ocurrió un error al excluir zonas a evitar en reintento. Usando geometría original de la parcela.");
                            // geometryForCalculations ya es parcelGeometry
                            alert("Advertencia: Ocurrió un error al excluir zonas a evitar en reintento. Generando pasadas sobre la parcela completa. Revisa la consola.");
                       }
                 }


                // --- SIMPLIFICACIÓN (Aplicar a la geometría que resulte de la exclusión o a la original si falló la exclusión) ---
                let finalGeometryToSweep = geometryForCalculations;
                console.log("Intentando simplificar la geometría final para el barrido...");
                console.log("Geometría ANTES de simplificar:", JSON.stringify(geometryForCalculations));

                if (!geometryForCalculations || !geometryForCalculations.type) {
                     console.error("La geometría para simplificar es nula, undefined o de tipo incorrecto. Deteniendo proceso.");
                      alert("Error: La geometría resultante para generar pasadas no es válida.");
                     return;
                }

                try {
                    const simplificationTolerance = 0.00005;

                    const featureToSimplify = turf.feature(geometryForCalculations);

                     if (featureToSimplify) {
                          const simplifiedFeature = turf.simplify(featureToSimplify, {
                               tolerance: simplificationTolerance,
                               highQuality: true
                          });

                        //    console.log("Resultado de turf.simplify:", JSON.stringify(simplifiedFeature)); // Corregido console.log

                           if (simplifiedFeature && simplifiedFeature.geometry && (simplifiedFeature.geometry.type === 'Polygon' || simplifiedFeature.geometry.type === 'MultiPolygon')) {
                               finalGeometryToSweep = simplifiedFeature.geometry;
                               console.log("Geometría final simplificada con éxito. Tipo:", finalGeometryToSweep.type);
                           } else {
                                console.warn("El resultado de turf.simplify no es un polígono o multipolígono válido. Usando geometría sin simplificar.", simplifiedFeature);
                                finalGeometryToSweep = geometryForCalculations;
                                alert("Advertencia: No se pudo simplificar la geometría resultante del área limpia. Generando pasadas con geometría detallada (puede ser más lento).");
                           }
                     } else {
                         console.warn("No se pudo crear una feature para simplificar. Usando geometría sin simplificar.");
                         finalGeometryToSweep = geometryForCalculations;
                          alert("Advertencia: No se pudo crear Feature para simplificar. Generando pasadas con geometría detallada.");
                     }


                } catch (e) {
                    console.error("Error durante la simplificación de geometría:", e);
                    console.warn("No se pudo simplificar la geometría final. Usando geometría sin simplificar.");
                    finalGeometryToSweep = geometryForCalculations;
                    alert("Advertencia: Ocurrió un error al simplificar la geometría. Generando pasadas con geometría detallada (puede ser más lento). Revisa la consola.");
                }


                // Asegurarse de que la geometría final para el barrido sea un polígono simple o usar el polígono más grande si es MultiPolygon
                let geometryForSweepAndPiP = null;
                if (finalGeometryToSweep && (finalGeometryToSweep.type === 'Polygon' || finalGeometryToSweep.type === 'MultiPolygon')) {
                     geometryForSweepAndPiP = finalGeometryToSweep;

                     if (geometryForSweepAndPiP.type === 'MultiPolygon') {
                         console.log("La geometría final para el barrido es un MultiPolygon. Intentando usar el polígono más grande o su unión.");
                         let largestPoly = null;
                         let maxPolyArea = 0;
                         let validPolygonsInMulti = [];

                         if (geometryForSweepAndPiP.coordinates && Array.isArray(geometryForSweepAndPiP.coordinates)) {
                             geometryForSweepAndPiP.coordinates.forEach(polyCoords => {
                                 try {
                                     const currentPoly = turf.polygon(polyCoords);
                                      let area = turf.area(currentPoly);
                                       validPolygonsInMulti.push(turf.feature(currentPoly.geometry));
                                     if (area > maxPolyArea) {
                                         maxPolyArea = area;
                                         largestPoly = currentPoly.geometry;
                                     }
                                 } catch (e) {
                                    console.warn("Error procesando un polígono dentro del MultiPolygon final:", e);
                                 }
                             });
                         } else {
                              console.error("Las coordenadas del MultiPolygon final no son válidas.");
                         }


                         if (largestPoly) {
                             if (validPolygonsInMulti.length > 0) {
                                 if (validPolygonsInMulti.length > 1) {
                                     console.log(`MultiPolygon contiene ${validPolygonsInMulti.length} polígonos válidos. Intentando unirlos para el barrido.`);
                                     try {
                                          const unionOfMultiParts = turf.union(...validPolygonsInMulti);
                                           if (unionOfMultiParts && unionOfMultiParts.geometry && (unionOfMultiParts.geometry.type === 'Polygon' || unionOfMultiParts.geometry.type === 'MultiPolygon')) {
                                               geometryForSweepAndPiP = unionOfMultiParts.geometry;
                                                console.log("Polígonos del MultiPolygon unidos con éxito para el barrido. Resultado:", geometryForSweepAndPiP.type);
                                           } else {
                                                console.warn("La unión de las partes del MultiPolygon no resultó en un polígono/multipolígono válido. Usando solo el polígono más grande.", unionOfMultiParts);
                                                geometryForSweepAndPiP = largestPoly;
                                           }
                                     } catch (e) {
                                          console.error("Error al intentar unir las partes del MultiPolygon:", e);
                                           console.warn("Error al unir las partes del MultiPolygon. Usando solo el polígono más grande.");
                                           geometryForSweepAndPiP = largestPoly;
                                     }
                                 } else {
                                     geometryForSweepAndPiP = largestPoly;
                                     console.log("MultiPolygon con 1 polígono válido encontrado. Usando este para el barrido.");
                                 }
                             } else {
                                   console.error("MultiPolygon resultante no contiene polígonos válidos después de procesar las partes.");
                                   alert("Error procesando la geometría para el barrido. No se encontraron polígonos válidos dentro del MultiPolygon.");
                                   return;
                             }

                         } else {
                              console.error("MultiPolygon resultante no contiene polígonos válidos para el barrido y no se pudo encontrar el polígono más grande.");
                              alert("Error procesando la geometría para el barrido. No se encontraron polígonos válidos dentro del MultiPolygon.");
                              return;
                         }
                     } else {
                         console.log("La geometría final para el barrido es un Polígono simple válido.");
                     }
                } else {
                     console.error("La geometría final para el barrido es nula, undefined o de tipo incorrecto:", finalGeometryToSweep);
                     alert("Error: La geometría resultante (después de excluir zonas a evitar/simplificar) no es un polígono válido para generar pasadas.");
                     return;
                }


                // console.log("Geometría FINAL para barrido y PiP:", JSON.stringify(geometryForSweepAndPiP)); // Corregido console.log
                try {
                     if (turf.area(geometryForSweepAndPiP) === 0) {
                          console.error("La geometría final para el barrido tiene área 0.");
                           alert("La geometría resultante del área limpia tiene área cero. No se pueden generar pasadas.");
                          return;
                     }
                } catch(e) {
                     console.error("Error calculando área de geometría final para barrido:", e);
                      alert("Error verificando la geometría final para el barrido.");
                     return;
                }


                let centroid = null;
                try {
                     centroid = turf.centroid(geometryForSweepAndPiP);
                    //  console.log("Centroide del área limpia para rotación:", JSON.stringify(centroid)); // Corregido console.log
                } catch(e) {
                     console.error("Error calculando centroide de la geometría limpia:", e);
                      alert("Error calculando el centroide para la rotación.");
                     return;
                }


                let rotationAngle = 0;
                let sweepDirectionInRotatedSpace = 0;
                let heuristicDirectionDescription = "";

                let longestSegmentAngle = 0;
                let foundLongestSegment = false;

                 if (parcelGeometry.type === 'Polygon' && parcelGeometry.coordinates && parcelGeometry.coordinates.length > 0) {
                    const exteriorCoords = parcelGeometry.coordinates[0];
                    if (exteriorCoords && Array.isArray(exteriorCoords) && exteriorCoords.length > 2) {
                         let maxLength = 0;
                         let p1Longest = null;
                         let p2Longest = null;

                         for (let i = 0; i < exteriorCoords.length - 1; i++) {
                             const p1 = turf.point(exteriorCoords[i]);
                             const p2 = turf.point(exteriorCoords[i+1]);
                             try {
                                const length = turf.distance(p1, p2, {units: units});
                                if (length > maxLength) {
                                    maxLength = length;
                                    p1Longest = p1;
                                    p2Longest = p2;
                                }
                             } catch(e) {
                                console.warn("Error calculando distancia para segmento en heurística:", p1, p2, e);
                             }

                         }

                         if (p1Longest && p2Longest) {
                             try {
                                 longestSegmentAngle = turf.bearing(p1Longest, p2Longest);
                                 foundLongestSegment = true;
                                 console.log(`Lado más largo de la parcela original encontrado. Longitud: ${maxLength.toFixed(2)}m, Ángulo (bearing): ${longestSegmentAngle.toFixed(2)}°`);
                             } catch(e) {
                                  console.warn("Error calculando bearing para lado más largo:", p1Longest, p2Longest, e);
                                  foundLongestSegment = false;
                             }
                         } else {
                              console.warn("No se encontraron suficientes puntos en el contorno exterior de la parcela original para calcular el lado más largo.");
                         }
                    } else {
                        console.warn("No se pudieron obtener coordenadas exteriores de la parcela original o no hay suficientes puntos.");
                    }
                 } else {
                      console.warn("La geometría original de la parcela no es un polígono simple para encontrar el lado más largo.");
                 }

                const useLongestSideThreshold = 0.7;
                let originalParcelBbox = null;
                let originalBboxWidthMeters = 0;
                let originalBboxHeightMeters = 0;
                let originalParcelArea = 0;
                let originalBboxArea = 0;
                let originalRectangularity = 0;

                 try {
                      originalParcelBbox = turf.bbox(parcelGeometry);
                      originalBboxWidthMeters = turf.distance(turf.point([originalParcelBbox[0], originalParcelBbox[1]]), turf.point([originalParcelBbox[2], originalBbox[1]]), {units: units});
                      originalBboxHeightMeters = turf.distance(turf.point([originalParcelBbox[0], originalParcelBbox[1]]), turf.point([originalParcelBbox[0], originalBbox[3]]), {units: units});
                      originalParcelArea = turf.area(turf.feature(parcelGeometry));
                      originalBboxArea = originalBboxWidthMeters * originalBboxHeightMeters;
                      originalRectangularity = originalBboxArea === 0 ? 0 : originalParcelArea / originalBboxArea;

                      console.log(`Dimensiones Bbox original: Ancho ${originalBboxWidthMeters.toFixed(2)}m, Alto ${originalBboxHeightMeters.toFixed(2)}m. Rectangularidad: ${originalRectangularity.toFixed(2)}`);

                 } catch(e) {
                      console.error("Error calculando Bbox o Rectangularidad de la parcela original:", e);
                 }



                if (foundLongestSegment && originalRectangularity > useLongestSideThreshold) {
                    rotationAngle = -longestSegmentAngle;
                    sweepDirectionInRotatedSpace = 0;
                    heuristicDirectionDescription = `Lado más largo de la parcela original (ángulo original: ${longestSegmentAngle.toFixed(2)}°, rotación aplicada: ${rotationAngle.toFixed(2)}°)`;
                     console.log("Heurística: Usando el lado más largo como dirección principal.");

                } else {
                    console.log("Heurística: Parcela irregular o lado largo no determinante. Usando la orientación de la Bbox original.");
                    if (originalBboxWidthMeters >= originalBboxHeightMeters) {
                        rotationAngle = 0;
                        sweepDirectionInRotatedSpace = 0;
                        heuristicDirectionDescription = "Bounding Box original más ancho que alto (o igual)";
                    } else {
                        rotationAngle = 90;
                        sweepDirectionInRotatedSpace = 0;
                        heuristicDirectionDescription = "Bounding Box original más alto que ancho (rotado 90° para pasadas horizontales)";
                         console.log("Bbox más alta que ancha, rotando 90 grados para pasadas horizontales en el espacio rotado.");
                    }
                }


                console.log(`Dirección heurística elegida: ${heuristicDirectionDescription}. Rotando el área para el barrido por ${rotationAngle.toFixed(2)} grados.`);
                console.log(`El barrido en el espacio rotado será ${sweepDirectionInRotatedSpace === 0 ? 'S-N (para pasadas horizontales)' : 'O-E (para pasadas verticales)'}.`); // Corregido descripción de dirección

                 if (!centroid || !centroid.geometry || !centroid.geometry.coordinates) {
                      console.error("Centroide no válido para la rotación. Deteniendo proceso.");
                       alert("Error: No se pudo determinar el centroide para la rotación.");
                      return;
                 }

                 let rotatedGeometryForSweepAndPiP = null;
                 try {
                      rotatedGeometryForSweepAndPiP = turf.transformRotate(geometryForCalculations, rotationAngle, {pivot: centroid});
                    //   console.log("Geometría LIMPIA, SIMPLIFICADA y ROTADA para barrido/PiP:", JSON.stringify(rotatedGeometryForSweepAndPiP)); // Corregido console.log
                 } catch(e) {
                      console.error("Error al rotar la geometría final para el barrido:", e);
                       alert("Error al rotar la geometría para generar pasadas.");
                      return;
                 }


                 let rotatedGeometryBbox = null;
                 let rotatedBboxWest = 0, rotatedBboxSouth = 0, rotatedBboxEast = 0, rotatedBboxNorth = 0;

                 try {
                      rotatedGeometryBbox = turf.bbox(rotatedGeometryForSweepAndPiP);
                      rotatedBboxWest = rotatedGeometryBbox[0];
                      rotatedBboxSouth = rotatedGeometryBbox[1];
                      rotatedBboxEast = rotatedGeometryBbox[2];
                      rotatedBboxNorth = rotatedGeometryBbox[3];
                 } catch(e) {
                      console.error("Error calculando Bbox de la geometría rotada:", e);
                       alert("Error calculando límites de la geometría rotada para generar pasadas.");
                      return;
                 }


                let rotatedStartSweepCoordValue;
                let rotatedEndSweepCoordValue;
                let rotatedSweepLineStartCoord;
                let rotatedSweepLineEndCoord;
                let rotatedSweepLineDirection;


                if (sweepDirectionInRotatedSpace === 0) {
                    rotatedStartSweepCoordValue = rotatedBboxSouth;
                    rotatedEndSweepCoordValue = rotatedBboxNorth;
                    rotatedSweepLineStartCoord = rotatedBboxWest;
                    rotatedSweepLineEndCoord = rotatedBboxEast;
                    rotatedSweepLineDirection = 90; // Dirección de la línea de barrido en el espacio rotado (horizontal)

                     console.log("Configurando barrido S->N en espacio rotado para generar pasadas horizontales (O->E).");
                } else { // sweepDirectionInRotatedSpace === 90 (para pasadas verticales)
                    rotatedStartSweepCoordValue = rotatedBboxWest;
                    rotatedEndSweepCoordValue = rotatedBboxEast;
                     rotatedSweepLineStartCoord = rotatedBboxSouth;
                     rotatedSweepLineEndCoord = rotatedBboxNorth;
                     rotatedSweepLineDirection = 0; // Dirección de la línea de barrido en el espacio rotado (vertical)

                     console.log("Configurando barrido O->E en espacio rotado para generar pasadas verticales (S->N).");
                }

                let totalSweepExtentMeters = 0;
                let passLengthMeters = 0;
                 try {
                     totalSweepExtentMeters = turf.distance(
                        turf.point(sweepDirectionInRotatedSpace === 0 ? [rotatedBboxWest, rotatedBboxSouth] : [rotatedBboxWest, rotatedBboxSouth]),
                        turf.point(sweepDirectionInRotatedSpace === 0 ? [rotatedBboxWest, rotatedBboxNorth] : [rotatedBboxEast, rotatedBboxSouth]),
                        {units: units}
                     );
                     console.log(`Extensión total del barrido en espacio rotado (a lo largo de la Bbox perpendicular a las pasadas): ${totalSweepExtentMeters.toFixed(2)} ${units}`);

                     passLengthMeters = turf.distance(
                          turf.point(sweepDirectionInRotatedSpace === 0 ? [rotatedBboxWest, rotatedBboxSouth] : [rotatedBboxWest, rotatedBboxSouth]),
                          turf.point(sweepDirectionInRotatedSpace === 0 ? [rotatedBboxEast, rotatedBboxSouth] : [rotatedBboxWest, rotatedBboxNorth]),
                          {units: units}
                      );
                      console.log(`Longitud máxima esperada de las pasadas en espacio rotado: ${passLengthMeters.toFixed(2)} ${units}`);

                 } catch(e) {
                     console.error("Error calculando distancias de la bbox rotada:", e);
                      alert("Error calculando límites de la geometría rotada para generar pasadas.");
                     return;
                 }


               let rotatedCurrentOffset = workingWidth / 2;
               const samplingDistance = 1;
               const geometryForPiPCheck = rotatedGeometryForSweepAndPiP;

               console.log(`Generando pasadas de ${workingWidth}m en espacio rotado (muestreo de ${samplingDistance}m).`);

                let generatedRotatedPasses = [];


               if (workingWidth <= 0 || totalSweepExtentMeters <= 0) {
                   console.warn("Ancho de trabajo o extensión del barrido <= 0. No se generarán pasadas.");
                   alert("Ancho de trabajo inválido o área a barrer muy pequeña.");
                   return;
               } else {
                    const sweepLimit = totalSweepExtentMeters - (workingWidth / 2) + (workingWidth * 0.1); // Pequeño margen al final

                     while (rotatedCurrentOffset < totalSweepExtentMeters + (workingWidth / 2)) { // Asegurarse de cubrir toda la extensión

                       let pointOnSweepAxis = null;
                        try {
                            // Calcular el punto central de la línea de barrido actual en el espacio rotado
                            // Partimos de la esquina suroeste de la bbox rotada y nos movemos la distancia del offset en la dirección de barrido
                            pointOnSweepAxis = turf.destination(
                                turf.point(sweepDirectionInRotatedSpace === 0 ? [rotatedBboxWest, rotatedBboxSouth] : [rotatedBboxWest, rotatedBboxSouth]),
                                rotatedCurrentOffset / 1000, // Convertir a kilómetros para turf.destination
                                sweepDirectionInRotatedSpace, // 0 para N, 90 para E
                                {units: 'kilometers'}
                            );
                        } catch(e) {
                            console.error("Error en turf.destination al calcular punto en eje de barrido:", e);
                            rotatedCurrentOffset += workingWidth;
                            continue;
                        }

                        if (!pointOnSweepAxis || !pointOnSweepAxis.geometry || !pointOnSweepAxis.geometry.coordinates) {
                             console.warn("turf.destination devolvió un punto inválido. Saltando esta pasada.");
                             rotatedCurrentOffset += workingWidth;
                             continue;
                        }


                       let passCenterCoord = sweepDirectionInRotatedSpace === 0 ? pointOnSweepAxis.geometry.coordinates[1] : pointOnSweepAxis.geometry.coordinates[0];


                       let fullSweepLineInRotatedSpace = null;
                        try {
                           // Crear una línea que atraviesa toda la bbox rotada en la dirección de las pasadas,
                           // pasando por passCenterCoord en la dimensión perpendicular
                           if (sweepDirectionInRotatedSpace === 0) { // Pasadas horizontales (Oeste a Este)
                                fullSweepLineInRotatedSpace = turf.lineString([[rotatedBboxWest, passCenterCoord], [rotatedBboxEast, passCenterCoord]]);
                           } else { // Pasadas verticales (Sur a Norte)
                                fullSweepLineInRotatedSpace = turf.lineString([[passCenterCoord, rotatedBboxSouth], [passCenterCoord, rotatedBboxNorth]]);
                           }
                        } catch(e) {
                             console.error("Error en turf.lineString al crear línea de barrido completa:", e);
                            rotatedCurrentOffset += workingWidth;
                            continue;
                        }

                         if (!fullSweepLineInRotatedSpace || !fullSweepLineInRotatedSpace.geometry || fullSweepLineInRotatedSpace.geometry.type !== 'LineString') {
                              console.warn("La línea de barrido completa no es válida (esperado LineString). Saltando esta pasada.");
                              rotatedCurrentOffset += workingWidth;
                              continue;
                         }


                       let lineLength = 0;
                        try {
                             lineLength = turf.length(fullSweepLineInRotatedSpace, {units: units});
                        } catch(e) {
                             console.error("Error en turf.length al calcular longitud de línea de barrido:", e);
                            rotatedCurrentOffset += workingWidth;
                            continue;
                        }


                       let currentSegmentPoints = [];

                       for (let i = 0; i <= lineLength; i += samplingDistance) {
                           let point = null;
                           try {
                               point = turf.along(fullSweepLineInRotatedSpace, i, {units: units});
                           } catch(e) {
                               console.warn("Error en turf.along al muestrear punto.", i, e);
                               continue;
                           }

                           if (!point || !point.geometry || !point.geometry.coordinates) {
                                console.warn(`turf.along en distancia ${i} devolvió punto inválido. Saltando punto.`);
                                continue;
                           }


                           let isInside = false;
                           if (geometryForPiPCheck && (geometryForPiPCheck.type === 'Polygon' || geometryForPiPCheck.type === 'MultiPolygon')) {
                               try {
                                   isInside = turf.booleanPointInPolygon(point, geometryForPiPCheck);
                               } catch(e) {
                                   console.warn("Error durante booleanPointInPolygon para punto en muestreo.", point, e);
                                   isInside = false;
                               }
                           } else {
                               console.error("La geometría para verificación PiP no es válida (esperado Polygon/MultiPolygon).", geometryForPiPCheck);
                               isInside = false;
                           }


                           if (isInside && point && point.geometry && point.geometry.coordinates) {
                               currentSegmentPoints.push(point.geometry.coordinates);
                           } else {
                               if (currentSegmentPoints.length > 1) {
                                    try {
                                        generatedRotatedPasses.push(turf.lineString(currentSegmentPoints));
                                    } catch(e) {
                                        console.error("Error en turf.lineString al crear segmento de pasada rotada:", e);
                                    }
                               }
                               currentSegmentPoints = [];
                           }
                       }

                       if (currentSegmentPoints.length > 1) {
                            try {
                                generatedRotatedPasses.push(turf.lineString(currentSegmentPoints));
                           } catch(e) {
                                console.error("Error en turf.lineString al crear segmento final de pasada rotada:", e);
                           }
                       }

                       rotatedCurrentOffset += workingWidth;
                   }
               }


               console.log(`Generadas ${generatedRotatedPasses.length} pasadas (segmentos de LineString) en el espacio rotado.`);

               console.log(`Rotando pasadas de vuelta por ${-rotationAngle.toFixed(2)} grados.`);
               generatedRotatedPasses.forEach((rotatedPass, index) => {
                   try {
                        if (rotatedPass && rotatedPass.geometry && rotatedPass.geometry.type === 'LineString') {
                             if (!centroid || !centroid.geometry || !centroid.geometry.coordinates) {
                                 console.warn(`Centroide no válido al rotar pasada #${index}. Saltando rotación para esta pasada.`);
                                 return;
                             }
                             const originalPassGeometry = turf.transformRotate(rotatedPass.geometry, -rotationAngle, {pivot: centroid});
                             L.geoJSON(originalPassGeometry, {
                                 style: { color: '#800080', weight: 2 }
                             }).addTo(generatedPassesLayer);
                        } else {
                             console.warn(`La pasada rotada #${index} no es un LineString válido. No se añadirá al mapa.`, rotatedPass);
                        }

                   } catch (e) {
                       console.warn(`Error al rotar una pasada de vuelta (#${index}):`, rotatedPass, e);
                   }
               });

                /*
                 * === PUNTO DE IMPLEMENTACIÓN CLAVE ===
                 * Aquí es donde debes añadir tu lógica para generar pasadas basadas en la elevación y las curvas de nivel.
                 *
                 * Tienes acceso a:
                 * - `selectedLayer`: La capa Leaflet de la parcela seleccionada.
                 * - `selectedParcelGeoJSON`: Los datos GeoJSON de la parcela seleccionada.
                 * - `elevationGeoRaster`: El objeto GeoRaster cargado del MDT. Puedes usar sus métodos para obtener valores de elevación
                 * en puntos específicos (`georaster.getValueAt(lon, lat)`).
                 * - `contourLinesGeoJSON`: Los datos GeoJSON de las curvas de nivel.
                 * - `workingWidth`: El ancho de trabajo definido por el usuario.
                 * - `window.exclusionFeatures`: Un array de Features GeoJSON (Polígonos/MultiPolígonos) que representan las áreas a evitar
                 * dentro de la parcela. Ya se usó para recortar el área de barrido, pero podría ser relevante para lógicas más avanzadas.
                 *
                 * La lógica de barrido simple (recta) que genera `generatedRotatedPasses` está AHORA MISMO ejecutándose ANTES de este comentario.
                 * Si quieres reemplazar esa lógica por la tuya, debes eliminar o comentar el código de barrido recto anterior
                 * y colocar tu nueva lógica aquí.
                 *
                 * Tu lógica podría implicar:
                 * 1. Analizar las curvas de nivel y/o los datos de elevación dentro de la parcela seleccionada para determinar
                 * direcciones de máxima pendiente o áreas con elevación similar.
                 * 2. Generar líneas de pasada (LineString GeoJSON Features) basadas en este análisis, asegurándote de que respetan
                 * el `workingWidth` y evitan las zonas definidas en `window.exclusionFeatures`. Puedes usar `turf.js` para operaciones
                 * geométricas (intersección, diferencia, buffer, etc.).
                 * 3. Una vez que tengas un array de pasadas (LineString GeoJSON Features), iterar sobre ellas y añadirlas al
                 * `generatedPassesLayer` en el mapa usando `L.geoJSON(...).addTo(generatedPassesLayer);`.
                 *
                 * Considera usar `turf.js` para:
                 * - `turf.intersect(feature1, feature2)` para encontrar la intersección de la parcela con las áreas de exclusión o curvas de nivel.
                 * - `turf.buffer(feature, distance, {units: units})` si necesitas crear buffers alrededor de geometrías (aunque ya se hace para ELEMLIN LineStrings).
                 * - `turf.along(line, distance, {units: units})` para obtener puntos a lo largo de una línea (útil para muestreo).
                 * - `turf.bearing(point1, point2)` para obtener el ángulo entre dos puntos.
                 * - `turf.distance(point1, point2, {units: units})` para obtener la distancia entre dos puntos.
                 * - `turf.lineSlice(startPoint, endPoint, line)` para cortar segmentos de línea.
                 * - `turf.dissolve(featureCollection)` si necesitas disolver geometrías.
                 *
                 * Recuerda que `elevationGeoRaster.getValueAt(lon, lat)` te dará la elevación en un punto geográfico. Esto es fundamental
                 * para entender el terreno. Puedes iterar sobre puntos dentro de la parcela para obtener un "perfil" de elevación.
                 *
                 * ¡Buena suerte con la implementación!
                 */


               console.log("Generación de pasadas optimizadas (excluyendo zonas a evitar) finalizada.");
                console.log("--- Fin Generación de Pasadas ---");

           } catch (e) {
               console.error("Error general durante la generación de pasadas:", e);
               console.error("Parcel Geometry (inicio):", JSON.stringify(parcelGeometry));
               if (typeof geometryForCalculations !== 'undefined') {
                    console.error("Geometry for Calculations (después de exclusión):", JSON.stringify(geometryForCalculations));
               }
                if (typeof finalGeometryToSweep !== 'undefined') {
                    console.error("Final Geometry To Sweep (después de simplificación):", JSON.stringify(finalGeometryToSweep));
               }
                if (typeof geometryForSweepAndPiP !== 'undefined') {
                     console.error("Geometry For Sweep And PiP (polígono más grande):", JSON.stringify(geometryForSweepAndPiP));
                }

               alert("Ocurrió un error al generar las pasadas. Revisa la consola para detalles.");
           }
        });

        // --- LOGS INICIALES ---
        console.log("Mapa Leaflet con capas base, Catastro (WMS) inicializados.");
        console.log("La carga automática de datos GeoJSON y GeoTIFF comenzará al terminar de cargar el DOM.");

    </script>

</body>
</html>