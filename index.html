<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa con Leaflet, Catastro, GeoJSONs y Generación de Pasadas (Parcelas)</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin="anonymous"/>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
    <script src="https://unpkg.com/georaster@4.0.0/dist/georaster.global.min.js"></script>
    <script src="https://unpkg.com/georaster-layer-for-leaflet@3.8.0/dist/georaster-layer-for-leaflet.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <style>
        #map {
            height: 500px;
            width: 80%;
            margin: 20px auto;
            border: 1px solid #ccc;
        }
        .container {
            position: relative;
            width: 80%;
            margin: 20px auto;
        }
        /* Estilo básico para los controles */
        .control-container {
            text-align: center;
            margin-bottom: 10px;
        }
        .control-container label, .control-container input, .control-container button, .control-container select {
            display: inline-block;
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            vertical-align: middle; /* Alinea verticalmente los elementos */
        }
         .control-container label {
             padding: 10px 5px; /* Ajuste de padding para la etiqueta */
             cursor: default;
        }
        .control-container input[type="number"] {
             width: 80px; /* Ancho fijo para el input number */
             padding: 10px;
        }
         #loading-status {
             margin-top: 10px;
             font-size: 1em;
             color: #555;
         }
         /* Estilo para el control de capas Leaflet */
         .leaflet-control-layers-group-label {
            font-weight: bold;
            margin-top: 5px;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>

    <div class="control-container">
        <label for="parcel-select">Seleccionar Parcela:</label>
        <select id="parcel-select">
           <option value="">-- Seleccionar --</option>
           </select>

         <label for="avoid-select">Seleccionar Zona a Evitar:</label>
        <select id="avoid-select">
            <option value="">-- Seleccionar --</option>
            </select>


        <label for="workingWidth">Ancho de Trabajo (m):</label>
        <input type="number" id="workingWidth" value="15" min="1">
        <button id="generarPasadasBtn" disabled>Generar Pasadas (Cargando Datos...)</button>
        <div id="loading-status">Cargando datos geoespaciales...</div>
    </div>


    <div class="container">
        <div id="map"></div>
    </div>

    <script defer>
        // NOTA: Estos console.log ahora se ejecutarán cuando el script principal se ejecute,
        // que es después de que el DOM esté cargado y las librerías (si se cargaron sin errores)
        // deberían estar disponibles. El mensaje "inmediatamente después del script tag"
        // puede que ya no aplique textualmente a este punto, sino que signifique
        // "inmediatamente al inicio de la ejecución de este script".
        console.log("Estado de 'turf' al inicio del script principal:", typeof turf);
        if (typeof turf === 'undefined') {
             console.error("VERIFICACIÓN: 'turf' es undefined. El script de Turf.js NO se cargó o ejecutó como se esperaba.");
        } else {
             console.log("VERIFICACIÓN: 'turf' parece estar definido. Tipo:", typeof turf);
        }

        // --- Definir la proyección ETRS89 / UTM zone 30N (EPSG:25830) ---
         // Esto es necesario para que proj4js y las librerías que lo usan (como georaster-layer-for-leaflet)
         // entiendan el sistema de coordenadas del MDT GeoTIFF.
         if (typeof proj4 !== 'undefined') {
             try {
                 // +towgs84=0,0,0,0,0,0,0 es la transformación estándar de ETRS89 a WGS84, asumiendo que son equivalentes en la práctica.
                 proj4.defs("EPSG:25830", "+proj=utm +zone=30 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
                 console.log("Proyección EPSG:25830 (ETRS89 / UTM Huso 30N) definida en proj4js.");
             } catch(e) {
                  console.error("Error definiendo proyección EPSG:25830 en proj4js:", e);
             }
         } else {
             console.error("Proj4js no está cargado. La capa de elevación podría no cargarse correctamente.");
         }


        // Vista inicial en Andalucía (ajustada para Ronda)
        const map = L.map('map').setView([36.7462, -5.1612], 14); // Vista ajustada

        // --- Variables ---
        let selectedLayer = null; // Variable para almacenar la capa (parcela) que está seleccionada
        let originalStyle = {}; // Variable para guardar el estilo original de cada capa de parcela
        let parcelasLayer = null; // Capa para parcelas (seleccionable)
        let parcelasGeoJSON = null; // Almacenar datos GeoJSON de parcelas
        let construccionesLayer = null; // Capa para construcciones (exclusión)
        let elementosInternosLayer = null; // Capa para viales/arroyos/elementos internos (exclusión)
        window.exclusionFeatures = []; // Variable global para almacenar las geometrías de exclusión (Polygon/MultiPolygon)
        let generatedPassesLayer = L.featureGroup().addTo(map); // Capa para las pasadas generadas

        // --- Variables para los nuevos datos de elevación y curvas de nivel ---
        let elevationGeoRaster = null; // Para almacenar el objeto GeoRaster del MDT cargado
        let contourLinesGeoJSON = null; // Para almacenar los datos GeoJSON de las curvas de nivel cargadas


        // --- Elementos de la interfaz ---
        const generarPasadasBtn = document.getElementById('generarPasadasBtn');
        const workingWidthInput = document.getElementById('workingWidth');
        const loadingStatusDiv = document.getElementById('loading-status'); // Referencia al indicador de carga

        // --- Capas base ---
        // Capa Minimalista (Se mantiene)
        const minimalBaseLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19
        });

        // Capa Satélite Esri (Se mantiene para el híbrido, pero se quita del selector de capas base)
         const satelliteLayer = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
              attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, GeoEye, Earthstar Geographics, CNES/Airbus DS, GeoEye, USDA FSA, USGS, AeroGRID, IGN, IGP, swisstopo, and the GIS User Community',
              maxZoom: 18
         });

        // Capa de Etiquetas Esri (Se mantiene para el híbrido)
         const esriOverlayLabels = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
             attribution: 'Esri, Garmin, FAO, NOAA, USGS',
             maxZoom: 17,
             transparent: true
           });

        // Capa Híbrida (Satélite + Etiquetas) (Se mantiene)
         const hybridEsriLayer = L.layerGroup([satelliteLayer, esriOverlayLabels]);


        // --- Capa de superposición WMS de la Dirección General del Catastro ---
        const catastroWmsUrl = 'https://ovc.catastro.meh.es/Cartografia/WMS/ServidorWMS.aspx';
        const catastroLayer = L.tileLayer.wms(catastroWmsUrl, {
            layers: 'Catastro',
            styles: '',
            format: 'image/png',
            transparent: true,
            attribution: 'Cartografía &copy; Dirección General del Catastro (España)',
            maxZoom: 20
        });

        // --- Añade capas iniciales al mapa ---
        // Mantenemos minimalBaseLayer como capa base por defecto
        minimalBaseLayer.addTo(map);
        catastroLayer.addTo(map);

        // --- Configura el control de capas (se actualizará al cargar GeoJSON y otros datos) ---
        const baseLayers = {
            "Fondo Claro Minimalista": minimalBaseLayer,
            "Híbrido Satélite+Etiquetas (Esri)": hybridEsriLayer
        };

        const overlayLayers = {
             "Cartografía Catastral (WMS)": catastroLayer,
             "Pasadas Generadas": generatedPassesLayer
        };

        let layersControl = L.control.layers(baseLayers, overlayLayers).addTo(map);


        // --- Funciones de carga de datos y actualización de interfaz ---

        // Función para actualizar el control de capas
        function updateLayersControl() {
             if (layersControl) map.removeControl(layersControl);
             layersControl = L.control.layers(baseLayers, overlayLayers).addTo(map);
        }

        // Función genérica para cargar GeoJSON y añadirlo al mapa (adaptada para promesas)
        function loadGeoJSONLayer(url, layerName, style = {}) {
            loadingStatusDiv.textContent = `Cargando ${layerName}...`;
            console.log(`Iniciando carga de ${layerName} desde: ${url}`);
            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}, URL: ${url}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log(`${layerName} cargado con éxito. Número de features: ${data.features ? data.features.length : 'N/D'}`);
                    const layer = L.geoJSON(data, { style: style }); // NO añadir a mapa inmediatamente en esta función
                    return { name: layerName, layer: layer, data: data, error: null }; // Devolver info de la capa y datos
                })
                .catch(error => {
                    console.error(`Error cargando ${layerName} desde ${url}:`, error);
                    loadingStatusDiv.textContent = `Error cargando ${layerName}.`;
                    // No alertar por cada error individual en Promise.all, se gestiona al final.
                    return { name: layerName, layer: null, data: null, error: error }; // Indicar que hubo un error
                });
        }

         // Función para cargar el GeoTIFF COG (ACTUALIZADA para intentar solucionar parseGeoRaster no definido y TypeError)
         function loadGeoTIFFLayer(url, layerName, opacity = 0.5, style = {}) {
             loadingStatusDiv.textContent = `Cargando ${layerName}...`;
             console.log(`Iniciando carga de ${layerName} desde: ${url}`);

              // Verificar que Leaflet esté cargado antes de intentar usar GeoRasterLayer
              // NOTA: Esta verificación en tiempo de ejecución es un respaldo. El orden correcto de los SCRIPT tags es clave.
              if (typeof L === 'undefined' || typeof L.GridLayer === 'undefined') {
                  const error = new Error("Leaflet o L.GridLayer no está cargado o inicializado correctamente.");
                  console.error(`Error cargando ${layerName}: ${error.message}`);
                   loadingStatusDiv.textContent = `Error cargando ${layerName}: Leaflet no listo.`;
                   // Asegurarse de que el Promise.all pueda continuar aunque esta parte falle
                   return Promise.resolve({ name: layerName, georaster: null, layer: null, error: error });
              }


              // Verificar si proj4js está cargado y la proyección está definida antes de intentar usarlo con georaster
             if (typeof proj4 === 'undefined' || !proj4.defs("EPSG:25830")) {
                  const error = new Error("Proj4js o la definición EPSG:25830 no está disponible. No se cargará el GeoTIFF.");
                  console.error(`Error cargando ${layerName}: ${error.message}`);
                  loadingStatusDiv.textContent = `Error cargando ${layerName}.`;
                  return Promise.resolve({ name: layerName, georaster: null, layer: null, error: error });
             }

             return fetch(url)
                 .then(response => {
                     if (!response.ok) {
                         throw new Error(`HTTP error! status: ${response.status}, URL: ${url}`);
                     }
                     return response.arrayBuffer();
                 })
                 .then(arrayBuffer => {
                     console.log("Archivo GeoTIFF cargado en ArrayBuffer. Intentando parsear GeoRaster...");
                      // *** Intentar acceder a parseGeoRaster de forma segura (simplificado para paquete global) ***
                      let parseFn = undefined;

                      // Un paquete global debería exponer parseGeoRaster globalmente o bajo window.GeoRaster
                      if (typeof parseGeoRaster !== 'undefined') { // Ámbito global
                           parseFn = parseGeoRaster;
                           console.log("parseFn encontrado en ámbito global.");
                      } else if (typeof window.GeoRaster !== 'undefined' && typeof window.GeoRaster.parseGeoRaster === 'function') {
                           // Bajo window.GeoRaster (nombre común)
                           parseFn = window.GeoRaster.parseGeoRaster;
                           console.log("parseFn encontrado bajo window.GeoRaster.");
                      }
                       // Note: Otros paquetes podrían usar window.georaster o .default, pero .global.min.js suele usar window.GeoRaster.
                       // Si sigue dando error de parseFn no definido, podríamos añadir más comprobaciones o considerar un problema de compatibilidad.

                     if (typeof parseFn === 'undefined') {
                          // Si no se encuentra
                           console.error("parseGeoRaster (o similar) no definido en las ubicaciones esperadas.");
                           console.log("Contenido de window.GeoRaster para depuración:", typeof window.GeoRaster !== 'undefined' ? window.GeoRaster : 'undefined');
                           console.log("Contenido de window.GeoRasterLayer para depuración:", typeof window.GeoRasterLayer !== 'undefined' ? window.GeoRasterLayer : 'undefined');

                           const error = new Error("Librería GeoRaster no cargada correctamente o parseFn no encontrado.");
                           loadingStatusDiv.textContent = `Error cargando ${layerName}: parseFn no encontrado.`;
                           return Promise.reject(error); // Rechazar la promesa para que Promise.all falle
                     }

                     // Usar la función parseFn encontrada
                     return parseFn(arrayBuffer); // Esto devuelve una Promise

                 })
                 .then(georaster => {
                     console.log("GeoRaster de elevación parseado con éxito:", georaster);
                      // Verificar que GeoRasterLayer esté cargado antes de usarlo
                       if (typeof GeoRasterLayer === 'undefined') {
                            const error = new Error("Librería GeoRasterLayer no cargada correctamente.");
                             console.error(`Error cargando ${layerName}: ${error.message}`);
                             loadingStatusDiv.textContent = `Error cargando ${layerName}: GeoRasterLayer no encontrado.`;
                             return Promise.resolve({ name: layerName, georaster: georaster, layer: null, error: error }); // Resolver, pero con error
                       }

                      // Crear la capa de Leaflet a partir del objeto GeoRaster.
                      // georaster-layer-for-leaflet usa proj4js para re-proyectar al vuelo.
                      const layer = new GeoRasterLayer({
                          georaster: georaster,
                          opacity: opacity,
                          // pixelValuesToColorFn: ... // Puedes añadir estilo aquí
                          // range: ...
                          // colors: ...
                      });
                      console.log(`${layerName} cargado con éxito.`);
                      return { name: layerName, georaster: georaster, layer: layer, error: null }; // Devolver info y el objeto georaster
                 })
                 .catch(error => {
                      console.error(`Error cargando y parseando GeoTIFF de ${layerName} desde ${url}:`, error);
                       loadingStatusDiv.textContent = `Error cargando ${layerName}.`;
                       // No alertar por cada error individual
                       return { name: layerName, georaster: null, layer: null, error: error }; // Indicar error
                 });
         }


        // --- Carga automática de datos al cargar la página ---
        document.addEventListener('DOMContentLoaded', function() {
            console.log("El DOM está cargado. Iniciando carga automática de datos geoespaciales.");
            console.log("Estado de exclusionFeatures global al inicio del DOMContentLoaded:", window.exclusionFeatures ? window.exclusionFeatures.length : 'undefined/null');
            loadingStatusDiv.textContent = 'Cargando datos...';
            generarPasadasBtn.disabled = true; // Asegurarse de que esté deshabilitado durante la carga


            // *** URLs de TUS ARCHIVOS EN GITHUB RAW ***
            // ** IMPORTANTE: Para evitar errores CORS, asegúrate de que tu página HTML también se sirve desde un servidor web (no abrir directamente desde file:///...). **
            // ** Las URLs raw.githubusercontent.com suelen permitir CORS si la página se sirve vía http/https. **
            const parcelasGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/JSON/main/PARCELA.geojson'; // URL DE PARCELAS (seleccionable)
            const construccionesGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/parcela/main/CONSTRU.json'; // URL DE CONSTRUCCIONES (exclusión)
            const elementosInternosGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/parcela/main/ELEMLIN.json'; // URL DE ELEMENTOS INTERNOS (exclusión - puede necesitar buffer)
            const mdtUrl = 'https://raw.githubusercontent.com/tinajita/parcela/main/MDT25-ETRS89-H30-1051-1-COB2.tif'; // URL del GeoTIFF COG de elevación (0.93 MB)
            const contourLinesUrl = 'https://raw.githubusercontent.com/tinajita/parcela/main/BTN0201L_CUR_NIV.json'; // URL del GeoJSON de curvas de nivel simplificadas (aprox 6.32 MB)
            // *** FIN URLs ***

            const units = 'meters'; // Unidades para Turf.js (buffer)
            const bufferDistanceForLines = 2; // Define una distancia de buffer adecuada en metros para LineStrings de ELEMLIN.json


            // Usar Promise.all para cargar todos los archivos concurrentemente
            Promise.all([
                loadGeoJSONLayer(parcelasGeojsonDataUrl, 'Mis Parcelas', { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 }), // Estilo por defecto de parcela
                loadGeoJSONLayer(construccionesGeojsonDataUrl, 'Construcciones', { color: 'red', weight: 2, opacity: 0.7, fillOpacity: 0.3 }),
                loadGeoJSONLayer(elementosInternosGeojsonDataUrl, 'Viales y Arroyos', { // Estilo adaptado para líneas/polígonos
                           style: feature => {
                                if (feature.geometry && feature.geometry.type === 'LineString') {
                                     return { color: '#0000FF', weight: 2, opacity: 0.8 };
                                } else if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                                     return { color: '#006400', weight: 1, fillColor: '#006400', fillOpacity: 0.3 };
                                }
                                return { color: '#888888', weight: 1, opacity: 0.5 };
                           }
                        }),
                loadGeoTIFFLayer(mdtUrl, 'Elevación (MDT25)', 0.5), // Cargar el GeoTIFF
                loadGeoJSONLayer(contourLinesUrl, 'Curvas de Nivel', { color: '#888', weight: 1, opacity: 0.7 }) // Cargar Curvas de Nivel GeoJSON
            ])
            .then(results => {
                console.log("Resultados de carga de Promise.all:", results);
                let allKeyDataLoadedSuccessfully = true; // Bandera para verificar si todos los archivos clave cargaron sin error

                // Procesar los resultados de la carga
                 results.forEach(result => {
                     if (result.error) {
                          allKeyDataLoadedSuccessfully = false;
                          // El error ya fue loggeado en la función de carga.
                          // Podemos mostrar un mensaje de error general al final si allKeyDataLoadedSuccessfully es false
                     } else {
                         // Si la carga fue exitosa, procesar y añadir la capa al mapa/control
                         if (result.name === 'Mis Parcelas') {
                             parcelasLayer = result.layer;
                             parcelasGeoJSON = result.data;
                             if (parcelasGeoJSON && parcelasGeoJSON.features) {
                                 populateSelect('parcel-select', parcelasGeoJSON, 'CODIGO'); // Poblar el selector de parcela
                                  // Añadir la capa de Parcelas al mapa y al control de capas
                                 if (parcelasLayer) {
                                      parcelasLayer.addTo(map);
                                       overlayLayers["Mis Parcelas"] = parcelasLayer;
                                  } else { allKeyDataLoadedSuccessfully = false; console.error("La capa de Parcelas no se pudo crear."); }
                             } else { allKeyDataLoadedSuccessfully = false; console.error("Datos de Parcelas nulos o sin features."); }
                         } else if (result.name === 'Construcciones') {
                              construccionesLayer = result.layer;
                              // Recopilar geometrías de exclusión (Polygon/MultiPolygon) si los datos son válidos
                              if (result.data && result.data.features) {
                                  result.data.features.forEach(feature => {
                                      if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                                          window.exclusionFeatures.push(JSON.parse(JSON.stringify(feature)));
                                      }
                                  });
                                   // Añadir capa al mapa y control
                                  if (construccionesLayer) {
                                       construccionesLayer.addTo(map);
                                        overlayLayers["Construcciones"] = construccionesLayer;
                                  } else { console.warn("La capa de Construcciones no se pudo crear."); }

                              } else { console.warn("Datos de Construcciones nulos o vacíos."); }
                         } else if (result.name === 'Viales y Arroyos') {
                              elementosInternosLayer = result.layer;
                              // Recopilar geometrías de exclusión (LineString -> Buffer, Polygon/MultiPolygon) si los datos son válidos
                               if (result.data && result.data.features) {
                                   result.data.features.forEach(feature => {
                                       if (feature.geometry) {
                                           if (feature.geometry.type === 'LineString') {
                                                try {
                                                    // Asegurarse de que turf está cargado antes de buffer
                                                    if (typeof turf !== 'undefined') {
                                                         const buffered = turf.buffer(feature, bufferDistanceForLines, {units: units});
                                                          // El buffer puede producir un FeatureCollection si el input es multi-geometría, o null si falla
                                                          if (buffered && buffered.features && buffered.features.length > 0) {
                                                               // Si es FeatureCollection, añadir las geometrías resultantes
                                                               buffered.features.forEach(bf => {
                                                                    if(bf.geometry && (bf.geometry.type === 'Polygon' || bf.geometry.type === 'MultiPolygon')) {
                                                                         window.exclusionFeatures.push(JSON.parse(JSON.stringify(bf)));
                                                                    } else { console.warn("Buffer de LineString produjo feature no poligonal:", bf); }
                                                               });
                                                          } else if (buffered && buffered.geometry && (buffered.geometry.type === 'Polygon' || buffered.geometry.type === 'MultiPolygon')) {
                                                               // Si es un solo Feature con Polygon/MultiPolygon
                                                                window.exclusionFeatures.push(JSON.parse(JSON.stringify(buffered)));
                                                          }
                                                          else {
                                                               console.warn("Buffer de LineString no válido para exclusión (no FeatureCollection ni Feature válido):", feature, buffered);
                                                          }
                                                    } else { console.error("Turf.js no cargado para buffer de Linea."); }

                                                } catch(e) { console.error("Error buffer LineString:", e); }
                                           } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                                                window.exclusionFeatures.push(JSON.parse(JSON.stringify(feature)));
                                           }
                                       }
                                   });
                                    // Añadir capa al mapa y control (el estilo ya maneja LineString y Polygon)
                                   if (elementosInternosLayer) {
                                        elementosInternosLayer.addTo(map);
                                        overlayLayers["Viales y Arroyos"] = elementosInternosLayer;
                                   } else { console.warn("La capa de Viales y Arroyos no se pudo crear."); }
                               } else { console.warn("Datos de Viales y Arroyos nulos o vacíos."); }
                         } else if (result.name === 'Elevación (MDT25)') {
                             elevationGeoRaster = result.georaster; // Almacenar el objeto georaster
                             // La capa Leaflet ya se creó y añadió en loadGeoTIFFLayer si el georaster es válido
                             if (!elevationGeoRaster) { allKeyDataLoadedSuccessfully = false; console.error("Objeto georaster nulo después de la carga."); }
                             else {
                                  overlayLayers["Elevación (MDT25)"] = result.layer; // Añadir capa al control
                                  if (result.layer) result.layer.addTo(map); // Añadir al mapa
                                  else { console.warn("La capa Leaflet de Elevación no se pudo crear."); allKeyDataLoadedSuccessfully = false; }
                             }
                         } else if (result.name === 'Curvas de Nivel') {
                             contourLinesGeoJSON = result.data; // Almacenar los datos GeoJSON de curvas de nivel
                              // La capa Leaflet ya se creó y añadió en loadGeoJSONLayer si los datos son válidos
                              if (!contourLinesGeoJSON || !contourLinesGeoJSON.features) { allKeyDataLoadedSuccessfully = false; console.error("Datos GeoJSON de Curvas de Nivel nulos o sin features."); }
                               else {
                                    overlayLayers["Curvas de Nivel"] = result.layer; // Añadir capa al control
                                    if (result.layer) result.layer.addTo(map); // Añadir al mapa
                                     else { console.warn("La capa Leaflet de Curvas de Nivel no se pudo crear."); allKeyDataLoadedSuccessfully = false; }
                               }
                         }

                          // Las capas de Construcciones, Viales, Elevación y Curvas de Nivel se añaden
                          // dentro de sus respectivos bloques if/else if arriba si se crearon correctamente.
                          // La capa de Parcelas también se añade arriba.

                     }
                 });

                 console.log(`Total features de exclusión recopiladas: ${window.exclusionFeatures.length}`);
                 console.log("Estado de exclusionFeatures global DESPUÉS de la carga:", window.exclusionFeatures.length, window.exclusionFeatures);


                // Actualizar el control de capas final
                updateLayersControl();

                // Ajustar la vista del mapa a la extensión de las Parcelas si se cargaron
                if (parcelasLayer && parcelasLayer.getBounds().isValid()) {
                     map.fitBounds(parcelasLayer.getBounds());
                } else {
                     console.warn("No se pudieron obtener bounds válidos de la capa de parcelas. Ajustando vista a Ronda...");
                      map.setView([36.7462, -5.1612], 14); // Fallback
                }

                 // Habilitar el botón si todos los datos CLAVE cargaron sin errores reportados en Promise.all
                 // Los datos clave son: Parcelas (geoJSON y layer), Elevación (georaster y layer), Curvas de Nivel (geoJSON y layer)
                 if (allKeyDataLoadedSuccessfully && parcelasGeoJSON && parcelasLayer && elevationGeoRaster && overlayLayers["Elevación (MDT25)"] && contourLinesGeoJSON && overlayLayers["Curvas de Nivel"]) {
                     loadingStatusDiv.textContent = 'Datos cargados. Selecciona una parcela.';
                     // El botón se habilita en el evento 'change' del selector si la parcela es válida
                     // Y si allKeyDataLoadedSuccessfully es true.
                     // Ahora, el botón solo se habilita si ya se seleccionó una parcela Y LA CARGA FUE EXITOSA.
                      // No habilitar aquí, se habilita en el evento 'change' si todo está listo.
                     console.log("Carga automática de datos finalizada con éxito. Esperando selección de parcela.");
                 } else {
                      loadingStatusDiv.textContent = 'Carga de datos completada con errores.';
                      console.error("La carga automática de datos finalizó, pero faltan datos clave. El botón de generar pasadas está deshabilitado.");
                      // Un alert general al final si hubo algún error de carga clave
                       let missingData = [];
                       if (!parcelasGeoJSON) missingData.push("Parcelas (datos)");
                       if (!parcelasLayer) missingData.push("Parcelas (capa Leaflet)");
                       if (!elevationGeoRaster) missingData.push("Elevación (georaster)");
                       if (!overlayLayers["Elevación (MDT25)"]) missingData.push("Elevación (capa Leaflet)");
                       if (!contourLinesGeoJSON) missingData.push("Curvas de Nivel (datos)");
                       if (!overlayLayers["Curvas de Nivel"]) missingData.push("Curvas de Nivel (capa Leaflet)");

                      if (missingData.length > 0) {
                           alert(`No se pudieron cargar todos los datos necesarios. Faltan: ${missingData.join(", ")}. Revisa la consola para detalles.`);
                      } else {
                           // Si no hay datos faltantes explícitos pero allKeyDataLoadedSuccessfully es false,
                           // podría ser un error en Construcciones/Viales o un error general no capturado.
                           alert("La carga de datos finalizó con errores. Revisa la consola para detalles.");
                      }

                 }


            })
            .catch(error => {
                 // Este catch se ejecutará si Promise.all falla catastróficamente,
                 // pero los errores individuales ya se manejan en cada función de carga.
                console.error("Error inesperado en Promise.all durante la carga de datos:", error);
                loadingStatusDiv.textContent = `Error crítico durante la carga: ${error.message}`;
                alert(`Ocurrió un error crítico durante la carga de datos. Revisa la consola para detalles.`);
            });
        });


        // Función para poblar un selector (select) con opciones de un FeatureCollection
        function populateSelect(selectId, featureCollection, propertyName) {
            const selectElement = document.getElementById(selectId);
            if (!selectElement || !featureCollection || !featureCollection.features) {
                console.warn(`No se pudo poblar el selector ${selectId}.`);
                return;
            }

            // Limpiar opciones existentes (excepto la primera, si es una opción por defecto)
            selectElement.innerHTML = '<option value="">-- Seleccionar --</option>';

            featureCollection.features.forEach(feature => {
                if (feature.properties && feature.properties[propertyName]) {
                    const option = document.createElement('option');
                    option.value = feature.properties[propertyName]; // Usar el código como valor
                    option.textContent = feature.properties[propertyName]; // Mostrar el código como texto
                    // También puedes mostrar otros atributos si son relevantes
                    // option.textContent = `Código: ${feature.properties[propertyName]} - Tipo: ${feature.properties.TIPO || 'N/D'}`;
                    selectElement.appendChild(option);
                }
            });
             console.log(`Selector '${selectId}' poblado con ${featureCollection.features.length} opciones.`);
        }

        // Manejar la selección de parcela
        const parcelSelect = document.getElementById('parcel-select');
        // Asegúrate de que el select de parcela existe en tu HTML. Se ha añadido en el código modificado.
        if (parcelSelect) {
            parcelSelect.addEventListener('change', (event) => {
                const selectedCode = event.target.value;

                // Limpiar selección anterior y estilo
                if (selectedLayer) {
                    // Restaurar estilo original si lo guardaste, o un estilo por defecto si no
                    // Clonar para evitar modificar el objeto original en caso de que el estilo sea complejo
                    const styleToRestore = originalStyle[selectedLayer._leaflet_id] ? JSON.parse(JSON.stringify(originalStyle[selectedLayer._leaflet_id])) : { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 };
                    selectedLayer.setStyle(styleToRestore);
                }
                selectedLayer = null; // Limpiar la referencia a la capa Leaflet seleccionada
                let selectedParcelGeoJSON = null; // Variable para almacenar el GeoJSON del feature seleccionado

                generarPasadasBtn.disabled = true; // Deshabilitar botón hasta seleccionar una válida

                if (selectedCode && parcelasGeoJSON && parcelasGeoJSON.features) {
                     const featureFound = parcelasGeoJSON.features.find(feature => feature.properties && feature.properties.CODIGO === selectedCode);

                    if (featureFound) {
                         // Si modificas el estilo de la capa existente (como en el original)
                         if (parcelasLayer) { // Asegúrate de que la capa de parcelas esté cargada
                              parcelasLayer.eachLayer(layer => {
                                   if (layer.feature && layer.feature.properties && layer.feature.properties.CODIGO === selectedCode) {
                                        // Guardar el estilo original antes de aplicarle el estilo de selección
                                        // Clonar para evitar modificar el objeto original en caso de que el estilo sea complejo
                                        originalStyle[layer._leaflet_id] = layer.options.style ? JSON.parse(JSON.stringify(layer.options.style)) : { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 };
                                        layer.setStyle({ color: '#00FFFF', weight: 3, fillColor: '#00FFFF', fillOpacity: 0.3 }); // Estilo de selección
                                        selectedLayer = layer; // Guarda la referencia a la capa Leaflet seleccionada
                                        selectedParcelGeoJSON = layer.feature; // Guarda el GeoJSON del feature seleccionado
                                        // Acercar el mapa SOLO si la capa tiene bounds válidos (algunos GeoJSONs pueden ser puntos o líneas sin extent claro)
                                        if (layer.getBounds && layer.getBounds().isValid()) {
                                              map.fitBounds(layer.getBounds()); // Acercar el mapa
                                        } else if (layer.getLatLng) { // Si es un punto
                                              map.setView(layer.getLatLng(), 16); // Acercar a un punto con un zoom fijo
                                        }


                                        // Habilitar botón solo si la parcela es válida Y los datos clave ya cargaron
                                        // La bandera allKeyDataLoadedSuccessfully se establece en el Promise.all del DOMContentLoaded
                                        // Necesitamos acceder a esa bandera. Podríamos hacerla global o re-verificar aquí.
                                        // Re-verificar los objetos cargados es más seguro que depender de una bandera global.
                                        // if (parcelasGeoJSON && elevationGeoRaster && contourLinesGeoJSON) {
                                        //     generarPasadasBtn.disabled = false;
                                        // }
                                        // Mejor verificar directamente la bandera global o los objetos
                                        // Si la carga inicial fue exitosa, habilitar el botón
                                        // Asumimos que si parcelasGeoJSON, elevationGeoRaster y contourLinesGeoJSON
                                        // existen aquí, la carga inicial fue considerada exitosa para habilitar la lógica.
                                        // Una bandera global `window.allInitialDataLoadedSuccessfully = true;` en el .then final
                                        // del Promise.all sería más robusto.
                                        // Por ahora, verificamos si los objetos necesarios existen.
                                        if (typeof turf !== 'undefined' && parcelasGeoJSON && elevationGeoRaster && contourLinesGeoJSON) {
                                             generarPasadasBtn.disabled = false;
                                        } else {
                                             console.warn("Faltan librerías o datos necesarios para habilitar el botón de generar pasadas.");
                                        }


                                        console.log("Parcela seleccionada:", selectedParcelGeoJSON.properties);
                                        L.DomEvent.stopPropagation(event); // Evitar propagación del clic si fuera relevante

                                        // Aquí podrías añadir lógica para filtrar y mostrar las exclusiones relevantes a esta parcela
                                        // o para realizar alguna otra acción específica de la parcela.

                                   } else {
                                        // Asegurarse de que las otras parcelas tengan su estilo original
                                        // Usar el estilo guardado, o el estilo por defecto si no se guardó (aunque debería haberse guardado)
                                         const styleToRestore = originalStyle[layer._leaflet_id] ? JSON.parse(JSON.stringify(originalStyle[layer._leaflet_id])) : { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 };
                                        layer.setStyle(styleToRestore);
                                   }
                              });
                         } else {
                             console.warn("La capa de parcelas no está cargada al intentar seleccionar.");
                         }

                    } else {
                        console.warn("No se encontró la parcela con el código:", selectedCode, "en los datos cargados.");
                        // alert("No se encontró la parcela seleccionada en los datos cargados."); // Evitar alert, el log es suficiente
                    }
                }
                // Si selectedParcelGeoJSON es null al final (no se encontró o seleccionó '-- Seleccionar --'), el botón seguirá deshabilitado.
            });
        } else {
             console.error("Elemento 'parcel-select' no encontrado en el DOM. Asegúrate de que está en tu HTML.");
        }


        // El selector 'avoid-select' en el HTML original no tenía funcionalidad asociada.
        // Si necesitas implementar la selección de zonas a evitar desde un select, necesitarías
        // poblarlo con opciones (ej. IDs de construcciones/viales) y manejar su selección.
        // La variable global `window.exclusionFeatures` ya contiene las geometrías de exclusión cargadas
        // (Construcciones y Elementos Linea con buffer si eran líneas).
        // Tu lógica en el evento click ya filtra las que intersectan con la parcela seleccionada
        // y las usa para calcular el área limpia. Puedes usar esa variable.
        // Si quieres poder SELECCIONAR zonas a evitar manualmente en el mapa, necesitarías:
        // 1. Hacer las capas de Construcciones y Viales interactivas (onEachFeature con click listeners).
        // 2. Tener una forma (ej. un botón o modo) para indicar que estás seleccionando zonas a evitar.
        // 3. Al hacer clic en una feature de Construcción o Vial, añadir su geometría (o su buffer si es LineString)
        //    a una lista TEMPORAL de "zonas a evitar seleccionadas por el usuario" para la generación de pasadas actual.
        // 4. Usar esta lista TEMPORAL en la lógica de exclusión dentro del botón de generar pasadas,
        //    EN LUGAR de (o además de) usar la variable global `window.exclusionFeatures` completa.
        // 5. Proporcionar alguna retroalimentación visual de las zonas a evitar seleccionadas por el usuario.
        // Esta implementación es compleja y va más allá del alcance actual. Por ahora, la lógica usa TODAS
        // las exclusiones cargadas que intersectan la parcela.


        // --- LÓGICA PARA GENERAR PASADAS OPTIMIZADAS USANDO TURF.JS Y DATOS DE ELEVACIÓN/CURVAS ---

        generarPasadasBtn.addEventListener('click', function() {

            // --- VERIFICACIÓN DE TURF ---
            console.log("Estado de 'turf' al hacer clic en Generar Pasadas: