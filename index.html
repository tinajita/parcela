<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa con Leaflet, Catastro, GeoJSONs y Generación de Pasadas (Parcelas)</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin="anonymous"/>

    <style>
        #map {
            height: 500px;
            width: 80%;
            margin: 20px auto;
            border: 1px solid #ccc;
        }
        .container {
            position: relative;
            width: 80%;
            margin: 20px auto;
        }
        /* Estilo básico para los controles */
        .control-container {
            text-align: center;
            margin-bottom: 10px;
        }
        /* Eliminamos los estilos específicos para select si ya no hay selectores */
        .control-container label, .control-container input, .control-container button {
            display: inline-block;
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            vertical-align: middle; /* Alinea verticalmente los elementos */
        }
         .control-container label {
             padding: 10px 5px; /* Ajuste de padding para la etiqueta */
             cursor: default;
        }
        .control-container input[type="number"] {
             width: 80px; /* Ancho fijo para el input number */
             padding: 10px;
        }
         #loading-status {
             margin-top: 10px;
             font-size: 1em;
             color: #555;
         }
         /* Estilo para el control de capas Leaflet */
         .leaflet-control-layers-group-label {
            font-weight: bold;
            margin-top: 5px;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>

    <div class="control-container">
        <label for="workingWidth">Ancho de Trabajo (m):</label>
        <input type="number" id="workingWidth" value="15" min="1">
        <button id="generarPasadasBtn" disabled>Generar Pasadas (Cargando Datos...)</button>
        <div id="loading-status">Cargando datos geoespaciales...</div>
    </div>


    <div class="container">
        <div id="map"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/georaster@1.6.0/dist/georaster.browser.bundle.min.js"></script>
    <script src="https://unpkg.com/georaster-layer-for-leaflet@3.8.0/dist/georaster-layer-for-leaflet.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <script defer>
        // Define variables y funciones clave en un ámbito superior para evitar ReferenceErrors
        let map; // Se inicializará en DOMContentLoaded
        let layersControl = null;
        const baseLayers = {};
        const overlayLayers = {};

        // Función para actualizar el control de capas
        function updateLayersControl() {
             // Inicializa el control si no existe o lo actualiza
             if (!layersControl && map) { // Inicializar solo si el mapa está listo
                  layersControl = L.control.layers(baseLayers, overlayLayers).addTo(map);
                  console.log("Layers control inicializado.");
             } else if (layersControl && map) { // Actualizar si el control ya existe y el mapa está listo
                 map.removeControl(layersControl);
                 layersControl = L.control.layers(baseLayers, overlayLayers).addTo(map);
                 console.log("Layers control actualizado.");
             } else {
                 console.warn("Mapa no definido o control de capas no inicializado. No se puede actualizar el control de capas.");
             }
        }

        // --- Debugging: Inspect global window object after library scripts load ---
        console.log("Contenido de window después de cargar librerías:");
        for (let key in window) {
            // Añadir una comprobación hasOwnProperty para evitar propiedades heredadas si es necesario
            if (window.hasOwnProperty(key)) {
                const lowerKey = key.toLowerCase();
                if (lowerKey.includes('georaster') || lowerKey.includes('geotiff') || (typeof window[key] === 'function' && lowerKey.includes('parse'))) {
                     // Limitar la profundidad para evitar logs excesivos de objetos complejos
                     // console.log(`window['${key}']:`, typeof window[key] === 'function' ? window[key].toString().substring(0, 100) + '...' : window[key]);
                     // Mostrar el objeto completo para mejor depuración, pero con cuidado
                     try {
                         console.log(`window['${key}']:`, window[key]);
                     } catch(e) {
                         console.log(`window['${key}']: Error al serializar`, e);
                     }

                }
            }
        }
        console.log("--- Fin Contenido de window ---");


        // --- El resto del script se ejecuta después de que el DOM esté listo y las librerías con 'defer' cargadas ---
        document.addEventListener('DOMContentLoaded', function() {
            console.log("El DOM está cargado. Iniciando script principal.");
            console.log("Estado de 'turf' al inicio del script principal:", typeof turf);
            if (typeof turf === 'undefined') {
                 console.error("VERIFICACIÓN: 'turf' es undefined. El script de Turf.js NO se cargó o ejecutó como se esperaba.");
            } else {
                 console.log("VERIFICACIÓN: 'turf' parece estar definido. Tipo:", typeof turf);
            }

            // --- Definir la proyección ETRS89 / UTM zone 30N (EPSG:25830) ---
             // Esto es necesario para que proj4js y las librerías que lo usan (como georaster-layer-for-leaflet)
             // entiendan el sistema de coordenadas del MDT GeoTIFF.
             if (typeof proj4 !== 'undefined') {
                 try {
                     // +towgs84=0,0,0,0,0,0,0 es la transformación estándar de ETRS89 a WGS84, asumiendo que son equivalentes en la práctica.
                     proj4.defs("EPSG:25830", "+proj=utm +zone=30 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
                     console.log("Proyección EPSG:25830 (ETRS89 / UTM Huso 30N) definida en proj4js.");
                 } catch(e) {
                      console.error("Error definiendo proyección EPSG:25830 en proj4js:", e);
                 }
             } else {
                 console.error("Proj4js no está cargado. La capa de elevación podría no cargarse correctamente.");
             }


            // Vista inicial en Andalucía (ajustada para Ronda)
            map = L.map('map').setView([36.7462, -5.1612], 14); // Vista ajustada

            // --- Variables ---
            let selectedLayer = null; // Variable para almacenar la capa (parcela) que está seleccionada
            let originalStyle = {}; // Variable para guardar el estilo original de cada capa de parcela
            let parcelasLayer = null; // Capa para parcelas (seleccionable)
            let parcelasGeoJSON = null; // Almacenar datos GeoJSON de parcelas
            let construccionesLayer = null; // Capa para construcciones (exclusión)
            let elementosInternosLayer = null; // Capa para viales/arroyos/elementos internos (exclusión)
            window.exclusionFeatures = []; // Variable global para almacenar las geometrías de exclusión (Polygon/MultiPolygon)
            let generatedPassesLayer = L.featureGroup().addTo(map); // Capa para las pasadas generadas

            // --- Variables para los nuevos datos de elevación y curvas de nivel ---
            let elevationGeoRaster = null; // Para almacenar el objeto GeoRaster del MDT cargado
            let contourLinesGeoJSON = null; // Para almacenar los datos GeoJSON de curvas de nivel cargadas


            // --- Elementos de la interfaz ---
            const generarPasadasBtn = document.getElementById('generarPasadasBtn');
            const workingWidthInput = document.getElementById('workingWidth');
            const loadingStatusDiv = document.getElementById('loading-status'); // Referencia al indicador de carga

            // --- Capas base ---
            // Capa Minimalista (Se mantiene)
            baseLayers["Fondo Claro Minimalista"] = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            });

            // Capa Satélite Esri (Se mantiene para el híbrido, pero se quita del selector de capas base)
             const satelliteLayer = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                  attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, GeoEye, Earthstar Geographics, CNES/Airbus DS, GeoEye, USDA FSA, USGS, AeroGRID, IGN, IGP, swisstopo, and the GIS User Community',
                  maxZoom: 18
             });

            // Capa de Etiquetas Esri (Se mantiene para el híbrido)
             const esriOverlayLabels = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
                 attribution: 'Esri, Garmin, FAO, NOAA, USGS',
                 maxZoom: 17,
                 transparent: true
               });

            // Capa Híbrida (Satélite + Etiquetas) (Se mantiene)
             baseLayers["Híbrido Satélite+Etiquetas (Esri)"] = L.layerGroup([satelliteLayer, esriOverlayLabels]);


            // --- Capa de superposición WMS de la Dirección General del Catastro ---
            const catastroWmsUrl = 'https://ovc.catastro.meh.es/Cartografia/WMS/ServidorWMS.aspx';
            overlayLayers["Cartografía Catastral (WMS)"] = L.tileLayer.wms(catastroWmsUrl, {
                layers: 'Catastro',
                styles: '',
                format: 'image/png',
                transparent: true,
                attribution: 'Cartografía &copy; Dirección General del Catastro (España)',
                maxZoom: 20
            });

            // --- Añade capas iniciales al mapa ---
            // Mantenemos minimalBaseLayer como capa base por defecto
            baseLayers["Fondo Claro Minimalista"].addTo(map);
            overlayLayers["Cartografía Catastral (WMS)"].addTo(map);

            // --- Configura el control de capas (inicializado aquí) ---
            // Initialize the layers control for the first time AFTER map is defined
            updateLayersControl(); // Llama a la función definida fuera


            // --- Funciones de carga de datos y actualización de interfaz ---

            // Función genérica para cargar GeoJSON y añadirlo al mapa (adaptada para promesas)
            function loadGeoJSONLayer(url, layerName, style = {}, options = {}) {
                loadingStatusDiv.textContent = `Cargando ${layerName}...`;
                console.log(`Iniciando carga de ${layerName} desde: ${url}`);
                return fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}, URL: ${url}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log(`${layerName} cargado con éxito. Número de features: ${data.features ? data.features.length : 'N/D'}`);
                        const layer = L.geoJSON(data, { style: style, onEachFeature: options.onEachFeature }); // Incluir onEachFeature si se proporciona
                        return { name: layerName, layer: layer, data: data, error: null }; // Devolver info de la capa y datos
                    })
                    .catch(error => {
                        console.error(`Error cargando ${layerName} desde ${url}:`, error);
                        loadingStatusDiv.textContent = `Error cargando ${layerName}.`;
                        // No alertar por cada error individual en Promise.all, se gestiona al final.
                        return { name: layerName, layer: null, data: null, error: error }; // Indicar que hubo un error
                    });
            }

             // Función para cargar el GeoTIFF COG (ACTUALIZADA para intentar solucionar parseGeoRaster no definido y TypeError)
             function loadGeoTIFFLayer(url, layerName, opacity = 0.5, style = {}) {
                 loadingStatusDiv.textContent = `Cargando ${layerName}...`;
                 console.log(`Iniciando carga de ${layerName} desde: ${url}`);

                  // Verificar que Leaflet esté cargado antes de intentar usar GeoRasterLayer
                  // NOTA: Esta verificación en tiempo de ejecución es un respaldo. El orden correcto de los SCRIPT tags es clave.
                  if (typeof L === 'undefined' || typeof L.GridLayer === 'undefined') {
                      const error = new Error("Leaflet o L.GridLayer no está cargado o inicializado correctamente.");
                      console.error(`Error cargando ${layerName}: ${error.message}`);
                       loadingStatusDiv.textContent = `Error cargando ${layerName}: Leaflet no listo.`;
                       // Asegurarse de que el Promise.all pueda continuar aunque esta parte falle
                       return Promise.resolve({ name: layerName, georaster: null, layer: null, error: error });
                  }


                  // Verificar si proj4js está cargado y la proyección está definida antes de intentar usarlo con georaster
                 if (typeof proj4 === 'undefined' || !proj4.defs("EPSG:25830")) {
                      const error = new Error("Proj4js o la definición EPSG:25830 no está disponible. No se cargará el GeoTIFF.");
                      console.error(`Error cargando ${layerName}: ${error.message}`);
                      loadingStatusDiv.textContent = `Error cargando ${layerName}.`;
                      return Promise.resolve({ name: layerName, georaster: null, layer: null, error: error });
                 }

                 return fetch(url)
                     .then(response => {
                         if (!response.ok) {
                             throw new Error(`HTTP error! status: ${response.status}, URL: ${url}`);
                         }
                         return response.arrayBuffer();
                     })
                     .then(arrayBuffer => {
                         console.log("Archivo GeoTIFF cargado en ArrayBuffer. Intentando parsear GeoRaster...");
                          // *** Intentar acceder a parseGeoraster de forma segura ***
                          let parseFn = undefined;

                          // Esperamos que parseGeoraster esté globalmente disponible con el paquete browser.bundle
                          if (typeof parseGeoraster !== 'undefined') { // Ámbito global
                               parseFn = parseGeoraster;
                               console.log("parseFn encontrado en ámbito global.");
                          } else if (typeof window.GeoRaster !== 'undefined' && typeof window.GeoRaster.parseGeoRaster === 'function') {
                               // Bajo window.GeoRaster (nombre común)
                               parseFn = window.GeoRaster.parseGeoRaster;
                               console.log("parseFn encontrado bajo window.GeoRaster.");
                          } else if (typeof window.georaster !== 'undefined' && typeof window.georaster.parseGeoRaster === 'function') {
                               // Bajo window.georaster (nombre común en minúsculas)
                               parseFn = window.georaster.parseGeoRaster;
                               console.log("parseFn encontrado bajo window.georaster.");
                          } else if (typeof window.GeoRasterLayer !== 'undefined' && typeof window.GeoRasterLayer.parseGeoRaster === 'function') {
                               // A veces, la función de parseo está adjunta al constructor de la capa
                               parseFn = window.GeoRasterLayer.parseGeoRaster;
                               console.log("parseFn encontrado bajo window.GeoRasterLayer.");
                           }


                         if (typeof parseFn === 'undefined') {
                              // Si no se encuentra
                               console.error("parseGeoRaster (o similar) no definido en las ubicaciones esperadas.");
                               console.log("Contenido de window.GeoRaster para depuración:", typeof window.GeoRaster !== 'undefined' ? window.GeoRaster : 'undefined');
                               console.log("Contenido de window.georaster para depuración:", typeof window.georaster !== 'undefined' ? window.georaster : 'undefined');
                               console.log("Contenido de window.GeoRasterLayer para depuración:", typeof window.GeoRasterLayer !== 'undefined' ? window.GeoRasterLayer : 'undefined');

                               // Debugging: If GeoRasterLayer is defined, inspect its properties to see what's there.
                               if (typeof window.GeoRasterLayer !== 'undefined') {
                                    console.log("Propiedades de window.GeoRasterLayer para depuración:", Object.keys(window.GeoRasterLayer));
                                    // Also check the prototype properties if it's a class/constructor
                                     if (window.GeoRasterLayer.prototype) {
                                         console.log("Propiedades del prototipo de window.GeoRasterLayer:", Object.keys(window.GeoRasterLayer.prototype));
                                     }
                               }


                               const error = new Error("Librería GeoRaster no cargada correctamente o parseFn no encontrado.");
                               loadingStatusDiv.textContent = `Error cargando ${layerName}: parseFn no encontrado.`;
                               return Promise.reject(error); // Rechazar la promesa para que Promise.all falle
                         }

                         // Usar la función parseFn encontrada
                         return parseFn(arrayBuffer); // Esto devuelve una Promise

                     })
                     .then(georaster => {
                         console.log("GeoRaster de elevación parseado con éxito:", georaster);
                          // Verificar que GeoRasterLayer esté cargado antes de usarlo
                           if (typeof GeoRasterLayer === 'undefined') {
                                const error = new Error("Librería GeoRasterLayer no cargada correctamente.");
                                 console.error(`Error cargando ${layerName}: ${error.message}`);
                                 loadingStatusDiv.textContent = `Error cargando ${layerName}: GeoRasterLayer no encontrado.`;
                                 return Promise.resolve({ name: layerName, georaster: georaster, layer: null, error: error }); // Resolver, pero con error
                           }

                          // Crear la capa de Leaflet a partir del objeto GeoRaster.
                          // georaster-layer-for-leaflet usa proj4js para re-proyectar al vuelo.
                          const layer = new GeoRasterLayer({
                              georaster: georaster,
                              opacity: opacity,
                              // pixelValuesToColorFn: ... // Puedes añadir estilo aquí
                              // range: ...
                              // colors: ...
                          });
                          console.log(`${layerName} cargado con éxito.`);
                          return { name: layerName, georaster: georaster, layer: layer, error: null }; // Devolver info y el objeto georaster
                     })
                     .catch(error => {
                          console.error(`Error cargando y parseando GeoTIFF de ${layerName} desde ${url}:`, error);
                           loadingStatusDiv.textContent = `Error cargando ${layerName}.`;
                           // No alertar por cada error individual
                           return { name: layerName, georaster: null, layer: null, error: error }; // Indicar error
                     });
             }


            // --- Carga automática de datos al cargar la página ---
            document.addEventListener('DOMContentLoaded', function() {
                console.log("El DOM está cargado. Iniciando carga automática de datos geoespaciales.");
                console.log("Estado de exclusionFeatures global al inicio del DOMContentLoaded:", window.exclusionFeatures ? window.exclusionFeatures.length : 'undefined/null');
                loadingStatusDiv.textContent = 'Cargando datos...';
                generarPasadasBtn.disabled = true; // Asegurarse de que esté deshabilitado durante la carga


                // *** URLs de TUS ARCHIVOS EN GITHUB RAW ***
                // ** IMPORTANTE: Para evitar errores CORS, asegúrate de que tu página HTML también se sirve desde un servidor web (no abrir directamente desde file:///...). **
                // ** Las URLs raw.githubusercontent.com suelen permitir CORS si la página se sirve vía http/https. **
                const parcelasGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/JSON/main/PARCELA.geojson'; // URL DE PARCELAS (seleccionable)
                const construccionesGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/parcela/main/CONSTRU.json'; // URL DE CONSTRUCCIONES (exclusión)
                const elementosInternosGeojsonDataUrl = 'https://raw.githubusercontent.com/tinajita/parcela/main/ELEMLIN.json'; // URL DE ELEMENTOS INTERNOS (exclusión - puede necesitar buffer)
                const mdtUrl = 'https://raw.githubusercontent.com/tinajita/parcela/main/MDT25-ETRS89-H30-1051-1-COB2.tif'; // URL del GeoTIFF COG de elevación (0.93 MB)
                const contourLinesUrl = 'https://raw.githubusercontent.com/tinajita/parcela/main/BTN0201L_CUR_NIV.json'; // URL del GeoJSON de curvas de nivel simplificadas (aprox 6.32 MB)
                // *** FIN URLs ***

                const units = 'meters'; // Unidades para Turf.js (buffer)
                const bufferDistanceForLines = 2; // Define una distancia de buffer adecuada en metros para LineStrings de ELEMLIN.json


                // Usar Promise.all para cargar todos los archivos concurrentemente
                Promise.all([
                    loadGeoJSONLayer(parcelasGeojsonDataUrl, 'Mis Parcelas', { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 }, { // Añadir opciones para loadGeoJSONLayer con onEachFeature
                         onEachFeature: (feature, layer) => { // Lógica onEachFeature para la selección de parcela al hacer clic
                             const defaultStyle = { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 };
                             originalStyle[layer._leaflet_id] = defaultStyle; // Guardar el estilo por defecto

                             layer.on({
                                 click: e => {
                                     // Limpiar selección anterior y estilo
                                     if (selectedLayer) {
                                         // Restaurar estilo original o un estilo por defecto si no se guardó
                                         const styleToRestore = originalStyle[selectedLayer._leaflet_id] || { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 };
                                         selectedLayer.setStyle(styleToRestore);
                                     }
                                     layer.setStyle({ color: '#00FFFF', weight: 3, fillColor: '#00FFFF', fillOpacity: 0.3 }); // Estilo de selección
                                     selectedLayer = layer; // Guarda la referencia a la capa Leaflet seleccionada

                                     // Habilitar botón solo si la parcela es válida Y los datos clave ya cargaron
                                     // Verificamos si elevationGeoRaster y contourLinesGeoJSON existen para asegurar datos clave.
                                     if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') && elevationGeoRaster && contourLinesGeoJSON) {
                                          generarPasadasBtn.disabled = false;
                                     } else {
                                          generarPasadasBtn.disabled = true;
                                          if (!(feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                                               console.warn("La feature seleccionada no es poligonal. Botón de generar pasadas deshabilitado.");
                                          }
                                           if (elevationGeoRaster === null) { // Usar null check explícito
                                               console.warn("Faltan datos de elevación. Botón de generar pasadas deshabilitado.");
                                           }
                                            if (contourLinesGeoJSON === null || !contourLinesGeoJSON.features) { // Usar null/features check explícito
                                                console.warn("Faltan datos de curvas de nivel. Botón de generar pasadas deshabilitado.");
                                            }
                                     }


                                     console.log("Parcela seleccionada (desde click):", feature.properties);
                                     // Acercar el mapa SOLO si la capa tiene bounds válidos
                                     if (layer.getBounds && layer.getBounds().isValid()) {
                                           map.fitBounds(layer.getBounds()); // Acercar el mapa
                                     } else if (layer.getLatLng) { // Si es un punto
                                           map.setView(layer.getLatLng(), 16); // Acercar a un punto con un zoom fijo
                                     }

                                     L.DomEvent.stopPropagation(e);
                                 }
                             });
                              // Guardar el estilo por defecto inicial para las opciones del selector (aunque no haya selector, la lógica lo usa al deseleccionar)
                             if (!originalStyle[layer._leaflet_id]) {
                                  originalStyle[layer._leaflet_id] = { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 };
                             }
                         }
                    }),
                    loadGeoJSONLayer(construccionesGeojsonDataUrl, 'Construcciones', { color: 'red', weight: 2, opacity: 0.7, fillOpacity: 0.3 }),
                    loadGeoJSONLayer(elementosInternosGeojsonDataUrl, 'Viales y Arroyos', { // Estilo adaptado para líneas/polígonos
                               style: feature => {
                                    if (feature.geometry && feature.geometry.type === 'LineString') {
                                         return { color: '#0000FF', weight: 2, opacity: 0.8 };
                                    } else if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                                         return { color: '#006400', weight: 1, fillColor: '#006400', fillOpacity: 0.3 };
                                    }
                                    return { color: '#888888', weight: 1, opacity: 0.5 };
                               }
                            }),
                    loadGeoTIFFLayer(mdtUrl, 'Elevación (MDT25)', 0.5), // Cargar el GeoTIFF
                    loadGeoJSONLayer(contourLinesUrl, 'Curvas de Nivel', { color: '#888', weight: 1, opacity: 0.7 }) // Cargar Curvas de Nivel GeoJSON
                ])
                .then(results => {
                    console.log("Resultados de carga de Promise.all:", results);
                    let allKeyDataLoadedSuccessfully = true; // Bandera para verificar si todos los archivos clave cargaron sin error

                    // Limpiar features de exclusión global existentes antes de repoblar
                     window.exclusionFeatures = [];

                    // Procesar los resultados de la carga
                     results.forEach(result => {
                         if (result.error) {
                              allKeyDataLoadedSuccessfully = false;
                              // El error ya fue loggeado en la función de carga.
                              // Podemos mostrar un mensaje de error general al final si allKeyDataLoadedSuccessfully es false
                         } else {
                             // Si la carga fue exitosa, procesar y añadir la capa al mapa/control
                             if (result.name === 'Mis Parcelas') {
                                 parcelasLayer = result.layer;
                                 parcelasGeoJSON = result.data;
                                 if (parcelasGeoJSON && parcelasGeoJSON.features) {
                                     // populateSelect('parcel-select', parcelasGeoJSON, 'CODIGO'); // Eliminamos el populateSelect
                                      // Añadir la capa de Parcelas al mapa
                                     if (parcelasLayer) {
                                          parcelasLayer.addTo(map);
                                           overlayLayers["Mis Parcelas"] = parcelasLayer;
                                           // Asegurarse de que el estilo original se guarda para cada capa de parcela
                                            if (parcelasGeoJSON.features) {
                                                parcelasGeoJSON.features.forEach((feature, index) => {
                                                     // Find the corresponding Leaflet layer by its feature reference or properties if needed
                                                    parcelasLayer.eachLayer(layer => {
                                                        if (layer.feature === feature) {
                                                            // Guarda el estilo inicial por defecto si aún no se ha guardado (la lógica click lo haría)
                                                            if (!originalStyle[layer._leaflet_id]) {
                                                                 originalStyle[layer._leaflet_id] = { color: '#000000', weight: 1, fillColor: '#ffffff', fillOpacity: 0.0 };
                                                                 console.log(`Guardado estilo por defecto para parcela ${feature.properties.CODIGO}`);
                                                             }
                                                        }
                                                    });
                                                });
                                            }


                                      } else { console.warn("La capa de Parcelas no se pudo crear."); allKeyDataLoadedSuccessfully = false; } // Ya se marcó el error general arriba
                                 } else { allKeyDataLoadedSuccessfully = false; console.error("Datos de Parcelas nulos o sin features."); } // Ya se marcó el error general arriba
                             } else if (result.name === 'Construcciones') {
                                  construccionesLayer = result.layer;
                                  // Recopilar geometrías de exclusión (Polygon/MultiPolygon) si los datos son válidos
                                  if (result.data && result.data.features) {
                                      result.data.features.forEach(feature => {
                                          if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                                              window.exclusionFeatures.push(JSON.parse(JSON.stringify(feature)));
                                          }
                                      });
                                       // Añadir capa al mapa y control
                                      if (construccionesLayer) {
                                           construccionesLayer.addTo(map);
                                            overlayLayers["Construcciones"] = construccionesLayer;
                                      } else { console.warn("La capa de Construcciones no se pudo crear."); }
                                  } else { console.warn("Datos de Construcciones nulos o vacíos."); }
                             } else if (result.name === 'Viales y Arroyos') {
                                  elementosInternosLayer = result.layer;
                                  // Recopilar geometrías de exclusión (LineString -> Buffer, Polygon/MultiPolygon) si los datos son válidos
                                   if (result.data && result.data.features) {
                                       result.data.features.forEach(feature => {
                                           if (feature.geometry) {
                                               if (feature.geometry.type === 'LineString') {
                                                    try {
                                                        // Asegurarse de que turf está cargado antes de buffer
                                                        if (typeof turf !== 'undefined') {
                                                             const buffered = turf.buffer(feature, bufferDistanceForLines, {units: units});
                                                              // El buffer puede producir un FeatureCollection si el input es multi-geometría, o null si falla
                                                              if (buffered && buffered.features && buffered.features.length > 0) {
                                                                   // Si es FeatureCollection, añadir las geometrías resultantes
                                                                   buffered.features.forEach(bf => {
                                                                        if(bf.geometry && (bf.geometry.type === 'Polygon' || bf.geometry.type === 'MultiPolygon')) {
                                                                             window.exclusionFeatures.push(JSON.parse(JSON.stringify(bf)));
                                                                        } else { console.warn("Buffer de LineString produjo feature no poligonal:", bf); }
                                                                   });
                                                              } else if (buffered && buffered.geometry && (buffered.geometry.type === 'Polygon' || buffered.geometry.type === 'MultiPolygon')) {
                                                                   // Si es un solo Feature con Polygon/MultiPolygon
                                                                    window.exclusionFeatures.push(JSON.parse(JSON.stringify(buffered)));
                                                              }
                                                              else {
                                                                   console.warn("Buffer de LineString no válido para exclusión (no FeatureCollection ni Feature válido):", feature, buffered);
                                                              }
                                                        } else { console.error("Turf.js no cargado para buffer de Linea."); }

                                                    } catch(e) { console.error("Error buffer LineString:", e); }
                                               } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                                                    window.exclusionFeatures.push(JSON.parse(JSON.stringify(feature)));
                                               }
                                           }
                                       });
                                        // Añadir capa al mapa y control (el estilo ya maneja LineString y Polygon)
                                       if (elementosInternosLayer) {
                                            elementosInternosLayer.addTo(map);
                                            overlayLayers["Viales y Arroyos"] = elementosInternosLayer;
                                       } else { console.warn("La capa de Viales y Arroyos no se pudo crear."); }
                                   } else { console.warn("Datos de Viales y Arroyos nulos o vacíos."); }
                             } else if (result.name === 'Elevación (MDT25)') {
                                 elevationGeoRaster = result.georaster; // Almacenar el objeto georaster
                                  if (result.layer) { // Asegurarse de que la capa Leaflet se creó
                                      overlayLayers["Elevación (MDT25)"] = result.layer; // Añadir capa al control
                                      result.layer.addTo(map); // Añadir al mapa
                                  } else { console.warn("La capa Leaflet de Elevación no se pudo crear."); allKeyDataLoadedSuccessfully = false; }
                                 if (typeof elevationGeoRaster === 'undefined' || elevationGeoRaster === null) { console.warn("Objeto georaster de elevación nulo después de la carga."); allKeyDataLoadedSuccessfully = false; } // Ya se marcó el error general arriba
                             } else if (result.name === 'Curvas de Nivel') {
                                 contourLinesGeoJSON = result.data; // Almacenar los datos GeoJSON de curvas de nivel
                                   if (result.layer) { // Asegurarse de que la capa Leaflet se creó
                                        overlayLayers["Curvas de Nivel"] = result.layer; // Añadir capa al control
                                        result.layer.addTo(map); // Añadir al mapa
                                   } else { console.warn("La capa Leaflet de Curvas de Nivel no se pudo crear."); allKeyDataLoadedSuccessfully = false; }
                                  if (typeof contourLinesGeoJSON === 'undefined' || contourLinesGeoJSON === null || !contourLinesGeoJSON.features) { console.warn("Datos GeoJSON de Curvas de Nivel nulos o sin features."); allKeyDataLoadedSuccessfully = false; } // Ya se marcó el error general arriba
                             }

                              // Las capas de Construcciones, Viales, Elevación y Curvas de Nivel se añaden
                              // dentro de sus respectivos bloques if/else if arriba si se crearon correctamente.
                              // La capa de Parcelas también se añade arriba.

                         }
                     });

                     console.log(`Total features de exclusión recopiladas: ${window.exclusionFeatures.length}`);
                     console.log("Estado de exclusionFeatures global DESPUÉS de la carga:", window.exclusionFeatures.length, window.exclusionFeatures);


                    // Actualizar el control de capas final
                    console.log("Intentando llamar a updateLayersControl..."); // Debug log antes de llamar
                    updateLayersControl();
                    console.log("Called updateLayersControl after Promise.all"); // Debug log después de llamar


                    // Ajustar la vista del mapa a la extensión de las Parcelas si se cargaron
                    if (parcelasLayer && parcelasLayer.getBounds().isValid()) {
                         map.fitBounds(parcelasLayer.getBounds());
                    } else {
                         console.warn("No se pudieron obtener bounds válidos de la capa de parcelas. Ajustando vista a Ronda...");
                          map.setView([36.7462, -5.1612], 14); // Fallback
                    }

                     // El botón generarPasadasBtn.disabled se controla en el evento 'click' de la capa de parcelas
                     // si los datos clave (GeoJSON de parcelas, elevationGeoRaster, contourLinesGeoJSON) se cargaron con éxito.
                    if (allKeyDataLoadedSuccessfully && parcelasGeoJSON && elevationGeoRaster && contourLinesGeoJSON) {
                         loadingStatusDiv.textContent = 'Datos cargados. Haz clic en una parcela.';
                         console.log("Carga automática de datos clave finalizada con éxito. Esperando clic en parcela.");
                     } else {
                          loadingStatusDiv.textContent = 'Carga de datos completada con errores. No se pueden generar pasadas.';
                          console.error("La carga automática de datos finalizó con datos clave faltantes. El botón de generar pasadas permanecerá deshabilitado.");
                           // Alertar si faltan datos clave
                           if (!parcelasGeoJSON) console.error("Error: No se pudieron cargar los datos de Parcelas."); // Solo log si ya se intentó cargar
                           if (elevationGeoRaster === null) console.error("Error: No se pudieron cargar los datos de Elevación (MDT)."); // Solo log si ya se intentó cargar
                           if (contourLinesGeoJSON === null || !contourLinesGeoJSON.features) console.error("Error: No se pudieron cargar los datos de Curvas de Nivel."); // Solo log si ya se intentó cargar

                          alert("Error: No se pudieron cargar todos los datos necesarios (Parcelas, Elevación o Curvas de Nivel). Revisa la consola para detalles. No se pueden generar pasadas.");
                     }


                })
                .catch(error => {
                     // Este catch se ejecutará si Promise.all falla catastróficamente,
                     // pero los errores individuales ya se manejan en cada función de carga.
                    console.error("Error inesperado en Promise.all durante la carga de datos:", error);
                    loadingStatusDiv.textContent = `Error crítico durante la carga: ${error.message}`;
                    alert(`Ocurrió un error crítico durante la carga de datos. Revisa la consola para detalles.`);
                });
            });


             // Eliminamos la función populateSelect y el manejo del evento 'change' del selector,
             // volviendo a la selección de parcela por clic en el mapa, como en tu código "bueno".
             // La lógica onEachFeature para el click ya está incluida en la carga de la capa de parcelas.


            // --- LÓGICA PARA GENERAR PASADAS OPTIMIZADAS USANDO TURF.JS Y DATOS DE ELEVACIÓN/CURVAS ---

            generarPasadasBtn.addEventListener('click', function() {

                // --- VERIFICACIÓN DE TURF ---
                console.log("Estado de 'turf' al hacer clic en Generar Pasadas:", typeof turf);
                if (typeof turf === 'undefined') {
                    console.error("Error: La biblioteca Turf.js no se cargó correctamente.");
                    alert("Error: La biblioteca Turf.js no está disponible. No se pueden generar pasadas. Revisa la consola.");
                    return;
                }
                // --- FIN VERIFICACIÓN ---

                console.log("--- Inicio Generación de Pasadas ---");

                // --- Verificar que los datos necesarios estén cargados y que hay una parcela seleccionada ---
                // La verificación de turf ya se hizo.
                 // selectedLayer ya debe existir y ser poligonal gracias a la lógica de selección y habilitación del botón.
                 if (!selectedLayer || !selectedLayer.feature || !selectedLayer.feature.geometry || (selectedLayer.feature.geometry.type !== 'Polygon' && selectedLayer.feature.geometry.type !== 'MultiPolygon')) {
                      // Esto no debería ocurrir si el botón está bien controlado, pero es una verificación de seguridad.
                      console.error("Error interno: Botón habilitado sin parcela poligonal seleccionada.");
                      alert("Error interno: No hay una parcela poligonal válida seleccionada.");
                      return;
                  }

                 // Verificar que los datos clave para la lógica de elevación/curvas están disponibles
                 if (typeof elevationGeoRaster === 'undefined' || elevationGeoRaster === null) {
                     console.error("Los datos de elevación (MDT) no están disponibles.");
                     alert("Los datos de elevación (MDT) no se cargaron correctamente. No se puede generar pasadas sensibles al terreno.");
                     return;
                 }
                 if (typeof contourLinesGeoJSON === 'undefined' || contourLinesGeoJSON === null || !contourLinesGeoJSON.features) {
                     console.error("Los datos de curvas de nivel no están disponibles.");
                     alert("Los datos de curvas de nivel no se cargaron correctamente. No se puede generar pasadas sensibles al terreno.");
                     return;
                 }


                const selectedParcelGeoJSON = selectedLayer.toGeoJSON();
                let parcelGeometry = selectedParcelGeoJSON.geometry; // Geometría de la parcela seleccionada
                const parcelFeature = turf.feature(parcelGeometry); // La parcela como feature para intersecciones

                generatedPassesLayer.clearLayers(); // Limpiar pasadas anteriores
                console.log("Limpiando pasadas generadas anteriormente.");

                // --- Obtener el ancho de trabajo del input ---
                const workingWidth = parseFloat(workingWidthInput.value);
                if (isNaN(workingWidth) || workingWidth <= 0) {
                     alert("Por favor, introduce un valor válido y positivo para el ancho de trabajo.");
                     console.error("Valor inválido para ancho de trabajo:", workingWidthInput.value);
                     return;
                }
                // --- Fin Obtener ancho de trabajo ---

                const units = 'meters'; // Unidades para Turf.js

                // *** UMBRAL DE PENDIENTE ***
                // Define aquí el porcentaje de pendiente a partir del cual el tractor debe seguir las curvas de nivel.
                const slopeThresholdPercent = 10; // Ejemplo: 10% de pendiente. AJUSTA ESTE VALOR.
                console.log(`Umbral de pendiente para cambio de lógica: ${slopeThresholdPercent}%`);


                try {
                    // window.exclusionFeatures ya contiene las geometrías de exclusión cargadas globalmente
                    let intersectingExclusionFeatures = []; // Array para almacenar las FEATURES de exclusión que INTERSECTAN
                     const globalExclusionFeatures = window.exclusionFeatures || []; // Acceder a la variable global

                    // --- Lógica para obtener features de exclusión que intersectan con la parcela seleccionada ---
                     if (globalExclusionFeatures.length > 0) {
                         console.log(`Total features de exclusión cargadas globalmente: ${globalExclusionFeatures.length}`);
                         console.log(`Filtrando features de exclusión para encontrar las que intersectan con la parcela seleccionada.`);
                          globalExclusionFeatures.forEach((exclusionFeature, index) => {
                              // exclusionFeature ya debe ser un Feature con Polígono/MultiPolígono (buffers si eran LineString)
                             if (exclusionFeature.geometry && (exclusionFeature.geometry.type === 'Polygon' || exclusionFeature.geometry.type === 'MultiPolygon')) {
                                  try {
                                       // Asegúrate de que la parcela seleccionada también sea una Feature válida para la intersección
                                       if (parcelFeature && parcelFeature.geometry && (parcelFeature.geometry.type === 'Polygon' || parcelFeature.geometry.type === 'MultiPolygon')) {
                                          // booleanIntersects verifica si las geometrías se tocan o se cruzan.
                                          if (turf.booleanIntersects(parcelFeature, exclusionFeature)) {
                                             // Si intersecta, añadir la FEATURE COMPLETA a la lista de exclusiones que intersectan
                                             intersectingExclusionFeatures.push(exclusionFeature); // Añadir la FEATURE
                                          }
                                       } else {
                                            console.warn("Parcela seleccionada no es una Feature válida para verificar intersección. Se omitirán todas las exclusiones.");
                                            // Romper el bucle o manejar la lógica de otra forma si la parcela no es válida
                                       }
                                  } catch (e) {
                                      console.warn(`Error al verificar intersección para feature de exclusión #${index}. Se omitirá.`, exclusionFeature, e);
                                  }
                             } else {
                                  console.warn(`Geometría de feature de exclusión #${index} (${exclusionFeature.geometry ? exclusionFeature.geometry.type : 'null/undefined'}) no es Polígono/MultiPolígono válido para intersección. Se omitirá.`, exclusionFeature);
                             }
                          });
                     } else {
                         console.log("No se cargaron features de exclusión globalmente (window.exclusionFeatures está vacío).");
                     }
                    console.log(`Features de exclusión que intersectan con la parcela: ${intersectingExclusionFeatures.length}`);


                    // --- Simplificar ligeramente las features de exclusión que intersectan ---
                     let simplifiedExclusionFeatures = [];
                     if (intersectingExclusionFeatures.length > 0) {
                         const tinySimplificationTolerance = 0.000001; // Tolerance en grados (CRS 4326)
                         console.log(`Aplicando mínima simplificación (${tinySimplificationTolerance} grados) a ${intersectingExclusionFeatures.length} features de exclusión que intersectan.`);
                         simplifiedExclusionFeatures = intersectingExclusionFeatures.map(feature => {
                               try {
                                    // Asegurarse de que la feature de exclusión sea un tipo geométrico que Turf.simplify pueda manejar
                                     if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                                          const simplified = turf.simplify(feature, { tolerance: tinySimplificationTolerance, highQuality: true });

                                          // Verificar si el resultado de simplify es una Feature válida con geometría
                                          if (simplified && simplified.geometry) {
                                               // turf.simplify puede devolver GeometryCollection, Polígono, o MultiPolígono.
                                               // Necesitamos asegurarnos de que sea un tipo de geometría que podamos usar para turf.union/difference.
                                               // La lógica para manejar GeometryCollection después de union/difference es más compleja,
                                               // así que idealmente simplified debería ser Polygon o MultiPolygon.
                                               // Si el resultado es GeometryCollection, intentamos "aplanar" o consolidar si es posible,
                                               // pero para una simplificación MÍNIMA, suele ser Polygon/MultiPolygon.
                                               if (simplified.geometry.type === 'Polygon' || simplified.geometry.type === 'MultiPolygon') {
                                                     // Opcional: verificar área > 0 después de simplificar si la simplificación extrema podría colapsar geometrías
                                                      if (turf.area(simplified) > 0) {
                                                          return simplified; // Devuelve el Feature simplificado
                                                      } else {
                                                           console.warn("Simplificación mínima: Resultado Polygon/MultiPolygon tiene área 0. Se omitirá.", simplified);
                                                          return null;
                                                      }

                                               } else {
                                                    console.warn(`Simplificación mínima: turf.simplify devolvió tipo de geometría inesperado (${simplified.geometry.type}). Se omitirá para la diferencia.`, simplified);
                                                    // Podrías intentar procesar GeometryCollection aquí si es necesario, pero complica la lógica
                                                    return null;
                                               }
                                          } else {
                                                console.warn("Simplificación mínima: turf.simplify devolvió un resultado nulo o sin geometría. Se omitirá.", simplified);
                                                return null;
                                          }

                                     } else {
                                          console.warn(`Simplificación mínima: La feature de exclusión no es Polygon/MultiPolygon para simplificar. Se omitirá.`, feature);
                                          return null;
                                     }

                               } catch (e) {
                                    console.error("Error durante la simplificación mínima de una feature de exclusión:", feature, e);
                                    console.warn("Simplificación mínima fallida para feature de exclusión. Se omitirá.");
                                    return null;
                               }
                           }).filter(feature => feature !== null); // Filtrar los resultados nulos

                           console.log(`Quedan ${simplifiedExclusionFeatures.length} features de exclusión VÁLIDAS (Polygon/MultiPolygon) después de la mínima simplificación.`);

                     } else {
                          console.log("No hay features de exclusión que intersecten para simplificar.");
                     }


                    // --- Calcular el área limpia (Parcela - Unión/Feature única de ExclusionFeatures simplificadas) ---
                    let geometryForCalculations = parcelGeometry; // Inicialmente es la geometría original de la parcela
                    let unionOfExclusionsFeature = null; // Almacenar la Feature resultante de la unión de exclusiones

                    if (simplifiedExclusionFeatures.length === 0) {
                         console.log("No hay features de exclusión simplificadas válidas para restar de la parcela.");
                         // geometryForCalculations se mantiene como parcelGeometry
                     } else if (simplifiedExclusionFeatures.length === 1) {
                         console.log("Solo 1 feature de exclusión simplificada. Usando esta directamente para la diferencia.");
                         unionOfExclusionsFeature = simplifiedExclusionFeatures[0];
                         // Asegurarse de que la única feature sea Polygon/MultiPolygon antes de usarla
                         if (!(unionOfExclusionsFeature.geometry && (unionOfExclusionsFeature.geometry.type === 'Polygon' || unionOfExclusionsFeature.geometry.type === 'MultiPolygon'))) {
                              console.warn("La única feature de exclusión simplificada no es Polígono/MultiPolígono válido para la diferencia. No se restará.");
                              unionOfExclusionsFeature = null; // Invalidar si no es válido
                         }

                     } else { // simplifiedExclusionFeatures.length > 1
                          console.log(`Más de 1 feature de exclusión simplificada (${simplifiedExclusionFeatures.length}). Calculando unión para la diferencia.`);
                         try {
                             // Calcular la unión de todas las features de exclusión simplificadas
                             // turf.union espera features individuales como argumentos
                             unionOfExclusionsFeature = turf.union(...simplifiedExclusionFeatures);

                              if (unionOfExclusionsFeature && unionOfExclusionsFeature.geometry) {
                                   // Verificar que el resultado de la unión sea un tipo de geometría útil (Polygon, MultiPolygon)
                                   // Aunque turf.union puede devolver GeometryCollection, turf.difference no lo maneja directamente.
                                   // Si el resultado es GeometryCollection, turf.difference puede fallar o dar resultados inesperados.
                                   if (!(unionOfExclusionsFeature.geometry.type === 'Polygon' || unionOfExclusionsFeature.geometry.type === 'MultiPolygon')) {
                                       console.warn(`El resultado de turf.union tiene geometría (${unionOfExclusionsFeature.geometry.type}), pero no es Polygon o MultiPolygon. Esto podría causar problemas en turf.difference.`, unionOfExclusionsFeature);
                                        // Considerar cómo manejar GeometryCollection aquí si es necesario, puede requerir lógica adicional
                                        // Por ahora, si no es Polygon/MultiPolygon, se procederá con la diferencia, pero con advertencia.
                                   }
                                   console.log(`Unión de exclusiones calculada. Tipo de geometría resultante: ${unionOfExclusionsFeature.geometry.type}.`);
                              } else {
                                   console.warn("El resultado de turf.union fue nulo o no tiene geometría. No se podrán restar exclusiones.");
                                   unionOfExclusionsFeature = null; // Asegurarse de que sea nulo si la unión falló
                              }

                         } catch (e) {
                             console.error("Error durante turf.union de exclusiones simplificadas:", e);
                             console.warn("Ocurrió un error al calcular la unión de áreas a evitar. No se podrán restar exclusiones.");
                             unionOfExclusionsFeature = null; // Asegurarse de que sea nulo si falló
                         }
                     }

                     // Realizar la diferencia si se obtuvo una Feature de unión válida
                     if (unionOfExclusionsFeature) {
                         console.log(`Realizando diferencia: Parcela - Unión de Exclusiones.`);
                          try {
                               // Asegurarse de que tanto la parcela como la unión de exclusiones sean Features para turf.difference
                               const parcelFeatureForDifference = turf.feature(parcelGeometry);
                                // Verificar que la unión de exclusiones sea una Feature válida con geometría
                                if (unionOfExclusionsFeature.geometry) {
                                     const cleanedAreaFeature = turf.difference(parcelFeatureForDifference, unionOfExclusionsFeature);

                                     if (cleanedAreaFeature && cleanedAreaFeature.geometry) {
                                          // El resultado de turf.difference puede ser Polygon, MultiPolygon, o incluso GeometryCollection o null si no hay resultado.
                                           const cleanedAreaGeometry = cleanedAreaFeature.geometry;
                                           const areaCalculated = turf.area(cleanedAreaFeature);


                                          if ((cleanedAreaGeometry.type === 'Polygon' || cleanedAreaGeometry.type === 'MultiPolygon' || cleanedAreaGeometry.type === 'GeometryCollection') && areaCalculated > 0) {
                                                // Si es GeometryCollection, necesitamos extraer los polígonos válidos para usar en cálculos posteriores
                                                if (cleanedAreaGeometry.type === 'GeometryCollection') {
                                                     console.warn("El resultado de turf.difference es un GeometryCollection. Intentando extraer polígonos válidos.");
                                                      let validGeometriesInGC = [];
                                                       turf.geomEach(cleanedAreaGeometry, function(geom) {
                                                           if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
                                                               validGeometriesInGC.push(turf.feature(geom));
                                                           }
                                                       });

                                                       if (validGeometriesInGC.length > 0) {
                                                            // Aquí podrías opcionalmente intentar unir los polígonos dentro del GC si necesitas un solo MultiPolygon/Polygon,
                                                            // pero para la lógica de punto en polígono o bbox, usar un MultiPolygon tal cual (si es el tipo) suele ser suficiente.
                                                             if (cleanedAreaGeometry.type === 'MultiPolygon') { // Si el GC contiene MultiPolygon
                                                                 geometryForCalculations = cleanedAreaGeometry; // Usar el MultiPolygon si el GC lo es
                                                                 console.log("GeometryCollection contiene un MultiPolygon válido. Usando este para cálculos.");
                                                             } else if (validGeometriesInGC.length === 1) { // Si solo hay un polígono válido
                                                                  geometryForCalculations = validGeometriesInGC[0].geometry;
                                                                  console.log("GeometryCollection contiene 1 Polígono válido. Usando este para cálculos.");
                                                              } else {
                                                                   // Si hay múltiples polígonos independientes dentro del GC, turf.difference los devuelve así.
                                                                   // Para el barrido, podemos necesitar trabajar con cada polígono individualmente o unirlos.
                                                                   // Por ahora, si es GeometryCollection, lo asignamos directamente y manejamos posibles problemas más adelante.
                                                                   geometryForCalculations = cleanedAreaGeometry;
                                                                   console.warn("GeometryCollection de diferencia contiene múltiples polígonos independientes. La lógica de barrido podría necesitar ajustarse.");
                                                              }
                                                       } else {
                                                            console.warn("GeometryCollection de diferencia no contiene polígonos válidos. Área limpia inválida.");
                                                            geometryForCalculations = parcelGeometry; // Revertir a parcela original si el área limpia no es válida
                                                            alert("Advertencia: El área limpia resultante es inválida. Generando pasadas sobre la parcela completa.");
                                                       }

                                                } else {
                                                     // Si el resultado es directamente Polygon o MultiPolygon y tiene área > 0
                                                     geometryForCalculations = cleanedAreaGeometry;
                                                     console.log(`Área limpia (parcela - exclusiones) calculada con éxito. Tipo: ${geometryForCalculations.type}, Área > 0. Usando para cálculos.`);
                                                }

                                          } else {
                                               console.warn("El área resultante de turf.difference no es un polígono/multipolígono/GC válido o tiene área 0.", cleanedAreaFeature);
                                                geometryForCalculations = parcelGeometry; // Revertir a parcela original si el área limpia no es válida o tiene área 0
                                                 if (areaCalculated === 0) {
                                                      console.log("Advertencia: La parcela seleccionada parece estar completamente cubierta por áreas a evitar (área limpia = 0).");
                                                      alert("Advertencia: La parcela seleccionada parece estar completamente cubierta por áreas a evitar. No se pueden generar pasadas útiles.");
                                                      console.log("Revertiendo a geometría original de la parcela según la lógica actual.");
                                                      geometryForCalculations = parcelGeometry;
                                                 } else {
                                                       console.warn("Advertencia: El área limpia resultante no es una geometría válida para generar pasadas.");
                                                       geometryForCalculations = parcelGeometry;
                                                        alert("Advertencia: El área limpia resultante no es una geometría válida para generar pasadas. Generando pasadas sobre la parcela completa.");
                                                 }
                                          }

                                     } else {
                                          console.warn("El resultado de turf.difference no tiene una geometría válida. No se excluirán zonas a evitar.", cleanedAreaFeature);
                                         geometryForCalculations = parcelGeometry; // Revertir a parcela original
                                          alert("Advertencia: El resultado del cálculo de áreas a evitar no es válido. Generando pasadas sobre la parcela completa.");
                                     }
                                } else {
                                     console.warn("La feature de unión de exclusiones no tiene geometría válida. No se excluirán zonas a evitar.");
                                    geometryForCalculations = parcelGeometry; // Revertir a parcela original
                                     alert("Advertencia: La geometría de áreas a evitar no es válida. Generando pasadas sobre la parcela completa.");
                                }

                          } catch (e) {
                                console.error("Error durante el cálculo de diferencia de geometrías:", e);
                                console.warn("Ocurrió un error al excluir zonas a evitar. Usando geometría original de la parcela.");
                                geometryForCalculations = parcelGeometry; // Revertir a parcela original
                                alert("Advertencia: Ocurrió un error al excluir zonas a evitar. Generando pasadas sobre la parcela completa. Revisa la consola.");
                          }
                     } else {
                         console.log("No se pudo obtener una Feature de unión válida para la diferencia. Usando geometría original de la parcela.");
                          // geometryForCalculations se mantiene como parcelGeometry
                     }


                     // VALIDACIONES FINALES del área para pasar
                     if (!geometryForCalculations || !(geometryForCalculations.type === 'Polygon' || geometryForCalculations.type === 'MultiPolygon' || geometryForCalculations.type === 'GeometryCollection')) {
                          console.error("La geometría final para cálculos no es un tipo geométrico válido (Polygon, MultiPolygon, GeometryCollection).");
                          alert("Error: La geometría resultante para generar pasadas es inválida (tipo incorrecto).");
                          return;
                     }
                     try {
                          // Calcular el área total, incluso si es GeometryCollection, sumando las áreas de los polígonos válidos dentro.
                           let totalAreaForCalculations = 0;
                            if (geometryForCalculations.type === 'Polygon' || geometryForCalculations.type === 'MultiPolygon') {
                                 totalAreaForCalculations = turf.area(turf.feature(geometryForCalculations));
                            } else if (geometryForCalculations.type === 'GeometryCollection') {
                                 turf.geomEach(geometryForCalculations, function(geom) {
                                     if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
                                         totalAreaForCalculations += turf.area(turf.feature(geom));
                                     }
                                 });
                            }


                          if (totalAreaForCalculations === 0) {
                               console.error("La geometría final para el barrido tiene área 0.");
                               alert("La geometría resultante del área limpia tiene área cero. No se pueden generar pasadas útiles.");
                               return;
                          }
                           console.log(`Área total calculada de la geometría final para el barrido: ${totalAreaForCalculations.toFixed(2)} m²`);

                     } catch(e) {
                          console.error("Error calculando área de geometría final para barrido:", e);
                           alert("Error verificando el área de la geometría final para el barrido.");
                          return;
                     }

                    // --- SIMPLIFICACIÓN (Aplicar a la geometría que resulte de la exclusión o a la original si falló la exclusión) ---
                     // Simplificar la geometría solo si es Polygon o MultiPolygon, ya que Turf.simplify no maneja GeometryCollection directamente.
                     let finalGeometryToSweep = null;
                     let geometryForPiPCheck = null; // La geometría que usaremos para la verificación Punto-en-Polígono


                    if (geometryForCalculations.type === 'Polygon' || geometryForCalculations.type === 'MultiPolygon') {
                        console.log("Intentando simplificar la geometría final (Polygon/MultiPolygon) para el barrido...");
                        console.log("Geometría ANTES de simplificar:", JSON.stringify(geometryForCalculations));

                        try {
                            const simplificationTolerance = 0.00005; // Tolerance en grados (CRS 4326)

                            const featureToSimplify = turf.feature(geometryForCalculations);

                             if (featureToSimplify && featureToSimplify.geometry) {
                                  const simplifiedFeature = turf.simplify(featureToSimplify, {
                                       tolerance: simplificationTolerance,
                                       highQuality: true // Intenta preservar mejor la forma
                                  });

                                   console.log("Resultado de turf.simplify:", simplifiedFeature ? simplifiedFeature.geometry ? simplifiedFeature.geometry.type : 'no geom' : 'null');


                                   if (simplifiedFeature && simplifiedFeature.geometry && (simplifiedFeature.geometry.type === 'Polygon' || simplifiedFeature.geometry.type === 'MultiPolygon')) {
                                       finalGeometryToSweep = simplifiedFeature.geometry;
                                        // Para el Punto-en-Polígono, usar la geometría simplificada si es válida
                                       geometryForPiPCheck = simplifiedFeature.geometry;
                                       console.log("Geometría final simplificada con éxito. Tipo:", finalGeometryToSweep.type);
                                   } else {
                                        console.warn("El resultado de turf.simplify no es un polígono o multipolígono válido. Usando geometría sin simplificar para el barrido.");
                                        finalGeometryToSweep = geometryForCalculations;
                                        // Para el Punto-en-Polígono, usar la geometría original si la simplificada no es válida
                                        geometryForPiPCheck = geometryForCalculations;
                                         alert("Advertencia: No se pudo simplificar la geometría resultante del área limpia a un tipo válido. Generando pasadas con geometría detallada (puede ser más lento).");
                                   }
                             } else {
                                 console.warn("No se pudo crear una feature válida para simplificar. Usando geometría sin simplificar.");
                                 finalGeometryToSweep = geometryForCalculations;
                                  geometryForPiPCheck = geometryForCalculations;
                                  alert("Advertencia: No se pudo crear Feature para simplificar. Generando pasadas con geometría detallada.");
                             }


                        } catch (e) {
                            console.error("Error durante la simplificación de geometría:", e);
                            console.warn("No se pudo simplificar la geometría final. Usando geometría sin simplificar.");
                            finalGeometryToSweep = geometryForCalculations;
                             geometryForPiPCheck = geometryForCalculations;
                            alert("Advertencia: Ocurrió un error al simplificar la geometría. Generando pasadas con geometría detallada (puede ser más lento). Revisa la consola.");
                        }

                    } else if (geometryForCalculations.type === 'GeometryCollection') {
                         console.warn("La geometría para el barrido es un GeometryCollection. No se puede simplificar directamente con turf.simplify. Se usará el GeometryCollection original para el barrido y la verificación PiP.");
                         finalGeometryToSweep = geometryForCalculations;
                          geometryForPiPCheck = geometryForCalculations; // Usar el GC para PiP
                          alert("Advertencia: El área limpia resultante es compleja (GeometryCollection). La simplificación automática no es posible. Generando pasadas con la geometría original (puede ser más lento/menos preciso).");
                    } else {
                        console.error("Tipo de geometría final para el barrido no soportado para simplificación o barrido:", geometryForCalculations.type);
                         alert("Error: La geometría resultante no es un tipo válido para generar pasadas.");
                         return;
                    }


                    // Asegurarse de que la geometría que se usará para el barrido sea válida antes de continuar
                    if (!finalGeometryToSweep || !finalGeometryToSweep.type) {
                         console.error("La geometría FINAL para el barrido es nula, undefined o de tipo incorrecto.");
                         alert("Error: La geometría final resultante para generar pasadas es inválida.");
                         return;
                    }

                     // Asegurarse de que la geometría para PiP sea válida
                     if (!geometryForPiPCheck || !(geometryForPiPCheck.type === 'Polygon' || geometryForPiPCheck.type === 'MultiPolygon' || geometryForPiPCheck.type === 'GeometryCollection')) {
                          console.error("La geometría FINAL para la verificación Punto-en-Polígono no es de un tipo válido (Polygon, MultiPolygon, GeometryCollection).");
                           alert("Error interno: La geometría para verificaciones internas es inválida.");
                          return;
                     }


                    // --- DETERMINAR DIRECCIÓN Y ROTACIÓN HEURÍSTICA ---
                     // (Mantenemos la lógica heurística de tu código anterior para determinar una dirección general)
                     let centroid = null;
                     try {
                          // Calcular el centroide de la *geometría limpia y simplificada* para usar como pivote de rotación
                          // Asegurarse de que la geometría para el centroide sea válida (Polygon, MultiPolygon)
                           if (finalGeometryToSweep.type === 'Polygon' || finalGeometryToSweep.type === 'MultiPolygon') {
                                centroid = turf.centroid(finalGeometryToSweep);
                                console.log("Centroide del área limpia (simplificada) para rotación:", JSON.stringify(centroid));
                           } else if (finalGeometryToSweep.type === 'GeometryCollection') {
                                // Si es GC, calcular centroide de un FeatureCollection de sus partes poligonales válidas
                                 let validGeomsInGC = [];
                                  turf.geomEach(finalGeometryToSweep, function(geom) {
                                      if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
                                          validGeomsInGC.push(turf.feature(geom));
                                      }
                                  });
                                  if (validGeomsInGC.length > 0) {
                                      centroid = turf.centroid(turf.featureCollection(validGeomsInGC));
                                       console.log("Centroide calculado para GeometryCollection de área limpia (simplificada):", JSON.stringify(centroid));
                                  } else {
                                      console.warn("GeometryCollection de área limpia no contiene polígonos válidos para calcular centroide.");
                                      // Intentar con la parcela original como fallback
                                      try {
                                           centroid = turf.centroid(parcelFeature);
                                            console.warn("Usando centroide de la parcela original como fallback.");
                                      } catch(e2) {
                                           console.error("Error calculando centroide de la parcela original como fallback:", e2);
                                           centroid = null; // Fallback final a null
                                      }
                                  }

                           } else {
                                console.warn(`Tipo de geometría (${finalGeometryToSweep.type}) no soportado para calcular centroide con turf.centroid.`);
                                // Intentar con la parcela original como fallback
                                try {
                                     centroid = turf.centroid(parcelFeature);
                                      console.warn("Usando centroide de la parcela original como fallback.");
                                } catch(e2) {
                                     console.error("Error calculando centroide de la parcela original como fallback:", e2);
                                     centroid = null; // Fallback final a null
                                }
                           }


                          if (!centroid || !centroid.geometry || !centroid.geometry.coordinates) {
                               console.error("Centroide no válido después de los intentos de cálculo.");
                               alert("Error: No se pudo determinar un centroide válido para la rotación.");
                               return;
                          }

                     } catch(e) {
                          console.error("Error general calculando centroide:", e);
                           alert("Error calculando el centroide para la rotación.");
                          return;
                     }


                     let rotationAngle = 0;
                     let sweepDirectionInRotatedSpace = 0; // 0 para barrido N-S (pasadas horizontales), 90 para barrido E-W (pasadas verticales)
                     let heuristicDirectionDescription = "";

                     // Heurística: Usar el ángulo del lado más largo de la PARCELA ORIGINAL si es relativamente rectangular
                     // Si no, usar la orientación de la Bbox de la PARCELA ORIGINAL.
                     // Esto es una HEURÍSTICA para la DIRECCIÓN GENERAL de la pasada en áreas de BAJA PENDIENTE.
                     // La lógica de alta pendiente (seguir curvas de nivel) usará la orientación local de las curvas.

                     let longestSegmentAngle = 0;
                     let foundLongestSegment = false;

                      // Calcular lado más largo en la PARCELA ORIGINAL (parcelGeometry)
                      if (parcelGeometry.type === 'Polygon' && parcelGeometry.coordinates && parcelGeometry.coordinates.length > 0) {
                         const exteriorCoords = parcelGeometry.coordinates[0];
                         if (exteriorCoords && Array.isArray(exteriorCoords) && exteriorCoords.length > 2) {
                              let maxLength = 0;
                              let p1Longest = null;
                              let p2Longest = null;

                              for (let i = 0; i < exteriorCoords.length - 1; i++) {
                                  const p1 = turf.point(exteriorCoords[i]);
                                  const p2 = turf.point(exteriorCoords[i+1]);
                                  try {
                                     const length = turf.distance(p1, p2, {units: units});
                                     if (length > maxLength) {
                                         maxLength = length;
                                         p1Longest = p1;
                                         p2Longest = p2;
                                     }
                                  } catch(e) {
                                     console.warn("Error calculando distancia para segmento en heurística (parcela original):", p1, p2, e);
                                  }
                              }

                              if (p1Longest && p2Longest) {
                                  try {
                                       // El bearing da el ángulo en grados, de -180 a 180. 0 es Norte, 90 Este, 180/ -180 Sur, -90 Oeste.
                                      longestSegmentAngle = turf.bearing(p1Longest, p2Longest);
                                      foundLongestSegment = true;
                                      console.log(`Lado más largo de la parcela original encontrado. Longitud: ${maxLength.toFixed(2)}m, Ángulo (bearing): ${longestSegmentAngle.toFixed(2)}°`);
                                  } catch(e) {
                                       console.warn("Error calculando bearing para lado más largo (parcela original):", p1Longest, p2Longest, e);
                                       foundLongestSegment = false;
                                  }
                              } else {
                                   console.warn("No se encontraron suficientes puntos en el contorno exterior de la parcela original para calcular el lado más largo.");
                              }
                         } else {
                             console.warn("No se pudieron obtener coordenadas exteriores de la parcela original o no hay suficientes puntos.");
                         }
                      } else {
                           console.warn("La geometría original de la parcela no es un polígono simple para encontrar el lado más largo.");
                      }


                     // Calcular rectangularidad de la PARCELA ORIGINAL
                     const useLongestSideThreshold = 0.7; // Umbral de rectangularidad
                     let originalParcelBbox = null;
                     let originalBboxWidthMeters = 0;
                     let originalBboxHeightMeters = 0;
                     let originalParcelArea = 0;
                     let originalBboxArea = 0;
                     let originalRectangularity = 0;

                      try {
                           originalParcelBbox = turf.bbox(parcelGeometry); // Bbox de la parcela ORIGINAL
                           // Calcular ancho y alto del bbox en metros
                           originalBboxWidthMeters = turf.distance(turf.point([originalParcelBbox[0], originalParcelBbox[1]]), turf.point([originalParcelBbox[2], originalParcelBbox[1]]), {units: units});
                           originalBboxHeightMeters = turf.distance(turf.point([originalParcelBbox[0], originalParcelBbox[1]]), turf.point([originalParcelBbox[0], originalParcelBbox[3]]), {units: units});
                            // Calcular área de la parcela ORIGINAL y área del bbox
                            originalParcelArea = turf.area(turf.feature(parcelGeometry));
                            originalBboxArea = originalBboxWidthMeters * originalBboxHeightMeters;
                            // La rectangularidad es la proporción del área de la parcela respecto al área de su bbox
                            originalRectangularity = (originalBboxArea === 0 || originalParcelArea === 0) ? 0 : originalParcelArea / originalBboxArea;

                           console.log(`Dimensiones Bbox original: Ancho ${originalBboxWidthMeters.toFixed(2)}m, Alto ${originalBboxHeightMeters.toFixed(2)}m. Rectangularidad: ${originalRectangularity.toFixed(2)}`);

                      } catch(e) {
                           console.error("Error calculando Bbox o Rectangularidad de la parcela original:", e);
                           originalRectangularity = 0; // Forzar fallback si hay error
                      }


                     // Aplicar la heurística
                     if (foundLongestSegment && originalRectangularity > useLongestSideThreshold) {
                          // Si se encontró un lado largo y la parcela es relativamente rectangular, usar el ángulo de ese lado.
                          // Queremos que las pasadas sean paralelas al lado más largo, es decir, con la misma dirección.
                          // Para rotar la geometría y que el lado más largo quede horizontal (ángulo 0 en el espacio rotado),
                          // debemos rotar por el *opuesto* del ángulo del lado más largo.
                          rotationAngle = -longestSegmentAngle;
                           // En el espacio rotado, las pasadas principales serán horizontales, lo que corresponde a un barrido N-S.
                          sweepDirectionInRotatedSpace = 0; // Barrido N-S
                          heuristicDirectionDescription = `Lado más largo de la parcela original (ángulo original: ${longestSegmentAngle.toFixed(2)}°, rotación aplicada: ${rotationAngle.toFixed(2)}°)`;
                          console.log("Heurística: Usando el lado más largo como dirección principal para pasadas (rotación para que el lado quede horizontal).");

                     } else {
                          // Si no se encontró un lado largo claro o la parcela no es rectangular, usar la orientación de la Bbox original.
                          console.log("Heurística: Parcela irregular o lado largo no determinante. Usando la orientación de la Bbox original.");
                          if (originalBboxWidthMeters >= originalBboxHeightMeters) {
                               // Si la bbox es más ancha que alta, asumir pasadas horizontales en la orientación original (rotación 0).
                               rotationAngle = 0;
                                sweepDirectionInRotatedSpace = 0; // Barrido N-S (para pasadas horizontales)
                                heuristicDirectionDescription = "Bounding Box original más ancha que alta (o igual)";
                                console.log("Bbox original más ancha. Pasadas principales horizontales (rotación 0).");
                          } else {
                               // Si la bbox es más alta que ancha, asumir pasadas verticales en la orientación original.
                               // Para simular esto con un barrido horizontal en el espacio rotado, rotamos 90 grados.
                               rotationAngle = 90; // Rotar 90 grados
                                sweepDirectionInRotatedSpace = 0; // Barrido N-S (para que en el espacio rotado queden horizontales)
                                heuristicDirectionDescription = "Bounding Box original más alta que ancha (rotado 90° para pasadas horizontales en espacio rotado)";
                                console.log("Bbox original más alta. Rotando 90 grados para simular pasadas verticales con barrido horizontal.");
                          }
                     }


                     console.log(`Dirección heurística elegida: ${heuristicDirectionDescription}. Rotando el área limpia por ${rotationAngle.toFixed(2)} grados alrededor del centroide.`);


                     let rotatedGeometryForSweep = null; // Geometría rotada para el barrido y PiP
                     try {
                          // Asegurarse de que la geometría a rotar sea válida (Polygon, MultiPolygon, GeometryCollection)
                           if (finalGeometryToSweep.type === 'Polygon' || finalGeometryToSweep.type === 'MultiPolygon' || finalGeometryToSweep.type === 'GeometryCollection') {
                                // turf.transformRotate puede manejar Polygon, MultiPolygon, Feature, FeatureCollection.
                                // Para GeometryCollection, puede devolver un nuevo GeometryCollection o fallar.
                                // Lo aplicamos a finalGeometryToSweep (que puede ser GC si no se pudo simplificar),
                                // y el resultado (rotatedGeometryForSweep) será la geometría que usamos para el barrido en el espacio rotado.
                                rotatedGeometryForSweep = turf.transformRotate(finalGeometryToSweep, rotationAngle, {pivot: centroid});
                                console.log("Geometría LIMPIA (posiblemente simplificada) y ROTADA para barrido/PiP:", rotatedGeometryForSweep ? rotatedGeometryForSweep.type : 'null/undefined');

                                // Verificar el tipo de geometría resultante de la rotación
                                if (!rotatedGeometryForSweep || !(rotatedGeometryForSweep.type === 'Polygon' || rotatedGeometryForSweep.type === 'MultiPolygon' || rotatedGeometryForSweep.type === 'GeometryCollection')) {
                                     console.error("El resultado de la rotación no es un Polígono, MultiPolígono o GeometryCollection válido.", rotatedGeometryForSweep);
                                      alert("Error: La geometría resultante después de la rotación es inválida.");
                                     return;
                                }
                                // Asegurarse de que la geometría para PiP check sea también válida después de la rotación
                                // Para PiP check, necesitamos una geometría que turf.booleanPointInPolygon pueda manejar (Polygon, MultiPolygon, GeometryCollection)
                                geometryForPiPCheck = rotatedGeometryForSweep;


                           } else {
                                console.error("Tipo de geometría FINAL para el barrido no soportado para rotación:", finalGeometryToSweep.type);
                                alert("Error: La geometría final para generar pasadas no es de un tipo rotatorio válido.");
                                return;
                           }


                     } catch(e) {
                          console.error("Error al rotar la geometría final para el barrido:", e);
                           alert("Error al rotar la geometría para generar pasadas.");
                          return;
                     }


                     // Calcular el Bbox de la geometría ROTADA
                     let rotatedGeometryBbox = null;
                     let rotatedBboxWest = 0, rotatedBboxSouth = 0, rotatedBboxEast = 0, rotatedBboxNorth = 0;

                     try {
                          // Asegurarse de que la geometría rotada sea válida para calcular el bbox
                           if (rotatedGeometryForSweep && (rotatedGeometryForSweep.type === 'Polygon' || rotatedGeometryForSweep.type === 'MultiPolygon' || rotatedGeometryForSweep.type === 'GeometryCollection')) {
                                rotatedGeometryBbox = turf.bbox(turf.feature(rotatedGeometryForSweep)); // turf.bbox espera Feature o GeometryCollection
                                rotatedBboxWest = rotatedGeometryBbox[0];
                                rotatedBboxSouth = rotatedGeometryBbox[1];
                                rotatedBboxEast = rotatedGeometryBbox[2];
                                rotatedBboxNorth = rotatedGeometryBbox[3];
                                 console.log(`Bbox de geometría rotada: [${rotatedBboxWest.toFixed(6)}, ${rotatedBboxSouth.toFixed(6)}, ${rotatedBboxEast.toFixed(6)}, ${rotatedBboxNorth.toFixed(6)}]`);

                           } else {
                                console.error("La geometría rotada no es válida para calcular su Bbox.");
                                alert("Error interno: La geometría rotada es inválida.");
                                return;
                           }

                     } catch(e) {
                          console.error("Error calculando Bbox de la geometría rotada:", e);
                           alert("Error calculando límites de la geometría rotada para generar pasadas.");
                          return;
                     }


                     // Determinar los puntos de inicio y fin para las líneas de barrido en el espacio rotado
                     // y la dirección de muestreo a lo largo de esas líneas (que corresponde a la dirección de la pasada)
                    let rotatedStartSweepCoordValue; // La coordenada (lat o lng) donde empieza el barrido (ej. borde Sur del bbox rotado si es barrido N-S)
                    let rotatedEndSweepCoordValue;   // La coordenada (lat o lng) donde termina el barrido (ej. borde Norte del bbox rotado si es barrido N-S)
                    let rotatedSweepLineStartCoord; // La coordenada (lng o lat) del inicio de la línea de barrido en el espacio rotado (ej. borde Oeste del bbox rotado si es barrido N-S)
                    let rotatedSweepLineEndCoord;   // La coordenada (lng o lat) del fin de la línea de barrido en el espacio rotado (ej. borde Este del bbox rotado si es barrido N-S)
                    let rotatedSweepLineDirection; // La dirección del muestreo a lo largo de la línea de barrido (0 para N-S, 90 para E-W)

                    if (sweepDirectionInRotatedSpace === 0) { // Barrido N-S en espacio rotado (para pasadas horizontales O-E)
                        rotatedStartSweepCoordValue = rotatedBboxSouth; // Empezar barrido desde el borde Sur
                        rotatedEndSweepCoordValue = rotatedBboxNorth;   // Terminar barrido en el borde Norte
                        rotatedSweepLineStartCoord = rotatedBboxWest; // Las líneas de barrido van del Oeste al Este
                        rotatedSweepLineEndCoord = rotatedBboxEast;
                        rotatedSweepLineDirection = 90; // La dirección del muestreo (pasada) es hacia el Este en el espacio rotado

                         console.log("Configurando barrido N->S en espacio rotado para generar pasadas horizontales (O->E).");
                    } else { // Barrido E-W en espacio rotado (para pasadas verticales S-N)
                        rotatedStartSweepCoordValue = rotatedBboxWest; // Empezar barrido desde el borde Oeste
                        rotatedEndSweepCoordValue = rotatedBboxEast;   // Terminar barrido en el borde Este
                        rotatedSweepLineStartCoord = rotatedBboxSouth; // Las líneas de barrido van del Sur al Norte
                        rotatedSweepLineEndCoord = rotatedBboxNorth;
                        rotatedSweepLineDirection = 0; // La dirección del muestreo (pasada) es hacia el Norte en el espacio rotado

                         console.log("Configurando barrido E->W en espacio rotado para generar pasadas verticales (S->N).");
                    }

                     // Calcular la extensión total del barrido (ancho perpendicular a las pasadas) en metros
                    let totalSweepExtentMeters = 0;
                     try {
                         totalSweepExtentMeters = turf.distance(
                             turf.point(sweepDirectionInRotatedSpace === 0 ? [rotatedBboxWest, rotatedBboxSouth] : [rotatedBboxWest, rotatedBboxSouth]),
                             turf.point(sweepDirectionInRotatedSpace === 0 ? [rotatedBboxWest, rotatedBboxNorth] : [rotatedBboxEast, rotatedBboxSouth]),
                             {units: units}
                         );
                         console.log(`Extensión total del barrido en espacio rotado (ancho perpendicular a las pasadas): ${totalSweepExtentMeters.toFixed(2)} ${units}`);

                     } catch(e) {
                         console.error("Error calculando extensión del barrido en bbox rotada:", e);
                          alert("Error calculando límites de la geometría rotada para generar pasadas.");
                         return;
                     }


                    // Definir el offset inicial del barrido (media del ancho de trabajo para centrar la primera pasada)
                    let rotatedCurrentOffset = workingWidth / 2;
                     // Definir la distancia de muestreo a lo largo de cada línea de pasada (ej. cada 1 metro)
                   const samplingDistance = 1; // Distancia de muestreo en metros

                   console.log(`Generando pasadas de ${workingWidth}m en espacio rotado (muestreo de ${samplingDistance}m).`);

                    let generatedRotatedPasses = []; // Array para almacenar los segmentos de pasadas en el espacio rotado


                   if (workingWidth <= 0 || totalSweepExtentMeters <= 0) {
                       console.warn("Ancho de trabajo o extensión del barrido <= 0. No se generarán pasadas.");
                       alert("Ancho de trabajo inválido o área a barrer muy pequeña.");
                       return;
                   } else {
                        // Calcular el límite del barrido con un pequeño margen
                       const sweepLimit = totalSweepExtentMeters + (workingWidth * 0.1); // Barrer un poco más allá de la extensión para asegurar cobertura

                       // Bucle principal para generar pasadas
                       let safetyCounter = 0;
                        // Estimar el número máximo de pasadas posibles para evitar bucles infinitos
                        const maxSweeps = Math.ceil(totalSweepExtentMeters / workingWidth) + 5; // Añadir un margen de seguridad

                       while (rotatedCurrentOffset <= sweepLimit && safetyCounter < maxSweeps) {

                            // Calcular un punto en el eje del barrido (perpendicular a la dirección de la pasada) para este offset
                           let pointOnSweepAxis = null;
                            try {
                                 // El punto de referencia para mover es la esquina Suroeste del bbox rotado
                                 const rotatedBboxSW = turf.point([rotatedBboxWest, rotatedBboxSouth]);
                                // Mover desde la esquina SW en la dirección del barrido por el offset actual
                                pointOnSweepAxis = turf.destination(
                                    rotatedBboxSW,
                                    rotatedCurrentOffset / 1000, // Distancia en kilómetros para turf.destination
                                    sweepDirectionInRotatedSpace, // Dirección del barrido (0 para N-S, 90 para E-W)
                                    {units: 'kilometers'}
                                );
                            } catch(e) {
                                console.error("Error en turf.destination al calcular punto en eje de barrido:", e);
                                // Si falla, saltar a la siguiente iteración incrementando el offset
                                rotatedCurrentOffset += workingWidth;
                                safetyCounter++;
                                continue; // Ir a la siguiente pasada
                            }

                            // Verificar que el punto calculado sea válido
                            if (!pointOnSweepAxis || !pointOnSweepAxis.geometry || !pointOnSweepAxis.geometry.coordinates) {
                                 console.warn(`turf.destination devolvió un punto inválido en offset ${rotatedCurrentOffset.toFixed(2)}m. Saltando esta pasada.`);
                                 rotatedCurrentOffset += workingWidth;
                                 safetyCounter++;
                                 continue; // Ir a la siguiente pasada
                            }


                           // Determinar las coordenadas de inicio y fin de la línea de barrido completa en el espacio rotado para este offset.
                           // Esta línea atraviesa todo el bbox rotado en la dirección de la pasada.
                           let fullSweepLineStartCoords;
                           let fullSweepLineEndCoords;

                            if (sweepDirectionInRotatedSpace === 0) { // Pasadas horizontales (O-E) en espacio rotado
                                // La línea va del Oeste al Este en el valor Y (latitud) del punto calculated
                                fullSweepLineStartCoords = [rotatedBboxWest, pointOnSweepAxis.geometry.coordinates[1]];
                                fullSweepLineEndCoords = [rotatedBboxEast, pointOnSweepAxis.geometry.coordinates[1]];
                            } else { // Pasadas verticales (S-N) en espacio rotado
                                // La línea va del Sur al Norte en el valor X (longitud) del punto calculated
                                fullSweepLineStartCoords = [pointOnSweepAxis.geometry.coordinates[0], rotatedBboxSouth];
                                fullSweepLineEndCoords = [pointOnSweepAxis.geometry.coordinates[0], rotatedBboxNorth];
                            }


                           // Crear la LineString completa que atraviesa el bbox rotado para este offset
                           let fullSweepLineInRotatedSpace = null;
                            try {
                                fullSweepLineInRotatedSpace = turf.lineString([fullSweepLineStartCoords, fullSweepLineEndCoords]);
                            } catch(e) {
                                console.error("Error en turf.lineString al crear línea de barrido completa:", fullSweepLineStartCoords, fullSweepLineEndCoords, e);
                                // Si falla, saltar a la siguiente iteración incrementando el offset
                                rotatedCurrentOffset += workingWidth;
                                safetyCounter++;
                                continue; // Ir a la siguiente pasada
                            }

                            // Verificar que la LineString completa sea válida
                            if (!fullSweepLineInRotatedSpace || !fullSweepLineInRotatedSpace.geometry || fullSweepLineInRotatedSpace.geometry.type !== 'LineString') {
                                 console.warn(`La línea de barrido completa para offset ${rotatedCurrentOffset.toFixed(2)}m no es válida (esperado LineString). Saltando esta pasada.`);
                                 rotatedCurrentOffset += workingWidth;
                                 safetyCounter++;
                                 continue; // Ir a la siguiente pasada
                            }


                           // Calcular la longitud de esta línea de barrido completa
                           let lineLength = 0;
                            try {
                                 lineLength = turf.length(fullSweepLineInRotatedSpace, {units: units});
                            } catch(e) {
                                 console.error("Error en turf.length al calcular longitud de línea de barrido:", e);
                                // Si falla, saltar a la siguiente iteración incrementando el offset
                                rotatedCurrentOffset += workingWidth;
                                safetyCounter++;
                                continue; // Ir a la siguiente pasada
                            }


                           // Muestrear puntos a lo largo de la línea de barrido completa y verificar si están DENTRO del área limpia rotada.
                           let currentSegmentPoints = []; // Almacena los puntos del segmento de pasada actual (dentro del área limpia)

                           for (let i = 0; i <= lineLength; i += samplingDistance) {
                               let point = null;
                               try {
                                    // Obtener el punto a lo largo de la línea de barrido a la distancia 'i'
                                   point = turf.along(fullSweepLineInRotatedSpace, i, {units: units});
                               } catch(e) {
                                   console.warn(`Error en turf.along al muestrear punto a distancia ${i.toFixed(2)}m. Saltando punto.`, e);
                                    // Si falla, intentar continuar con el siguiente punto (si el bucle lo permite)
                                   continue;
                               }

                               // Verificar que el punto muestreado sea válido
                               if (!point || !point.geometry || !point.geometry.coordinates) {
                                    console.warn(`turf.along en distancia ${i.toFixed(2)}m devolvió punto inválido. Saltando punto.`);
                                    continue;
                               }


                               // Verificar si el punto muestreado está dentro de la geometría limpia rotada
                               let isInside = false;
                                // geometryForPiPCheck ya debe ser válido (Polygon, MultiPolygon, GeometryCollection)
                                if (geometryForPiPCheck) {
                                    try {
                                        // turf.booleanPointInPolygon maneja Polygon, MultiPolygon, Feature<Polygon>, Feature<MultiPolygon>
                                        // y para GeometryCollection, verifica contra todas las geometrías dentro.
                                        isInside = turf.booleanPointInPolygon(point, geometryForPiPCheck);
                                    } catch(e) {
                                        console.warn(`Error durante booleanPointInPolygon para punto en muestreo a distancia ${i.toFixed(2)}m. Asumiendo fuera.`, point, e);
                                        isInside = false;
                                    }
                                } else {
                                    console.error("La geometría para verificación Punto-en-Polígono no es válida.");
                                    isInside = false; // Si la geometría para PiP no es válida, no se puede verificar
                                }


                                // Lógica para formar segmentos de pasada
                               if (isInside && point && point.geometry && point.geometry.coordinates) {
                                    // Si el punto está dentro, añadirlo al segmento actual
                                   currentSegmentPoints.push(point.geometry.coordinates);
                               } else {
                                    // Si el punto está fuera, significa que el segmento de pasada dentro del área limpia ha terminado (o aún no ha empezado).
                                   // Si teníamos puntos acumulados en el segmento actual, crear una LineString con ellos y añadirla a las pasadas generadas.
                                   if (currentSegmentPoints.length > 1) { // Necesitamos al menos 2 puntos para formar un segmento de línea válido
                                        try {
                                            generatedRotatedPasses.push(turf.lineString(currentSegmentPoints));
                                        } catch(e) {
                                            console.error("Error en turf.lineString al crear segmento de pasada rotada:", e);
                                        }
                                   }
                                   // Reiniciar el array de puntos para el siguiente segmento potencial
                                   currentSegmentPoints = [];
                               }
                           }

                           // Después de salir del bucle de muestreo, verificar si queda un segmento de pasada al final
                           if (currentSegmentPoints.length > 1) {
                                try {
                                    generatedRotatedPasses.push(turf.lineString(currentSegmentPoints));
                               } catch(e) {
                                    console.error("Error en turf.lineString al crear segmento final de pasada rotada:", e);
                               }
                           }

                           // Incrementar el offset para la siguiente pasada (distancia entre pasadas es el ancho de trabajo)
                           rotatedCurrentOffset += workingWidth;
                           safetyCounter++; // Incrementar contador de seguridad

                       } // Fin bucle while de pasadas

                       if (safetyCounter >= maxSweeps) {
                            console.warn(`Se alcanzó el límite máximo de ${maxSweeps} pasadas. El barrido podría no haber cubierto completamente el área limpia.`);
                       }

                   }


                   console.log(`Generadas ${generatedRotatedPasses.length} pasadas (segmentos de LineString) en el espacio rotado.`);

                   console.log(`Rotando pasadas de vuelta a la orientación original por ${-rotationAngle.toFixed(2)} grados.`);
                   generatedRotatedPasses.forEach((rotatedPass, index) => {
                       try {
                            // Asegurarse de que la pasada rotada sea una LineString válida
                            if (rotatedPass && rotatedPass.geometry && rotatedPass.geometry.type === 'LineString') {
                                 // Asegurarse de que el centroide sea válido para la rotación inversa
                                 if (!centroid || !centroid.geometry || !centroid.geometry.coordinates) {
                                     console.warn(`Centroide no válido al rotar pasada #${index}. Saltando rotación para esta pasada.`);
                                     // Si no se puede rotar, al menos añadir la pasada en el espacio rotado (para depuración visual)
                                     L.geoJSON(rotatedPass, {
                                         style: { color: '#FFA500', weight: 1, dashArray: '5, 5' } // Estilo diferente para indicar que no se rotó
                                     }).addTo(generatedPassesLayer);
                                     return;
                                 }
                                 // Rotar la geometría de la LineString de vuelta usando el ángulo opuesto y el mismo pivote
                                 const originalPassGeometry = turf.transformRotate(rotatedPass.geometry, -rotationAngle, {pivot: centroid});

                                 // Añadir la pasada rotada de vuelta al mapa
                                 L.geoJSON(originalPassGeometry, {
                                     style: { color: 'green', weight: 2 } // Estilo para las pasadas finales
                                 }).addTo(generatedPassesLayer);
                            } else {
                                 console.warn(`La pasada rotada #${index} no es un LineString válido. No se añadirá al mapa.`, rotatedPass);
                            }

                       } catch (e) {
                           console.warn(`Error al rotar una pasada de vuelta (#${index}):`, rotatedPass, e);
                            // Si falla la rotación, al menos añadir la pasada en el espacio rotado (para depuración visual)
                           if (rotatedPass && rotatedPass.geometry) {
                                L.geoJSON(rotatedPass, {
                                    style: { color: '#FFA500', weight: 1, dashArray: '5, 5' } // Estilo diferente para indicar que no se rotó
                                }).addTo(generatedPassesLayer);
                           }
                       }
                   });

                   console.log("Generación de pasadas optimizadas (excluyendo zonas a evitar, usando heurística de orientación) finalizada.");

                   // --- AQUÍ ES DONDE IMPLEMENTARÍAS LA LÓGICA AVANZADA DE PENDIENTE/CURVAS ---
                   // La lógica actual genera pasadas rectas basadas en la orientación heurística y el área limpia.
                   // Para implementar pasadas sensibles a la pendiente y curvas de nivel:
                   // Dentro del bucle 'while (rotatedCurrentOffset <= sweepLimit && safetyCounter < maxSweeps)',
                   // en lugar de generar puntos a lo largo de una línea recta (`turf.along(fullSweepLineInRotatedSpace, i, ...)`),
                   // necesitarías, para cada punto muestreado:
                   // 1. Obtener la elevación en ese punto usando `elevationGeoRaster.getValueAt(point.geometry.coordinates[0], point.geometry.coordinates[1], { planar: true })`.
                   //    Nota: `getValueAt` podría ser asíncrono, lo que requeriría usar `async/await` o `.then()` dentro del bucle, complicando la lógica.
                   // 2. Estimar la pendiente en ese punto (requiere muestrear elevación en puntos cercanos).
                   // 3. Si la pendiente > `slopeThresholdPercent`:
                   //    - Encontrar la curva de nivel más cercana al punto usando `turf.nearestPointOnLine` con `contourLinesGeoJSON`.
                   //    - Determinar la dirección de la curva de nivel en ese punto (esto es complejo, podrías necesitar calcular el bearing entre puntos cercanos en la curva o usar funciones más avanzadas si las librerías lo ofrecen).
                   //    - Mover el siguiente punto de la pasada una distancia corta en la dirección PARALELA a la curva de nivel encontrada.
                   // 4. Si la pendiente <= `slopeThresholdPercent`:
                   //    - Mover el siguiente punto de la pasada una distancia corta en la dirección general de barrido (la heurística calculada arriba).
                   // 5. Asegurarse siempre de que el punto generado esté DENTRO de `geometryForPiPCheck`.
                   // 6. Acumular estos puntos para formar los segmentos de las pasadas y luego rotarlos de vuelta.
                   // Esta lógica es significativamente más compleja que el barrido recto actual.


                loadingStatusDiv.textContent = `Pasadas generadas: ${generatedPassesFeatures.length} segmentos.`; // Count the generated segments before rotation
                console.log("--- Fin Generación de Pasadas ---");


           } catch (e) {
               console.error("Error general durante la generación de pasadas (incluida lógica de exclusión/simplificación/barrido):", e);
                // Logs de depuración de geometrías antes de la falla
               console.error("Parcel Geometry (inicio):", JSON.stringify(parcelGeometry));
               if (typeof geometryForCalculations !== 'undefined') {
                    console.error("Geometry for Calculations (después de exclusión):", JSON.stringify(geometryForCalculations));
               }
                if (typeof finalGeometryToSweep !== 'undefined') {
                    console.error("Final Geometry To Sweep (después de simplificación):", JSON.stringify(finalGeometryToSweep));
                }
                 if (typeof rotatedGeometryForSweep !== 'undefined') {
                     console.error("Rotated Geometry For Sweep (después de rotación):", rotatedGeometryForSweep ? rotatedGeometryForSweep.type : 'null/undefined', JSON.stringify(rotatedGeometryForSweep));
                 }
                  if (typeof geometryForPiPCheck !== 'undefined') {
                     console.error("Geometry For PiP Check:", geometryForPiPCheck ? geometryForPiPCheck.type : 'null/undefined', JSON.stringify(geometryForPiPCheck));
                 }


               alert("Ocurrió un error general al generar las pasadas. Revisa la consola para detalles.");
           }
        });


        // --- LÓGICA DE SELECCIÓN DE ZONAS A EVITAR (Requiere implementación adicional si quieres seleccionarlas en el mapa) ---
        // La variable global `window.exclusionFeatures` ya contiene las geometrías de exclusión cargadas
        // (Construcciones y Elementos Linea con buffer si eran líneas).
        // Tu lógica en el evento click ya filtra las que intersectan con la parcela seleccionada
        // y las usa para calcular el área limpia. Puedes usar esa variable.
        // Si quieres poder SELECCIONAR zonas a evitar manualmente en el mapa, necesitarías:
        // 1. Hacer las capas de Construcciones y Viales interactivas (onEachFeature con click listeners).
        // 2. Tener una forma (ej. un botón o modo) para indicar que estás seleccionando zonas a evitar.
        // 3. Al hacer clic en una feature de Construcción o Vial, añadir su geometría (o su buffer si es LineString)
        //    a una lista TEMPORAL de "zonas a evitar seleccionadas por el usuario" para la generación de pasadas actual.
        // 4. Usar esta lista TEMPORAL en la lógica de exclusión dentro del botón de generar pasadas,
        //    EN LUGAR de (o además de) usar la variable global `window.exclusionFeatures` completa.
        // 5. Proporcionar alguna retroalimentación visual de las zonas a evitar seleccionadas por el usuario.
        // Esta implementación es compleja y va más allá del alcance actual. Por ahora, la lógica usa TODAS
        // las exclusiones cargadas que intersectan la parcela.


        // --- LOGS INICIALES ---
        console.log("Mapa Leaflet con capas base, Catastro (WMS) inicializados.");
        console.log("La carga automática de datos geoespaciales (GeoJSON y ráster/vectoriales de elevación) comenzará al terminar de cargar el DOM.");


    </script>

</body>
</html>